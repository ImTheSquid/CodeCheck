// Generated from Java20Parser.g4 by ANTLR 4.8
#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(nonstandard_style)]
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(unused_braces)]
use antlr_rust::PredictionContextCache;
use antlr_rust::parser::{Parser, BaseParser, ParserRecog, ParserNodeType};
use antlr_rust::token_stream::TokenStream;
use antlr_rust::TokenSource;
use antlr_rust::parser_atn_simulator::ParserATNSimulator;
use antlr_rust::errors::*;
use antlr_rust::rule_context::{BaseRuleContext, CustomRuleContext, RuleContext};
use antlr_rust::recognizer::{Recognizer,Actions};
use antlr_rust::atn_deserializer::ATNDeserializer;
use antlr_rust::dfa::DFA;
use antlr_rust::atn::{ATN, INVALID_ALT};
use antlr_rust::error_strategy::{ErrorStrategy, DefaultErrorStrategy};
use antlr_rust::parser_rule_context::{BaseParserRuleContext, ParserRuleContext,cast,cast_mut};
use antlr_rust::tree::*;
use antlr_rust::token::{TOKEN_EOF,OwningToken,Token};
use antlr_rust::int_stream::EOF;
use antlr_rust::vocabulary::{Vocabulary,VocabularyImpl};
use antlr_rust::token_factory::{CommonTokenFactory,TokenFactory, TokenAware};
use super::java20parserlistener::*;
use super::java20parservisitor::*;

use antlr_rust::lazy_static;
use antlr_rust::{TidAble,TidExt};

use std::marker::PhantomData;
use std::sync::Arc;
use std::rc::Rc;
use std::convert::TryFrom;
use std::cell::RefCell;
use std::ops::{DerefMut, Deref};
use std::borrow::{Borrow,BorrowMut};
use std::any::{Any,TypeId};

		pub const EXPORTS:isize=1; 
		pub const MODULE:isize=2; 
		pub const NONSEALED:isize=3; 
		pub const OACA:isize=4; 
		pub const OPEN:isize=5; 
		pub const OPENS:isize=6; 
		pub const PERMITS:isize=7; 
		pub const PROVIDES:isize=8; 
		pub const RECORD:isize=9; 
		pub const REQUIRES:isize=10; 
		pub const SEALED:isize=11; 
		pub const TO:isize=12; 
		pub const TRANSITIVE:isize=13; 
		pub const USES:isize=14; 
		pub const VAR:isize=15; 
		pub const WITH:isize=16; 
		pub const YIELD:isize=17; 
		pub const ABSTRACT:isize=18; 
		pub const ASSERT:isize=19; 
		pub const BOOLEAN:isize=20; 
		pub const BREAK:isize=21; 
		pub const BYTE:isize=22; 
		pub const CASE:isize=23; 
		pub const CATCH:isize=24; 
		pub const CHAR:isize=25; 
		pub const CLASS:isize=26; 
		pub const CONST:isize=27; 
		pub const CONTINUE:isize=28; 
		pub const DEFAULT:isize=29; 
		pub const DO:isize=30; 
		pub const DOUBLE:isize=31; 
		pub const ELSE:isize=32; 
		pub const ENUM:isize=33; 
		pub const EXTENDS:isize=34; 
		pub const FINAL:isize=35; 
		pub const FINALLY:isize=36; 
		pub const FLOAT:isize=37; 
		pub const FOR:isize=38; 
		pub const IF:isize=39; 
		pub const GOTO:isize=40; 
		pub const IMPLEMENTS:isize=41; 
		pub const IMPORT:isize=42; 
		pub const INSTANCEOF:isize=43; 
		pub const INT:isize=44; 
		pub const INTERFACE:isize=45; 
		pub const LONG:isize=46; 
		pub const NATIVE:isize=47; 
		pub const NEW:isize=48; 
		pub const PACKAGE:isize=49; 
		pub const PRIVATE:isize=50; 
		pub const PROTECTED:isize=51; 
		pub const PUBLIC:isize=52; 
		pub const RETURN:isize=53; 
		pub const SHORT:isize=54; 
		pub const STATIC:isize=55; 
		pub const STRICTFP:isize=56; 
		pub const SUPER:isize=57; 
		pub const SWITCH:isize=58; 
		pub const SYNCHRONIZED:isize=59; 
		pub const THIS:isize=60; 
		pub const THROW:isize=61; 
		pub const THROWS:isize=62; 
		pub const TRANSIENT:isize=63; 
		pub const TRY:isize=64; 
		pub const VOID:isize=65; 
		pub const VOLATILE:isize=66; 
		pub const WHILE:isize=67; 
		pub const UNDER_SCORE:isize=68; 
		pub const IntegerLiteral:isize=69; 
		pub const FloatingPointLiteral:isize=70; 
		pub const BooleanLiteral:isize=71; 
		pub const CharacterLiteral:isize=72; 
		pub const StringLiteral:isize=73; 
		pub const TextBlock:isize=74; 
		pub const NullLiteral:isize=75; 
		pub const LPAREN:isize=76; 
		pub const RPAREN:isize=77; 
		pub const LBRACE:isize=78; 
		pub const RBRACE:isize=79; 
		pub const LBRACK:isize=80; 
		pub const RBRACK:isize=81; 
		pub const SEMI:isize=82; 
		pub const COMMA:isize=83; 
		pub const DOT:isize=84; 
		pub const ELLIPSIS:isize=85; 
		pub const AT:isize=86; 
		pub const COLONCOLON:isize=87; 
		pub const ASSIGN:isize=88; 
		pub const GT:isize=89; 
		pub const LT:isize=90; 
		pub const BANG:isize=91; 
		pub const TILDE:isize=92; 
		pub const QUESTION:isize=93; 
		pub const COLON:isize=94; 
		pub const ARROW:isize=95; 
		pub const EQUAL:isize=96; 
		pub const LE:isize=97; 
		pub const GE:isize=98; 
		pub const NOTEQUAL:isize=99; 
		pub const AND:isize=100; 
		pub const OR:isize=101; 
		pub const INC:isize=102; 
		pub const DEC:isize=103; 
		pub const ADD:isize=104; 
		pub const SUB:isize=105; 
		pub const MUL:isize=106; 
		pub const DIV:isize=107; 
		pub const BITAND:isize=108; 
		pub const BITOR:isize=109; 
		pub const CARET:isize=110; 
		pub const MOD:isize=111; 
		pub const ADD_ASSIGN:isize=112; 
		pub const SUB_ASSIGN:isize=113; 
		pub const MUL_ASSIGN:isize=114; 
		pub const DIV_ASSIGN:isize=115; 
		pub const AND_ASSIGN:isize=116; 
		pub const OR_ASSIGN:isize=117; 
		pub const XOR_ASSIGN:isize=118; 
		pub const MOD_ASSIGN:isize=119; 
		pub const LSHIFT_ASSIGN:isize=120; 
		pub const RSHIFT_ASSIGN:isize=121; 
		pub const URSHIFT_ASSIGN:isize=122; 
		pub const Identifier:isize=123; 
		pub const WS:isize=124; 
		pub const COMMENT:isize=125; 
		pub const LINE_COMMENT:isize=126;
	pub const RULE_start:usize = 0; 
	pub const RULE_literal:usize = 1; 
	pub const RULE_typeIdentifier:usize = 2; 
	pub const RULE_unqualifiedMethodIdentifier:usize = 3; 
	pub const RULE_primitiveType:usize = 4; 
	pub const RULE_numericType:usize = 5; 
	pub const RULE_integralType:usize = 6; 
	pub const RULE_floatingPointType:usize = 7; 
	pub const RULE_referenceType:usize = 8; 
	pub const RULE_coit:usize = 9; 
	pub const RULE_classOrInterfaceType:usize = 10; 
	pub const RULE_classType:usize = 11; 
	pub const RULE_interfaceType:usize = 12; 
	pub const RULE_typeVariable:usize = 13; 
	pub const RULE_arrayType:usize = 14; 
	pub const RULE_dims:usize = 15; 
	pub const RULE_typeParameter:usize = 16; 
	pub const RULE_typeParameterModifier:usize = 17; 
	pub const RULE_typeBound:usize = 18; 
	pub const RULE_additionalBound:usize = 19; 
	pub const RULE_typeArguments:usize = 20; 
	pub const RULE_typeArgumentList:usize = 21; 
	pub const RULE_typeArgument:usize = 22; 
	pub const RULE_wildcard:usize = 23; 
	pub const RULE_wildcardBounds:usize = 24; 
	pub const RULE_moduleName:usize = 25; 
	pub const RULE_packageName:usize = 26; 
	pub const RULE_typeName:usize = 27; 
	pub const RULE_packageOrTypeName:usize = 28; 
	pub const RULE_expressionName:usize = 29; 
	pub const RULE_methodName:usize = 30; 
	pub const RULE_ambiguousName:usize = 31; 
	pub const RULE_compilationUnit:usize = 32; 
	pub const RULE_ordinaryCompilationUnit:usize = 33; 
	pub const RULE_modularCompilationUnit:usize = 34; 
	pub const RULE_packageDeclaration:usize = 35; 
	pub const RULE_packageModifier:usize = 36; 
	pub const RULE_importDeclaration:usize = 37; 
	pub const RULE_singleTypeImportDeclaration:usize = 38; 
	pub const RULE_typeImportOnDemandDeclaration:usize = 39; 
	pub const RULE_singleStaticImportDeclaration:usize = 40; 
	pub const RULE_staticImportOnDemandDeclaration:usize = 41; 
	pub const RULE_topLevelClassOrInterfaceDeclaration:usize = 42; 
	pub const RULE_moduleDeclaration:usize = 43; 
	pub const RULE_moduleDirective:usize = 44; 
	pub const RULE_requiresModifier:usize = 45; 
	pub const RULE_classDeclaration:usize = 46; 
	pub const RULE_normalClassDeclaration:usize = 47; 
	pub const RULE_classModifier:usize = 48; 
	pub const RULE_typeParameters:usize = 49; 
	pub const RULE_typeParameterList:usize = 50; 
	pub const RULE_classExtends:usize = 51; 
	pub const RULE_classImplements:usize = 52; 
	pub const RULE_interfaceTypeList:usize = 53; 
	pub const RULE_classPermits:usize = 54; 
	pub const RULE_classBody:usize = 55; 
	pub const RULE_classBodyDeclaration:usize = 56; 
	pub const RULE_classMemberDeclaration:usize = 57; 
	pub const RULE_fieldDeclaration:usize = 58; 
	pub const RULE_fieldModifier:usize = 59; 
	pub const RULE_variableDeclaratorList:usize = 60; 
	pub const RULE_variableDeclarator:usize = 61; 
	pub const RULE_variableDeclaratorId:usize = 62; 
	pub const RULE_variableInitializer:usize = 63; 
	pub const RULE_unannType:usize = 64; 
	pub const RULE_unannPrimitiveType:usize = 65; 
	pub const RULE_unannReferenceType:usize = 66; 
	pub const RULE_unannClassOrInterfaceType:usize = 67; 
	pub const RULE_uCOIT:usize = 68; 
	pub const RULE_unannClassType:usize = 69; 
	pub const RULE_unannInterfaceType:usize = 70; 
	pub const RULE_unannTypeVariable:usize = 71; 
	pub const RULE_unannArrayType:usize = 72; 
	pub const RULE_methodDeclaration:usize = 73; 
	pub const RULE_methodModifier:usize = 74; 
	pub const RULE_methodHeader:usize = 75; 
	pub const RULE_result:usize = 76; 
	pub const RULE_methodDeclarator:usize = 77; 
	pub const RULE_receiverParameter:usize = 78; 
	pub const RULE_formalParameterList:usize = 79; 
	pub const RULE_formalParameter:usize = 80; 
	pub const RULE_variableArityParameter:usize = 81; 
	pub const RULE_variableModifier:usize = 82; 
	pub const RULE_throwsT:usize = 83; 
	pub const RULE_exceptionTypeList:usize = 84; 
	pub const RULE_exceptionType:usize = 85; 
	pub const RULE_methodBody:usize = 86; 
	pub const RULE_instanceInitializer:usize = 87; 
	pub const RULE_staticInitializer:usize = 88; 
	pub const RULE_constructorDeclaration:usize = 89; 
	pub const RULE_constructorModifier:usize = 90; 
	pub const RULE_constructorDeclarator:usize = 91; 
	pub const RULE_simpleTypeName:usize = 92; 
	pub const RULE_constructorBody:usize = 93; 
	pub const RULE_explicitConstructorInvocation:usize = 94; 
	pub const RULE_enumDeclaration:usize = 95; 
	pub const RULE_enumBody:usize = 96; 
	pub const RULE_enumConstantList:usize = 97; 
	pub const RULE_enumConstant:usize = 98; 
	pub const RULE_enumConstantModifier:usize = 99; 
	pub const RULE_enumBodyDeclarations:usize = 100; 
	pub const RULE_recordDeclaration:usize = 101; 
	pub const RULE_recordHeader:usize = 102; 
	pub const RULE_recordComponentList:usize = 103; 
	pub const RULE_recordComponent:usize = 104; 
	pub const RULE_variableArityRecordComponent:usize = 105; 
	pub const RULE_recordComponentModifier:usize = 106; 
	pub const RULE_recordBody:usize = 107; 
	pub const RULE_recordBodyDeclaration:usize = 108; 
	pub const RULE_compactConstructorDeclaration:usize = 109; 
	pub const RULE_interfaceDeclaration:usize = 110; 
	pub const RULE_normalInterfaceDeclaration:usize = 111; 
	pub const RULE_interfaceModifier:usize = 112; 
	pub const RULE_interfaceExtends:usize = 113; 
	pub const RULE_interfacePermits:usize = 114; 
	pub const RULE_interfaceBody:usize = 115; 
	pub const RULE_interfaceMemberDeclaration:usize = 116; 
	pub const RULE_constantDeclaration:usize = 117; 
	pub const RULE_constantModifier:usize = 118; 
	pub const RULE_interfaceMethodDeclaration:usize = 119; 
	pub const RULE_interfaceMethodModifier:usize = 120; 
	pub const RULE_annotationInterfaceDeclaration:usize = 121; 
	pub const RULE_annotationInterfaceBody:usize = 122; 
	pub const RULE_annotationInterfaceMemberDeclaration:usize = 123; 
	pub const RULE_annotationInterfaceElementDeclaration:usize = 124; 
	pub const RULE_annotationInterfaceElementModifier:usize = 125; 
	pub const RULE_defaultValue:usize = 126; 
	pub const RULE_annotation:usize = 127; 
	pub const RULE_normalAnnotation:usize = 128; 
	pub const RULE_elementValuePairList:usize = 129; 
	pub const RULE_elementValuePair:usize = 130; 
	pub const RULE_elementValue:usize = 131; 
	pub const RULE_elementValueArrayInitializer:usize = 132; 
	pub const RULE_elementValueList:usize = 133; 
	pub const RULE_markerAnnotation:usize = 134; 
	pub const RULE_singleElementAnnotation:usize = 135; 
	pub const RULE_arrayInitializer:usize = 136; 
	pub const RULE_variableInitializerList:usize = 137; 
	pub const RULE_block:usize = 138; 
	pub const RULE_blockStatements:usize = 139; 
	pub const RULE_blockStatement:usize = 140; 
	pub const RULE_localClassOrInterfaceDeclaration:usize = 141; 
	pub const RULE_localVariableDeclaration:usize = 142; 
	pub const RULE_localVariableType:usize = 143; 
	pub const RULE_localVariableDeclarationStatement:usize = 144; 
	pub const RULE_statement:usize = 145; 
	pub const RULE_statementNoShortIf:usize = 146; 
	pub const RULE_statementWithoutTrailingSubstatement:usize = 147; 
	pub const RULE_emptyStatement:usize = 148; 
	pub const RULE_labeledStatement:usize = 149; 
	pub const RULE_labeledStatementNoShortIf:usize = 150; 
	pub const RULE_expressionStatement:usize = 151; 
	pub const RULE_statementExpression:usize = 152; 
	pub const RULE_ifThenStatement:usize = 153; 
	pub const RULE_ifThenElseStatement:usize = 154; 
	pub const RULE_ifThenElseStatementNoShortIf:usize = 155; 
	pub const RULE_assertStatement:usize = 156; 
	pub const RULE_switchStatement:usize = 157; 
	pub const RULE_switchBlock:usize = 158; 
	pub const RULE_switchRule:usize = 159; 
	pub const RULE_switchBlockStatementGroup:usize = 160; 
	pub const RULE_switchLabel:usize = 161; 
	pub const RULE_caseConstant:usize = 162; 
	pub const RULE_whileStatement:usize = 163; 
	pub const RULE_whileStatementNoShortIf:usize = 164; 
	pub const RULE_doStatement:usize = 165; 
	pub const RULE_forStatement:usize = 166; 
	pub const RULE_forStatementNoShortIf:usize = 167; 
	pub const RULE_basicForStatement:usize = 168; 
	pub const RULE_basicForStatementNoShortIf:usize = 169; 
	pub const RULE_forInit:usize = 170; 
	pub const RULE_forUpdate:usize = 171; 
	pub const RULE_statementExpressionList:usize = 172; 
	pub const RULE_enhancedForStatement:usize = 173; 
	pub const RULE_enhancedForStatementNoShortIf:usize = 174; 
	pub const RULE_breakStatement:usize = 175; 
	pub const RULE_continueStatement:usize = 176; 
	pub const RULE_returnStatement:usize = 177; 
	pub const RULE_throwStatement:usize = 178; 
	pub const RULE_synchronizedStatement:usize = 179; 
	pub const RULE_tryStatement:usize = 180; 
	pub const RULE_catches:usize = 181; 
	pub const RULE_catchClause:usize = 182; 
	pub const RULE_catchFormalParameter:usize = 183; 
	pub const RULE_catchType:usize = 184; 
	pub const RULE_finallyBlock:usize = 185; 
	pub const RULE_tryWithResourcesStatement:usize = 186; 
	pub const RULE_resourceSpecification:usize = 187; 
	pub const RULE_resourceList:usize = 188; 
	pub const RULE_resource:usize = 189; 
	pub const RULE_variableAccess:usize = 190; 
	pub const RULE_yieldStatement:usize = 191; 
	pub const RULE_pattern:usize = 192; 
	pub const RULE_typePattern:usize = 193; 
	pub const RULE_expression:usize = 194; 
	pub const RULE_primary:usize = 195; 
	pub const RULE_primaryNoNewArray:usize = 196; 
	pub const RULE_pNNA:usize = 197; 
	pub const RULE_classLiteral:usize = 198; 
	pub const RULE_classInstanceCreationExpression:usize = 199; 
	pub const RULE_unqualifiedClassInstanceCreationExpression:usize = 200; 
	pub const RULE_classOrInterfaceTypeToInstantiate:usize = 201; 
	pub const RULE_typeArgumentsOrDiamond:usize = 202; 
	pub const RULE_arrayCreationExpression:usize = 203; 
	pub const RULE_arrayCreationExpressionWithoutInitializer:usize = 204; 
	pub const RULE_arrayCreationExpressionWithInitializer:usize = 205; 
	pub const RULE_dimExprs:usize = 206; 
	pub const RULE_dimExpr:usize = 207; 
	pub const RULE_arrayAccess:usize = 208; 
	pub const RULE_fieldAccess:usize = 209; 
	pub const RULE_methodInvocation:usize = 210; 
	pub const RULE_argumentList:usize = 211; 
	pub const RULE_methodReference:usize = 212; 
	pub const RULE_postfixExpression:usize = 213; 
	pub const RULE_pfE:usize = 214; 
	pub const RULE_postIncrementExpression:usize = 215; 
	pub const RULE_postDecrementExpression:usize = 216; 
	pub const RULE_unaryExpression:usize = 217; 
	pub const RULE_preIncrementExpression:usize = 218; 
	pub const RULE_preDecrementExpression:usize = 219; 
	pub const RULE_unaryExpressionNotPlusMinus:usize = 220; 
	pub const RULE_castExpression:usize = 221; 
	pub const RULE_multiplicativeExpression:usize = 222; 
	pub const RULE_additiveExpression:usize = 223; 
	pub const RULE_shiftExpression:usize = 224; 
	pub const RULE_relationalExpression:usize = 225; 
	pub const RULE_equalityExpression:usize = 226; 
	pub const RULE_andExpression:usize = 227; 
	pub const RULE_exclusiveOrExpression:usize = 228; 
	pub const RULE_inclusiveOrExpression:usize = 229; 
	pub const RULE_conditionalAndExpression:usize = 230; 
	pub const RULE_conditionalOrExpression:usize = 231; 
	pub const RULE_conditionalExpression:usize = 232; 
	pub const RULE_assignmentExpression:usize = 233; 
	pub const RULE_assignment:usize = 234; 
	pub const RULE_leftHandSide:usize = 235; 
	pub const RULE_assignmentOperator:usize = 236; 
	pub const RULE_lambdaExpression:usize = 237; 
	pub const RULE_lambdaParameters:usize = 238; 
	pub const RULE_lambdaParameterList:usize = 239; 
	pub const RULE_lambdaParameter:usize = 240; 
	pub const RULE_lambdaParameterType:usize = 241; 
	pub const RULE_lambdaBody:usize = 242; 
	pub const RULE_switchExpression:usize = 243; 
	pub const RULE_constantExpression:usize = 244;
	pub const ruleNames: [&'static str; 245] =  [
		"start", "literal", "typeIdentifier", "unqualifiedMethodIdentifier", "primitiveType", 
		"numericType", "integralType", "floatingPointType", "referenceType", "coit", 
		"classOrInterfaceType", "classType", "interfaceType", "typeVariable", 
		"arrayType", "dims", "typeParameter", "typeParameterModifier", "typeBound", 
		"additionalBound", "typeArguments", "typeArgumentList", "typeArgument", 
		"wildcard", "wildcardBounds", "moduleName", "packageName", "typeName", 
		"packageOrTypeName", "expressionName", "methodName", "ambiguousName", 
		"compilationUnit", "ordinaryCompilationUnit", "modularCompilationUnit", 
		"packageDeclaration", "packageModifier", "importDeclaration", "singleTypeImportDeclaration", 
		"typeImportOnDemandDeclaration", "singleStaticImportDeclaration", "staticImportOnDemandDeclaration", 
		"topLevelClassOrInterfaceDeclaration", "moduleDeclaration", "moduleDirective", 
		"requiresModifier", "classDeclaration", "normalClassDeclaration", "classModifier", 
		"typeParameters", "typeParameterList", "classExtends", "classImplements", 
		"interfaceTypeList", "classPermits", "classBody", "classBodyDeclaration", 
		"classMemberDeclaration", "fieldDeclaration", "fieldModifier", "variableDeclaratorList", 
		"variableDeclarator", "variableDeclaratorId", "variableInitializer", "unannType", 
		"unannPrimitiveType", "unannReferenceType", "unannClassOrInterfaceType", 
		"uCOIT", "unannClassType", "unannInterfaceType", "unannTypeVariable", 
		"unannArrayType", "methodDeclaration", "methodModifier", "methodHeader", 
		"result", "methodDeclarator", "receiverParameter", "formalParameterList", 
		"formalParameter", "variableArityParameter", "variableModifier", "throwsT", 
		"exceptionTypeList", "exceptionType", "methodBody", "instanceInitializer", 
		"staticInitializer", "constructorDeclaration", "constructorModifier", 
		"constructorDeclarator", "simpleTypeName", "constructorBody", "explicitConstructorInvocation", 
		"enumDeclaration", "enumBody", "enumConstantList", "enumConstant", "enumConstantModifier", 
		"enumBodyDeclarations", "recordDeclaration", "recordHeader", "recordComponentList", 
		"recordComponent", "variableArityRecordComponent", "recordComponentModifier", 
		"recordBody", "recordBodyDeclaration", "compactConstructorDeclaration", 
		"interfaceDeclaration", "normalInterfaceDeclaration", "interfaceModifier", 
		"interfaceExtends", "interfacePermits", "interfaceBody", "interfaceMemberDeclaration", 
		"constantDeclaration", "constantModifier", "interfaceMethodDeclaration", 
		"interfaceMethodModifier", "annotationInterfaceDeclaration", "annotationInterfaceBody", 
		"annotationInterfaceMemberDeclaration", "annotationInterfaceElementDeclaration", 
		"annotationInterfaceElementModifier", "defaultValue", "annotation", "normalAnnotation", 
		"elementValuePairList", "elementValuePair", "elementValue", "elementValueArrayInitializer", 
		"elementValueList", "markerAnnotation", "singleElementAnnotation", "arrayInitializer", 
		"variableInitializerList", "block", "blockStatements", "blockStatement", 
		"localClassOrInterfaceDeclaration", "localVariableDeclaration", "localVariableType", 
		"localVariableDeclarationStatement", "statement", "statementNoShortIf", 
		"statementWithoutTrailingSubstatement", "emptyStatement", "labeledStatement", 
		"labeledStatementNoShortIf", "expressionStatement", "statementExpression", 
		"ifThenStatement", "ifThenElseStatement", "ifThenElseStatementNoShortIf", 
		"assertStatement", "switchStatement", "switchBlock", "switchRule", "switchBlockStatementGroup", 
		"switchLabel", "caseConstant", "whileStatement", "whileStatementNoShortIf", 
		"doStatement", "forStatement", "forStatementNoShortIf", "basicForStatement", 
		"basicForStatementNoShortIf", "forInit", "forUpdate", "statementExpressionList", 
		"enhancedForStatement", "enhancedForStatementNoShortIf", "breakStatement", 
		"continueStatement", "returnStatement", "throwStatement", "synchronizedStatement", 
		"tryStatement", "catches", "catchClause", "catchFormalParameter", "catchType", 
		"finallyBlock", "tryWithResourcesStatement", "resourceSpecification", 
		"resourceList", "resource", "variableAccess", "yieldStatement", "pattern", 
		"typePattern", "expression", "primary", "primaryNoNewArray", "pNNA", "classLiteral", 
		"classInstanceCreationExpression", "unqualifiedClassInstanceCreationExpression", 
		"classOrInterfaceTypeToInstantiate", "typeArgumentsOrDiamond", "arrayCreationExpression", 
		"arrayCreationExpressionWithoutInitializer", "arrayCreationExpressionWithInitializer", 
		"dimExprs", "dimExpr", "arrayAccess", "fieldAccess", "methodInvocation", 
		"argumentList", "methodReference", "postfixExpression", "pfE", "postIncrementExpression", 
		"postDecrementExpression", "unaryExpression", "preIncrementExpression", 
		"preDecrementExpression", "unaryExpressionNotPlusMinus", "castExpression", 
		"multiplicativeExpression", "additiveExpression", "shiftExpression", "relationalExpression", 
		"equalityExpression", "andExpression", "exclusiveOrExpression", "inclusiveOrExpression", 
		"conditionalAndExpression", "conditionalOrExpression", "conditionalExpression", 
		"assignmentExpression", "assignment", "leftHandSide", "assignmentOperator", 
		"lambdaExpression", "lambdaParameters", "lambdaParameterList", "lambdaParameter", 
		"lambdaParameterType", "lambdaBody", "switchExpression", "constantExpression"
	];


	pub const _LITERAL_NAMES: [Option<&'static str>;123] = [
		None, Some("'exports'"), Some("'module'"), Some("'non-sealed'"), Some("'<>'"), 
		Some("'open'"), Some("'opens'"), Some("'permits'"), Some("'provides'"), 
		Some("'record'"), Some("'requires'"), Some("'sealed'"), Some("'to'"), 
		Some("'transitive'"), Some("'uses'"), Some("'var'"), Some("'with'"), Some("'yield'"), 
		Some("'abstract'"), Some("'assert'"), Some("'boolean'"), Some("'break'"), 
		Some("'byte'"), Some("'case'"), Some("'catch'"), Some("'char'"), Some("'class'"), 
		Some("'const'"), Some("'continue'"), Some("'default'"), Some("'do'"), 
		Some("'double'"), Some("'else'"), Some("'enum'"), Some("'extends'"), Some("'final'"), 
		Some("'finally'"), Some("'float'"), Some("'for'"), Some("'if'"), Some("'goto'"), 
		Some("'implements'"), Some("'import'"), Some("'instanceof'"), Some("'int'"), 
		Some("'interface'"), Some("'long'"), Some("'native'"), Some("'new'"), 
		Some("'package'"), Some("'private'"), Some("'protected'"), Some("'public'"), 
		Some("'return'"), Some("'short'"), Some("'static'"), Some("'strictfp'"), 
		Some("'super'"), Some("'switch'"), Some("'synchronized'"), Some("'this'"), 
		Some("'throw'"), Some("'throws'"), Some("'transient'"), Some("'try'"), 
		Some("'void'"), Some("'volatile'"), Some("'while'"), Some("'_'"), None, 
		None, None, None, None, None, Some("'null'"), Some("'('"), Some("')'"), 
		Some("'{'"), Some("'}'"), Some("'['"), Some("']'"), Some("';'"), Some("','"), 
		Some("'.'"), Some("'...'"), Some("'@'"), Some("'::'"), Some("'='"), Some("'>'"), 
		Some("'<'"), Some("'!'"), Some("'~'"), Some("'?'"), Some("':'"), Some("'->'"), 
		Some("'=='"), Some("'<='"), Some("'>='"), Some("'!='"), Some("'&&'"), 
		Some("'||'"), Some("'++'"), Some("'--'"), Some("'+'"), Some("'-'"), Some("'*'"), 
		Some("'/'"), Some("'&'"), Some("'|'"), Some("'^'"), Some("'%'"), Some("'+='"), 
		Some("'-='"), Some("'*='"), Some("'/='"), Some("'&='"), Some("'|='"), 
		Some("'^='"), Some("'%='"), Some("'<<='"), Some("'>>='"), Some("'>>>='")
	];
	pub const _SYMBOLIC_NAMES: [Option<&'static str>;127]  = [
		None, Some("EXPORTS"), Some("MODULE"), Some("NONSEALED"), Some("OACA"), 
		Some("OPEN"), Some("OPENS"), Some("PERMITS"), Some("PROVIDES"), Some("RECORD"), 
		Some("REQUIRES"), Some("SEALED"), Some("TO"), Some("TRANSITIVE"), Some("USES"), 
		Some("VAR"), Some("WITH"), Some("YIELD"), Some("ABSTRACT"), Some("ASSERT"), 
		Some("BOOLEAN"), Some("BREAK"), Some("BYTE"), Some("CASE"), Some("CATCH"), 
		Some("CHAR"), Some("CLASS"), Some("CONST"), Some("CONTINUE"), Some("DEFAULT"), 
		Some("DO"), Some("DOUBLE"), Some("ELSE"), Some("ENUM"), Some("EXTENDS"), 
		Some("FINAL"), Some("FINALLY"), Some("FLOAT"), Some("FOR"), Some("IF"), 
		Some("GOTO"), Some("IMPLEMENTS"), Some("IMPORT"), Some("INSTANCEOF"), 
		Some("INT"), Some("INTERFACE"), Some("LONG"), Some("NATIVE"), Some("NEW"), 
		Some("PACKAGE"), Some("PRIVATE"), Some("PROTECTED"), Some("PUBLIC"), Some("RETURN"), 
		Some("SHORT"), Some("STATIC"), Some("STRICTFP"), Some("SUPER"), Some("SWITCH"), 
		Some("SYNCHRONIZED"), Some("THIS"), Some("THROW"), Some("THROWS"), Some("TRANSIENT"), 
		Some("TRY"), Some("VOID"), Some("VOLATILE"), Some("WHILE"), Some("UNDER_SCORE"), 
		Some("IntegerLiteral"), Some("FloatingPointLiteral"), Some("BooleanLiteral"), 
		Some("CharacterLiteral"), Some("StringLiteral"), Some("TextBlock"), Some("NullLiteral"), 
		Some("LPAREN"), Some("RPAREN"), Some("LBRACE"), Some("RBRACE"), Some("LBRACK"), 
		Some("RBRACK"), Some("SEMI"), Some("COMMA"), Some("DOT"), Some("ELLIPSIS"), 
		Some("AT"), Some("COLONCOLON"), Some("ASSIGN"), Some("GT"), Some("LT"), 
		Some("BANG"), Some("TILDE"), Some("QUESTION"), Some("COLON"), Some("ARROW"), 
		Some("EQUAL"), Some("LE"), Some("GE"), Some("NOTEQUAL"), Some("AND"), 
		Some("OR"), Some("INC"), Some("DEC"), Some("ADD"), Some("SUB"), Some("MUL"), 
		Some("DIV"), Some("BITAND"), Some("BITOR"), Some("CARET"), Some("MOD"), 
		Some("ADD_ASSIGN"), Some("SUB_ASSIGN"), Some("MUL_ASSIGN"), Some("DIV_ASSIGN"), 
		Some("AND_ASSIGN"), Some("OR_ASSIGN"), Some("XOR_ASSIGN"), Some("MOD_ASSIGN"), 
		Some("LSHIFT_ASSIGN"), Some("RSHIFT_ASSIGN"), Some("URSHIFT_ASSIGN"), 
		Some("Identifier"), Some("WS"), Some("COMMENT"), Some("LINE_COMMENT")
	];
	lazy_static!{
	    static ref _shared_context_cache: Arc<PredictionContextCache> = Arc::new(PredictionContextCache::new());
		static ref VOCABULARY: Box<dyn Vocabulary> = Box::new(VocabularyImpl::new(_LITERAL_NAMES.iter(), _SYMBOLIC_NAMES.iter(), None));
	}


type BaseParserType<'input, I> =
	BaseParser<'input,Java20ParserExt<'input>, I, Java20ParserContextType , dyn Java20ParserListener<'input> + 'input >;

type TokenType<'input> = <LocalTokenFactory<'input> as TokenFactory<'input>>::Tok;
pub type LocalTokenFactory<'input> = CommonTokenFactory;

pub type Java20ParserTreeWalker<'input,'a> =
	ParseTreeWalker<'input, 'a, Java20ParserContextType , dyn Java20ParserListener<'input> + 'a>;

/// Parser for Java20Parser grammar
pub struct Java20Parser<'input,I,H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	base:BaseParserType<'input,I>,
	interpreter:Arc<ParserATNSimulator>,
	_shared_context_cache: Box<PredictionContextCache>,
    pub err_handler: H,
}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn get_serialized_atn() -> &'static str { _serializedATN }

    pub fn set_error_strategy(&mut self, strategy: H) {
        self.err_handler = strategy
    }

    pub fn with_strategy(input: I, strategy: H) -> Self {
		antlr_rust::recognizer::check_version("0","3");
		let interpreter = Arc::new(ParserATNSimulator::new(
			_ATN.clone(),
			_decision_to_DFA.clone(),
			_shared_context_cache.clone(),
		));
		Self {
			base: BaseParser::new_base_parser(
				input,
				Arc::clone(&interpreter),
				Java20ParserExt{
					_pd: Default::default(),
				}
			),
			interpreter,
            _shared_context_cache: Box::new(PredictionContextCache::new()),
            err_handler: strategy,
        }
    }

}

type DynStrategy<'input,I> = Box<dyn ErrorStrategy<'input,BaseParserType<'input,I>> + 'input>;

impl<'input, I> Java20Parser<'input, I, DynStrategy<'input,I>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
{
    pub fn with_dyn_strategy(input: I) -> Self{
    	Self::with_strategy(input,Box::new(DefaultErrorStrategy::new()))
    }
}

impl<'input, I> Java20Parser<'input, I, DefaultErrorStrategy<'input,Java20ParserContextType>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
{
    pub fn new(input: I) -> Self{
    	Self::with_strategy(input,DefaultErrorStrategy::new())
    }
}

/// Trait for monomorphized trait object that corresponds to the nodes of parse tree generated for Java20Parser
pub trait Java20ParserContext<'input>:
	for<'x> Listenable<dyn Java20ParserListener<'input> + 'x > + 
	for<'x> Visitable<dyn Java20ParserVisitor<'input> + 'x > + 
	ParserRuleContext<'input, TF=LocalTokenFactory<'input>, Ctx=Java20ParserContextType>
{}

antlr_rust::coerce_from!{ 'input : Java20ParserContext<'input> }

impl<'input, 'x, T> VisitableDyn<T> for dyn Java20ParserContext<'input> + 'input
where
    T: Java20ParserVisitor<'input> + 'x,
{
    fn accept_dyn(&self, visitor: &mut T) {
        self.accept(visitor as &mut (dyn Java20ParserVisitor<'input> + 'x))
    }
}

impl<'input> Java20ParserContext<'input> for TerminalNode<'input,Java20ParserContextType> {}
impl<'input> Java20ParserContext<'input> for ErrorNode<'input,Java20ParserContextType> {}

antlr_rust::tid! { impl<'input> TidAble<'input> for dyn Java20ParserContext<'input> + 'input }

antlr_rust::tid! { impl<'input> TidAble<'input> for dyn Java20ParserListener<'input> + 'input }

pub struct Java20ParserContextType;
antlr_rust::tid!{Java20ParserContextType}

impl<'input> ParserNodeType<'input> for Java20ParserContextType{
	type TF = LocalTokenFactory<'input>;
	type Type = dyn Java20ParserContext<'input> + 'input;
}

impl<'input, I, H> Deref for Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
    type Target = BaseParserType<'input,I>;

    fn deref(&self) -> &Self::Target {
        &self.base
    }
}

impl<'input, I, H> DerefMut for Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.base
    }
}

pub struct Java20ParserExt<'input>{
	_pd: PhantomData<&'input str>,
}

impl<'input> Java20ParserExt<'input>{
}
antlr_rust::tid! { Java20ParserExt<'a> }

impl<'input> TokenAware<'input> for Java20ParserExt<'input>{
	type TF = LocalTokenFactory<'input>;
}

impl<'input,I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>> ParserRecog<'input, BaseParserType<'input,I>> for Java20ParserExt<'input>{}

impl<'input,I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>> Actions<'input, BaseParserType<'input,I>> for Java20ParserExt<'input>{
	fn get_grammar_file_name(&self) -> & str{ "Java20Parser.g4"}

   	fn get_rule_names(&self) -> &[& str] {&ruleNames}

   	fn get_vocabulary(&self) -> &dyn Vocabulary { &**VOCABULARY }
	fn sempred(_localctx: Option<&(dyn Java20ParserContext<'input> + 'input)>, rule_index: isize, pred_index: isize,
			   recog:&mut BaseParserType<'input,I>
	)->bool{
		match rule_index {
					222 => Java20Parser::<'input,I,_>::multiplicativeExpression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					223 => Java20Parser::<'input,I,_>::additiveExpression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					224 => Java20Parser::<'input,I,_>::shiftExpression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					225 => Java20Parser::<'input,I,_>::relationalExpression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					226 => Java20Parser::<'input,I,_>::equalityExpression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					227 => Java20Parser::<'input,I,_>::andExpression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					228 => Java20Parser::<'input,I,_>::exclusiveOrExpression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					229 => Java20Parser::<'input,I,_>::inclusiveOrExpression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					230 => Java20Parser::<'input,I,_>::conditionalAndExpression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					231 => Java20Parser::<'input,I,_>::conditionalOrExpression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
			_ => true
		}
	}
}

impl<'input, I> Java20Parser<'input, I, DefaultErrorStrategy<'input,Java20ParserContextType>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
{
	fn multiplicativeExpression_sempred(_localctx: Option<&MultiplicativeExpressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				0=>{
					recog.precpred(None, 3)
				}
				1=>{
					recog.precpred(None, 2)
				}
				2=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn additiveExpression_sempred(_localctx: Option<&AdditiveExpressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				3=>{
					recog.precpred(None, 2)
				}
				4=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn shiftExpression_sempred(_localctx: Option<&ShiftExpressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				5=>{
					recog.precpred(None, 3)
				}
				6=>{
					recog.precpred(None, 2)
				}
				7=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn relationalExpression_sempred(_localctx: Option<&RelationalExpressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				8=>{
					recog.precpred(None, 5)
				}
				9=>{
					recog.precpred(None, 4)
				}
				10=>{
					recog.precpred(None, 3)
				}
				11=>{
					recog.precpred(None, 2)
				}
				12=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn equalityExpression_sempred(_localctx: Option<&EqualityExpressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				13=>{
					recog.precpred(None, 2)
				}
				14=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn andExpression_sempred(_localctx: Option<&AndExpressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				15=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn exclusiveOrExpression_sempred(_localctx: Option<&ExclusiveOrExpressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				16=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn inclusiveOrExpression_sempred(_localctx: Option<&InclusiveOrExpressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				17=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn conditionalAndExpression_sempred(_localctx: Option<&ConditionalAndExpressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				18=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn conditionalOrExpression_sempred(_localctx: Option<&ConditionalOrExpressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				19=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
}
//------------------- start ----------------
pub type StartContextAll<'input> = StartContext<'input>;


pub type StartContext<'input> = BaseParserRuleContext<'input,StartContextExt<'input>>;

#[derive(Clone)]
pub struct StartContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for StartContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for StartContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_start(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_start(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for StartContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_start(self);
	}
}

impl<'input> CustomRuleContext<'input> for StartContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_start }
	//fn type_rule_index() -> usize where Self: Sized { RULE_start }
}
antlr_rust::tid!{StartContextExt<'a>}

impl<'input> StartContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StartContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StartContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StartContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<StartContextExt<'input>>{

fn compilationUnit(&self) -> Option<Rc<CompilationUnitContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token EOF
/// Returns `None` if there is no child corresponding to token EOF
fn EOF(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(EOF, 0)
}

}

impl<'input> StartContextAttrs<'input> for StartContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn start(&mut self,)
	-> Result<Rc<StartContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StartContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 0, RULE_start);
        let mut _localctx: Rc<StartContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule compilationUnit*/
			recog.base.set_state(490);
			recog.compilationUnit()?;

			recog.base.set_state(491);
			recog.base.match_token(EOF,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- literal ----------------
pub type LiteralContextAll<'input> = LiteralContext<'input>;


pub type LiteralContext<'input> = BaseParserRuleContext<'input,LiteralContextExt<'input>>;

#[derive(Clone)]
pub struct LiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for LiteralContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for LiteralContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_literal(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_literal(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for LiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_literal(self);
	}
}

impl<'input> CustomRuleContext<'input> for LiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_literal }
	//fn type_rule_index() -> usize where Self: Sized { RULE_literal }
}
antlr_rust::tid!{LiteralContextExt<'a>}

impl<'input> LiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LiteralContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<LiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IntegerLiteral
/// Returns `None` if there is no child corresponding to token IntegerLiteral
fn IntegerLiteral(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(IntegerLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token FloatingPointLiteral
/// Returns `None` if there is no child corresponding to token FloatingPointLiteral
fn FloatingPointLiteral(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(FloatingPointLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token BooleanLiteral
/// Returns `None` if there is no child corresponding to token BooleanLiteral
fn BooleanLiteral(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(BooleanLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token CharacterLiteral
/// Returns `None` if there is no child corresponding to token CharacterLiteral
fn CharacterLiteral(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(CharacterLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token StringLiteral
/// Returns `None` if there is no child corresponding to token StringLiteral
fn StringLiteral(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(StringLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token TextBlock
/// Returns `None` if there is no child corresponding to token TextBlock
fn TextBlock(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(TextBlock, 0)
}
/// Retrieves first TerminalNode corresponding to token NullLiteral
/// Returns `None` if there is no child corresponding to token NullLiteral
fn NullLiteral(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(NullLiteral, 0)
}

}

impl<'input> LiteralContextAttrs<'input> for LiteralContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn literal(&mut self,)
	-> Result<Rc<LiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 2, RULE_literal);
        let mut _localctx: Rc<LiteralContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(493);
			_la = recog.base.input.la(1);
			if { !(((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeIdentifier ----------------
pub type TypeIdentifierContextAll<'input> = TypeIdentifierContext<'input>;


pub type TypeIdentifierContext<'input> = BaseParserRuleContext<'input,TypeIdentifierContextExt<'input>>;

#[derive(Clone)]
pub struct TypeIdentifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for TypeIdentifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for TypeIdentifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeIdentifier(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_typeIdentifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for TypeIdentifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_typeIdentifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeIdentifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeIdentifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeIdentifier }
}
antlr_rust::tid!{TypeIdentifierContextExt<'a>}

impl<'input> TypeIdentifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeIdentifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeIdentifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeIdentifierContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<TypeIdentifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}

}

impl<'input> TypeIdentifierContextAttrs<'input> for TypeIdentifierContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeIdentifier(&mut self,)
	-> Result<Rc<TypeIdentifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeIdentifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 4, RULE_typeIdentifier);
        let mut _localctx: Rc<TypeIdentifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(495);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unqualifiedMethodIdentifier ----------------
pub type UnqualifiedMethodIdentifierContextAll<'input> = UnqualifiedMethodIdentifierContext<'input>;


pub type UnqualifiedMethodIdentifierContext<'input> = BaseParserRuleContext<'input,UnqualifiedMethodIdentifierContextExt<'input>>;

#[derive(Clone)]
pub struct UnqualifiedMethodIdentifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for UnqualifiedMethodIdentifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for UnqualifiedMethodIdentifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unqualifiedMethodIdentifier(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_unqualifiedMethodIdentifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for UnqualifiedMethodIdentifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_unqualifiedMethodIdentifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnqualifiedMethodIdentifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unqualifiedMethodIdentifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unqualifiedMethodIdentifier }
}
antlr_rust::tid!{UnqualifiedMethodIdentifierContextExt<'a>}

impl<'input> UnqualifiedMethodIdentifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnqualifiedMethodIdentifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnqualifiedMethodIdentifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnqualifiedMethodIdentifierContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<UnqualifiedMethodIdentifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}

}

impl<'input> UnqualifiedMethodIdentifierContextAttrs<'input> for UnqualifiedMethodIdentifierContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unqualifiedMethodIdentifier(&mut self,)
	-> Result<Rc<UnqualifiedMethodIdentifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnqualifiedMethodIdentifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 6, RULE_unqualifiedMethodIdentifier);
        let mut _localctx: Rc<UnqualifiedMethodIdentifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(497);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- primitiveType ----------------
pub type PrimitiveTypeContextAll<'input> = PrimitiveTypeContext<'input>;


pub type PrimitiveTypeContext<'input> = BaseParserRuleContext<'input,PrimitiveTypeContextExt<'input>>;

#[derive(Clone)]
pub struct PrimitiveTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for PrimitiveTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for PrimitiveTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_primitiveType(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_primitiveType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for PrimitiveTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_primitiveType(self);
	}
}

impl<'input> CustomRuleContext<'input> for PrimitiveTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primitiveType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primitiveType }
}
antlr_rust::tid!{PrimitiveTypeContextExt<'a>}

impl<'input> PrimitiveTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrimitiveTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrimitiveTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrimitiveTypeContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<PrimitiveTypeContextExt<'input>>{

fn numericType(&self) -> Option<Rc<NumericTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token BOOLEAN
/// Returns `None` if there is no child corresponding to token BOOLEAN
fn BOOLEAN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(BOOLEAN, 0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> PrimitiveTypeContextAttrs<'input> for PrimitiveTypeContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn primitiveType(&mut self,)
	-> Result<Rc<PrimitiveTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrimitiveTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 8, RULE_primitiveType);
        let mut _localctx: Rc<PrimitiveTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(502);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(499);
				recog.annotation()?;

				}
				}
				recog.base.set_state(504);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(507);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 BYTE | CHAR | DOUBLE | FLOAT | INT | LONG | SHORT 
				=> {
					{
					/*InvokeRule numericType*/
					recog.base.set_state(505);
					recog.numericType()?;

					}
				}

			 BOOLEAN 
				=> {
					{
					recog.base.set_state(506);
					recog.base.match_token(BOOLEAN,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- numericType ----------------
pub type NumericTypeContextAll<'input> = NumericTypeContext<'input>;


pub type NumericTypeContext<'input> = BaseParserRuleContext<'input,NumericTypeContextExt<'input>>;

#[derive(Clone)]
pub struct NumericTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for NumericTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for NumericTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_numericType(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_numericType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for NumericTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_numericType(self);
	}
}

impl<'input> CustomRuleContext<'input> for NumericTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_numericType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_numericType }
}
antlr_rust::tid!{NumericTypeContextExt<'a>}

impl<'input> NumericTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NumericTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NumericTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NumericTypeContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<NumericTypeContextExt<'input>>{

fn integralType(&self) -> Option<Rc<IntegralTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn floatingPointType(&self) -> Option<Rc<FloatingPointTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NumericTypeContextAttrs<'input> for NumericTypeContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn numericType(&mut self,)
	-> Result<Rc<NumericTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NumericTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 10, RULE_numericType);
        let mut _localctx: Rc<NumericTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(511);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 BYTE | CHAR | INT | LONG | SHORT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule integralType*/
					recog.base.set_state(509);
					recog.integralType()?;

					}
				}

			 DOUBLE | FLOAT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule floatingPointType*/
					recog.base.set_state(510);
					recog.floatingPointType()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- integralType ----------------
pub type IntegralTypeContextAll<'input> = IntegralTypeContext<'input>;


pub type IntegralTypeContext<'input> = BaseParserRuleContext<'input,IntegralTypeContextExt<'input>>;

#[derive(Clone)]
pub struct IntegralTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for IntegralTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for IntegralTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_integralType(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_integralType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for IntegralTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_integralType(self);
	}
}

impl<'input> CustomRuleContext<'input> for IntegralTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_integralType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_integralType }
}
antlr_rust::tid!{IntegralTypeContextExt<'a>}

impl<'input> IntegralTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IntegralTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IntegralTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IntegralTypeContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<IntegralTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token BYTE
/// Returns `None` if there is no child corresponding to token BYTE
fn BYTE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(BYTE, 0)
}
/// Retrieves first TerminalNode corresponding to token SHORT
/// Returns `None` if there is no child corresponding to token SHORT
fn SHORT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SHORT, 0)
}
/// Retrieves first TerminalNode corresponding to token INT
/// Returns `None` if there is no child corresponding to token INT
fn INT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(INT, 0)
}
/// Retrieves first TerminalNode corresponding to token LONG
/// Returns `None` if there is no child corresponding to token LONG
fn LONG(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LONG, 0)
}
/// Retrieves first TerminalNode corresponding to token CHAR
/// Returns `None` if there is no child corresponding to token CHAR
fn CHAR(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(CHAR, 0)
}

}

impl<'input> IntegralTypeContextAttrs<'input> for IntegralTypeContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn integralType(&mut self,)
	-> Result<Rc<IntegralTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IntegralTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 12, RULE_integralType);
        let mut _localctx: Rc<IntegralTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(513);
			_la = recog.base.input.la(1);
			if { !(_la==BYTE || _la==CHAR || ((((_la - 44)) & !0x3f) == 0 && ((1usize << (_la - 44)) & ((1usize << (INT - 44)) | (1usize << (LONG - 44)) | (1usize << (SHORT - 44)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- floatingPointType ----------------
pub type FloatingPointTypeContextAll<'input> = FloatingPointTypeContext<'input>;


pub type FloatingPointTypeContext<'input> = BaseParserRuleContext<'input,FloatingPointTypeContextExt<'input>>;

#[derive(Clone)]
pub struct FloatingPointTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for FloatingPointTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for FloatingPointTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_floatingPointType(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_floatingPointType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for FloatingPointTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_floatingPointType(self);
	}
}

impl<'input> CustomRuleContext<'input> for FloatingPointTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_floatingPointType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_floatingPointType }
}
antlr_rust::tid!{FloatingPointTypeContextExt<'a>}

impl<'input> FloatingPointTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FloatingPointTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FloatingPointTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FloatingPointTypeContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<FloatingPointTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FLOAT
/// Returns `None` if there is no child corresponding to token FLOAT
fn FLOAT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(FLOAT, 0)
}
/// Retrieves first TerminalNode corresponding to token DOUBLE
/// Returns `None` if there is no child corresponding to token DOUBLE
fn DOUBLE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOUBLE, 0)
}

}

impl<'input> FloatingPointTypeContextAttrs<'input> for FloatingPointTypeContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn floatingPointType(&mut self,)
	-> Result<Rc<FloatingPointTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FloatingPointTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 14, RULE_floatingPointType);
        let mut _localctx: Rc<FloatingPointTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(515);
			_la = recog.base.input.la(1);
			if { !(_la==DOUBLE || _la==FLOAT) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- referenceType ----------------
pub type ReferenceTypeContextAll<'input> = ReferenceTypeContext<'input>;


pub type ReferenceTypeContext<'input> = BaseParserRuleContext<'input,ReferenceTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ReferenceTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ReferenceTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ReferenceTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_referenceType(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_referenceType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ReferenceTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_referenceType(self);
	}
}

impl<'input> CustomRuleContext<'input> for ReferenceTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_referenceType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_referenceType }
}
antlr_rust::tid!{ReferenceTypeContextExt<'a>}

impl<'input> ReferenceTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ReferenceTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ReferenceTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ReferenceTypeContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ReferenceTypeContextExt<'input>>{

fn classOrInterfaceType(&self) -> Option<Rc<ClassOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeVariable(&self) -> Option<Rc<TypeVariableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn arrayType(&self) -> Option<Rc<ArrayTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ReferenceTypeContextAttrs<'input> for ReferenceTypeContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn referenceType(&mut self,)
	-> Result<Rc<ReferenceTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ReferenceTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 16, RULE_referenceType);
        let mut _localctx: Rc<ReferenceTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(520);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(3,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule classOrInterfaceType*/
					recog.base.set_state(517);
					recog.classOrInterfaceType()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule typeVariable*/
					recog.base.set_state(518);
					recog.typeVariable()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule arrayType*/
					recog.base.set_state(519);
					recog.arrayType()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- coit ----------------
pub type CoitContextAll<'input> = CoitContext<'input>;


pub type CoitContext<'input> = BaseParserRuleContext<'input,CoitContextExt<'input>>;

#[derive(Clone)]
pub struct CoitContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for CoitContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for CoitContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_coit(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_coit(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for CoitContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_coit(self);
	}
}

impl<'input> CustomRuleContext<'input> for CoitContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_coit }
	//fn type_rule_index() -> usize where Self: Sized { RULE_coit }
}
antlr_rust::tid!{CoitContextExt<'a>}

impl<'input> CoitContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CoitContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CoitContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CoitContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<CoitContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn typeIdentifier(&self) -> Option<Rc<TypeIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn coit(&self) -> Option<Rc<CoitContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CoitContextAttrs<'input> for CoitContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn coit(&mut self,)
	-> Result<Rc<CoitContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CoitContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 18, RULE_coit);
        let mut _localctx: Rc<CoitContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(522);
			recog.base.match_token(DOT,&mut recog.err_handler)?;

			recog.base.set_state(526);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(523);
				recog.annotation()?;

				}
				}
				recog.base.set_state(528);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule typeIdentifier*/
			recog.base.set_state(529);
			recog.typeIdentifier()?;

			recog.base.set_state(531);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(5,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule typeArguments*/
					recog.base.set_state(530);
					recog.typeArguments()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(534);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(6,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule coit*/
					recog.base.set_state(533);
					recog.coit()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classOrInterfaceType ----------------
pub type ClassOrInterfaceTypeContextAll<'input> = ClassOrInterfaceTypeContext<'input>;


pub type ClassOrInterfaceTypeContext<'input> = BaseParserRuleContext<'input,ClassOrInterfaceTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ClassOrInterfaceTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ClassOrInterfaceTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ClassOrInterfaceTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classOrInterfaceType(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_classOrInterfaceType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ClassOrInterfaceTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_classOrInterfaceType(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassOrInterfaceTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classOrInterfaceType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classOrInterfaceType }
}
antlr_rust::tid!{ClassOrInterfaceTypeContextExt<'a>}

impl<'input> ClassOrInterfaceTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassOrInterfaceTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassOrInterfaceTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassOrInterfaceTypeContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ClassOrInterfaceTypeContextExt<'input>>{

fn typeIdentifier(&self) -> Option<Rc<TypeIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn packageName(&self) -> Option<Rc<PackageNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn coit(&self) -> Option<Rc<CoitContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ClassOrInterfaceTypeContextAttrs<'input> for ClassOrInterfaceTypeContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classOrInterfaceType(&mut self,)
	-> Result<Rc<ClassOrInterfaceTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassOrInterfaceTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 20, RULE_classOrInterfaceType);
        let mut _localctx: Rc<ClassOrInterfaceTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(539);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(7,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule packageName*/
					recog.base.set_state(536);
					recog.packageName()?;

					recog.base.set_state(537);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(544);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(541);
				recog.annotation()?;

				}
				}
				recog.base.set_state(546);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule typeIdentifier*/
			recog.base.set_state(547);
			recog.typeIdentifier()?;

			recog.base.set_state(549);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(9,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule typeArguments*/
					recog.base.set_state(548);
					recog.typeArguments()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(552);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(10,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule coit*/
					recog.base.set_state(551);
					recog.coit()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classType ----------------
pub type ClassTypeContextAll<'input> = ClassTypeContext<'input>;


pub type ClassTypeContext<'input> = BaseParserRuleContext<'input,ClassTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ClassTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ClassTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ClassTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classType(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_classType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ClassTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_classType(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classType }
}
antlr_rust::tid!{ClassTypeContextExt<'a>}

impl<'input> ClassTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassTypeContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ClassTypeContextExt<'input>>{

fn typeIdentifier(&self) -> Option<Rc<TypeIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn packageName(&self) -> Option<Rc<PackageNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn classOrInterfaceType(&self) -> Option<Rc<ClassOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ClassTypeContextAttrs<'input> for ClassTypeContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classType(&mut self,)
	-> Result<Rc<ClassTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 22, RULE_classType);
        let mut _localctx: Rc<ClassTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(588);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(17,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(557);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==AT {
						{
						{
						/*InvokeRule annotation*/
						recog.base.set_state(554);
						recog.annotation()?;

						}
						}
						recog.base.set_state(559);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeIdentifier*/
					recog.base.set_state(560);
					recog.typeIdentifier()?;

					recog.base.set_state(562);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(561);
						recog.typeArguments()?;

						}
					}

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule packageName*/
					recog.base.set_state(564);
					recog.packageName()?;

					recog.base.set_state(565);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(569);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==AT {
						{
						{
						/*InvokeRule annotation*/
						recog.base.set_state(566);
						recog.annotation()?;

						}
						}
						recog.base.set_state(571);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeIdentifier*/
					recog.base.set_state(572);
					recog.typeIdentifier()?;

					recog.base.set_state(574);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(573);
						recog.typeArguments()?;

						}
					}

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule classOrInterfaceType*/
					recog.base.set_state(576);
					recog.classOrInterfaceType()?;

					recog.base.set_state(577);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(581);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==AT {
						{
						{
						/*InvokeRule annotation*/
						recog.base.set_state(578);
						recog.annotation()?;

						}
						}
						recog.base.set_state(583);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeIdentifier*/
					recog.base.set_state(584);
					recog.typeIdentifier()?;

					recog.base.set_state(586);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(585);
						recog.typeArguments()?;

						}
					}

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfaceType ----------------
pub type InterfaceTypeContextAll<'input> = InterfaceTypeContext<'input>;


pub type InterfaceTypeContext<'input> = BaseParserRuleContext<'input,InterfaceTypeContextExt<'input>>;

#[derive(Clone)]
pub struct InterfaceTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for InterfaceTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for InterfaceTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_interfaceType(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_interfaceType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for InterfaceTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_interfaceType(self);
	}
}

impl<'input> CustomRuleContext<'input> for InterfaceTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfaceType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfaceType }
}
antlr_rust::tid!{InterfaceTypeContextExt<'a>}

impl<'input> InterfaceTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfaceTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfaceTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfaceTypeContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<InterfaceTypeContextExt<'input>>{

fn classType(&self) -> Option<Rc<ClassTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InterfaceTypeContextAttrs<'input> for InterfaceTypeContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfaceType(&mut self,)
	-> Result<Rc<InterfaceTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfaceTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 24, RULE_interfaceType);
        let mut _localctx: Rc<InterfaceTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule classType*/
			recog.base.set_state(590);
			recog.classType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeVariable ----------------
pub type TypeVariableContextAll<'input> = TypeVariableContext<'input>;


pub type TypeVariableContext<'input> = BaseParserRuleContext<'input,TypeVariableContextExt<'input>>;

#[derive(Clone)]
pub struct TypeVariableContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for TypeVariableContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for TypeVariableContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeVariable(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_typeVariable(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for TypeVariableContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_typeVariable(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeVariableContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeVariable }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeVariable }
}
antlr_rust::tid!{TypeVariableContextExt<'a>}

impl<'input> TypeVariableContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeVariableContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeVariableContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeVariableContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<TypeVariableContextExt<'input>>{

fn typeIdentifier(&self) -> Option<Rc<TypeIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> TypeVariableContextAttrs<'input> for TypeVariableContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeVariable(&mut self,)
	-> Result<Rc<TypeVariableContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeVariableContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 26, RULE_typeVariable);
        let mut _localctx: Rc<TypeVariableContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(595);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(592);
				recog.annotation()?;

				}
				}
				recog.base.set_state(597);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule typeIdentifier*/
			recog.base.set_state(598);
			recog.typeIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- arrayType ----------------
pub type ArrayTypeContextAll<'input> = ArrayTypeContext<'input>;


pub type ArrayTypeContext<'input> = BaseParserRuleContext<'input,ArrayTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ArrayTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ArrayTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ArrayTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_arrayType(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_arrayType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ArrayTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_arrayType(self);
	}
}

impl<'input> CustomRuleContext<'input> for ArrayTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_arrayType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_arrayType }
}
antlr_rust::tid!{ArrayTypeContextExt<'a>}

impl<'input> ArrayTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ArrayTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ArrayTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ArrayTypeContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ArrayTypeContextExt<'input>>{

fn primitiveType(&self) -> Option<Rc<PrimitiveTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dims(&self) -> Option<Rc<DimsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classType(&self) -> Option<Rc<ClassTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeVariable(&self) -> Option<Rc<TypeVariableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ArrayTypeContextAttrs<'input> for ArrayTypeContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn arrayType(&mut self,)
	-> Result<Rc<ArrayTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ArrayTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 28, RULE_arrayType);
        let mut _localctx: Rc<ArrayTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(609);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(19,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule primitiveType*/
					recog.base.set_state(600);
					recog.primitiveType()?;

					/*InvokeRule dims*/
					recog.base.set_state(601);
					recog.dims()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule classType*/
					recog.base.set_state(603);
					recog.classType()?;

					/*InvokeRule dims*/
					recog.base.set_state(604);
					recog.dims()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule typeVariable*/
					recog.base.set_state(606);
					recog.typeVariable()?;

					/*InvokeRule dims*/
					recog.base.set_state(607);
					recog.dims()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- dims ----------------
pub type DimsContextAll<'input> = DimsContext<'input>;


pub type DimsContext<'input> = BaseParserRuleContext<'input,DimsContextExt<'input>>;

#[derive(Clone)]
pub struct DimsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for DimsContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for DimsContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_dims(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_dims(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for DimsContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_dims(self);
	}
}

impl<'input> CustomRuleContext<'input> for DimsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_dims }
	//fn type_rule_index() -> usize where Self: Sized { RULE_dims }
}
antlr_rust::tid!{DimsContextExt<'a>}

impl<'input> DimsContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DimsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DimsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DimsContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<DimsContextExt<'input>>{

/// Retrieves all `TerminalNode`s corresponding to token LBRACK in current rule
fn LBRACK_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token LBRACK, starting from 0.
/// Returns `None` if number of children corresponding to token LBRACK is less or equal than `i`.
fn LBRACK(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LBRACK, i)
}
/// Retrieves all `TerminalNode`s corresponding to token RBRACK in current rule
fn RBRACK_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token RBRACK, starting from 0.
/// Returns `None` if number of children corresponding to token RBRACK is less or equal than `i`.
fn RBRACK(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RBRACK, i)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> DimsContextAttrs<'input> for DimsContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn dims(&mut self,)
	-> Result<Rc<DimsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DimsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 30, RULE_dims);
        let mut _localctx: Rc<DimsContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(614);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(611);
				recog.annotation()?;

				}
				}
				recog.base.set_state(616);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(617);
			recog.base.match_token(LBRACK,&mut recog.err_handler)?;

			recog.base.set_state(618);
			recog.base.match_token(RBRACK,&mut recog.err_handler)?;

			recog.base.set_state(629);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(22,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(622);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==AT {
						{
						{
						/*InvokeRule annotation*/
						recog.base.set_state(619);
						recog.annotation()?;

						}
						}
						recog.base.set_state(624);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(625);
					recog.base.match_token(LBRACK,&mut recog.err_handler)?;

					recog.base.set_state(626);
					recog.base.match_token(RBRACK,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(631);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(22,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeParameter ----------------
pub type TypeParameterContextAll<'input> = TypeParameterContext<'input>;


pub type TypeParameterContext<'input> = BaseParserRuleContext<'input,TypeParameterContextExt<'input>>;

#[derive(Clone)]
pub struct TypeParameterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for TypeParameterContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for TypeParameterContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeParameter(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_typeParameter(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for TypeParameterContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_typeParameter(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeParameterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeParameter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeParameter }
}
antlr_rust::tid!{TypeParameterContextExt<'a>}

impl<'input> TypeParameterContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeParameterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeParameterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeParameterContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<TypeParameterContextExt<'input>>{

fn typeIdentifier(&self) -> Option<Rc<TypeIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeParameterModifier_all(&self) ->  Vec<Rc<TypeParameterModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeParameterModifier(&self, i: usize) -> Option<Rc<TypeParameterModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn typeBound(&self) -> Option<Rc<TypeBoundContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypeParameterContextAttrs<'input> for TypeParameterContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeParameter(&mut self,)
	-> Result<Rc<TypeParameterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 32, RULE_typeParameter);
        let mut _localctx: Rc<TypeParameterContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(635);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule typeParameterModifier*/
				recog.base.set_state(632);
				recog.typeParameterModifier()?;

				}
				}
				recog.base.set_state(637);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule typeIdentifier*/
			recog.base.set_state(638);
			recog.typeIdentifier()?;

			recog.base.set_state(640);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==EXTENDS {
				{
				/*InvokeRule typeBound*/
				recog.base.set_state(639);
				recog.typeBound()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeParameterModifier ----------------
pub type TypeParameterModifierContextAll<'input> = TypeParameterModifierContext<'input>;


pub type TypeParameterModifierContext<'input> = BaseParserRuleContext<'input,TypeParameterModifierContextExt<'input>>;

#[derive(Clone)]
pub struct TypeParameterModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for TypeParameterModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for TypeParameterModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeParameterModifier(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_typeParameterModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for TypeParameterModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_typeParameterModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeParameterModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeParameterModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeParameterModifier }
}
antlr_rust::tid!{TypeParameterModifierContextExt<'a>}

impl<'input> TypeParameterModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeParameterModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeParameterModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeParameterModifierContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<TypeParameterModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypeParameterModifierContextAttrs<'input> for TypeParameterModifierContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeParameterModifier(&mut self,)
	-> Result<Rc<TypeParameterModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeParameterModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 34, RULE_typeParameterModifier);
        let mut _localctx: Rc<TypeParameterModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule annotation*/
			recog.base.set_state(642);
			recog.annotation()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeBound ----------------
pub type TypeBoundContextAll<'input> = TypeBoundContext<'input>;


pub type TypeBoundContext<'input> = BaseParserRuleContext<'input,TypeBoundContextExt<'input>>;

#[derive(Clone)]
pub struct TypeBoundContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for TypeBoundContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for TypeBoundContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeBound(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_typeBound(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for TypeBoundContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_typeBound(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeBoundContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeBound }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeBound }
}
antlr_rust::tid!{TypeBoundContextExt<'a>}

impl<'input> TypeBoundContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeBoundContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeBoundContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeBoundContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<TypeBoundContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token EXTENDS
/// Returns `None` if there is no child corresponding to token EXTENDS
fn EXTENDS(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(EXTENDS, 0)
}
fn typeVariable(&self) -> Option<Rc<TypeVariableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classOrInterfaceType(&self) -> Option<Rc<ClassOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn additionalBound_all(&self) ->  Vec<Rc<AdditionalBoundContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn additionalBound(&self, i: usize) -> Option<Rc<AdditionalBoundContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> TypeBoundContextAttrs<'input> for TypeBoundContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeBound(&mut self,)
	-> Result<Rc<TypeBoundContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeBoundContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 36, RULE_typeBound);
        let mut _localctx: Rc<TypeBoundContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(644);
			recog.base.match_token(EXTENDS,&mut recog.err_handler)?;

			recog.base.set_state(653);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(26,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule typeVariable*/
					recog.base.set_state(645);
					recog.typeVariable()?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule classOrInterfaceType*/
					recog.base.set_state(646);
					recog.classOrInterfaceType()?;

					recog.base.set_state(650);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==BITAND {
						{
						{
						/*InvokeRule additionalBound*/
						recog.base.set_state(647);
						recog.additionalBound()?;

						}
						}
						recog.base.set_state(652);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- additionalBound ----------------
pub type AdditionalBoundContextAll<'input> = AdditionalBoundContext<'input>;


pub type AdditionalBoundContext<'input> = BaseParserRuleContext<'input,AdditionalBoundContextExt<'input>>;

#[derive(Clone)]
pub struct AdditionalBoundContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for AdditionalBoundContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for AdditionalBoundContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_additionalBound(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_additionalBound(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for AdditionalBoundContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_additionalBound(self);
	}
}

impl<'input> CustomRuleContext<'input> for AdditionalBoundContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_additionalBound }
	//fn type_rule_index() -> usize where Self: Sized { RULE_additionalBound }
}
antlr_rust::tid!{AdditionalBoundContextExt<'a>}

impl<'input> AdditionalBoundContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AdditionalBoundContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AdditionalBoundContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AdditionalBoundContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<AdditionalBoundContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token BITAND
/// Returns `None` if there is no child corresponding to token BITAND
fn BITAND(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(BITAND, 0)
}
fn interfaceType(&self) -> Option<Rc<InterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AdditionalBoundContextAttrs<'input> for AdditionalBoundContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn additionalBound(&mut self,)
	-> Result<Rc<AdditionalBoundContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AdditionalBoundContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 38, RULE_additionalBound);
        let mut _localctx: Rc<AdditionalBoundContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(655);
			recog.base.match_token(BITAND,&mut recog.err_handler)?;

			/*InvokeRule interfaceType*/
			recog.base.set_state(656);
			recog.interfaceType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeArguments ----------------
pub type TypeArgumentsContextAll<'input> = TypeArgumentsContext<'input>;


pub type TypeArgumentsContext<'input> = BaseParserRuleContext<'input,TypeArgumentsContextExt<'input>>;

#[derive(Clone)]
pub struct TypeArgumentsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for TypeArgumentsContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for TypeArgumentsContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeArguments(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_typeArguments(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for TypeArgumentsContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_typeArguments(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeArgumentsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeArguments }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeArguments }
}
antlr_rust::tid!{TypeArgumentsContextExt<'a>}

impl<'input> TypeArgumentsContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeArgumentsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeArgumentsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeArgumentsContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<TypeArgumentsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LT
/// Returns `None` if there is no child corresponding to token LT
fn LT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LT, 0)
}
fn typeArgumentList(&self) -> Option<Rc<TypeArgumentListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token GT
/// Returns `None` if there is no child corresponding to token GT
fn GT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(GT, 0)
}

}

impl<'input> TypeArgumentsContextAttrs<'input> for TypeArgumentsContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeArguments(&mut self,)
	-> Result<Rc<TypeArgumentsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeArgumentsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 40, RULE_typeArguments);
        let mut _localctx: Rc<TypeArgumentsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(658);
			recog.base.match_token(LT,&mut recog.err_handler)?;

			/*InvokeRule typeArgumentList*/
			recog.base.set_state(659);
			recog.typeArgumentList()?;

			recog.base.set_state(660);
			recog.base.match_token(GT,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeArgumentList ----------------
pub type TypeArgumentListContextAll<'input> = TypeArgumentListContext<'input>;


pub type TypeArgumentListContext<'input> = BaseParserRuleContext<'input,TypeArgumentListContextExt<'input>>;

#[derive(Clone)]
pub struct TypeArgumentListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for TypeArgumentListContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for TypeArgumentListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeArgumentList(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_typeArgumentList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for TypeArgumentListContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_typeArgumentList(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeArgumentListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeArgumentList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeArgumentList }
}
antlr_rust::tid!{TypeArgumentListContextExt<'a>}

impl<'input> TypeArgumentListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeArgumentListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeArgumentListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeArgumentListContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<TypeArgumentListContextExt<'input>>{

fn typeArgument_all(&self) ->  Vec<Rc<TypeArgumentContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeArgument(&self, i: usize) -> Option<Rc<TypeArgumentContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> TypeArgumentListContextAttrs<'input> for TypeArgumentListContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeArgumentList(&mut self,)
	-> Result<Rc<TypeArgumentListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeArgumentListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 42, RULE_typeArgumentList);
        let mut _localctx: Rc<TypeArgumentListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule typeArgument*/
			recog.base.set_state(662);
			recog.typeArgument()?;

			recog.base.set_state(667);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				recog.base.set_state(663);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				/*InvokeRule typeArgument*/
				recog.base.set_state(664);
				recog.typeArgument()?;

				}
				}
				recog.base.set_state(669);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeArgument ----------------
pub type TypeArgumentContextAll<'input> = TypeArgumentContext<'input>;


pub type TypeArgumentContext<'input> = BaseParserRuleContext<'input,TypeArgumentContextExt<'input>>;

#[derive(Clone)]
pub struct TypeArgumentContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for TypeArgumentContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for TypeArgumentContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeArgument(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_typeArgument(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for TypeArgumentContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_typeArgument(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeArgumentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeArgument }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeArgument }
}
antlr_rust::tid!{TypeArgumentContextExt<'a>}

impl<'input> TypeArgumentContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeArgumentContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeArgumentContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeArgumentContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<TypeArgumentContextExt<'input>>{

fn referenceType(&self) -> Option<Rc<ReferenceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn wildcard(&self) -> Option<Rc<WildcardContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypeArgumentContextAttrs<'input> for TypeArgumentContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeArgument(&mut self,)
	-> Result<Rc<TypeArgumentContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeArgumentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 44, RULE_typeArgument);
        let mut _localctx: Rc<TypeArgumentContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(672);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(28,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule referenceType*/
					recog.base.set_state(670);
					recog.referenceType()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule wildcard*/
					recog.base.set_state(671);
					recog.wildcard()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- wildcard ----------------
pub type WildcardContextAll<'input> = WildcardContext<'input>;


pub type WildcardContext<'input> = BaseParserRuleContext<'input,WildcardContextExt<'input>>;

#[derive(Clone)]
pub struct WildcardContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for WildcardContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for WildcardContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_wildcard(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_wildcard(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for WildcardContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_wildcard(self);
	}
}

impl<'input> CustomRuleContext<'input> for WildcardContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_wildcard }
	//fn type_rule_index() -> usize where Self: Sized { RULE_wildcard }
}
antlr_rust::tid!{WildcardContextExt<'a>}

impl<'input> WildcardContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WildcardContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WildcardContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait WildcardContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<WildcardContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token QUESTION
/// Returns `None` if there is no child corresponding to token QUESTION
fn QUESTION(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(QUESTION, 0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn wildcardBounds(&self) -> Option<Rc<WildcardBoundsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> WildcardContextAttrs<'input> for WildcardContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn wildcard(&mut self,)
	-> Result<Rc<WildcardContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WildcardContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 46, RULE_wildcard);
        let mut _localctx: Rc<WildcardContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(677);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(674);
				recog.annotation()?;

				}
				}
				recog.base.set_state(679);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(680);
			recog.base.match_token(QUESTION,&mut recog.err_handler)?;

			recog.base.set_state(682);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==EXTENDS || _la==SUPER {
				{
				/*InvokeRule wildcardBounds*/
				recog.base.set_state(681);
				recog.wildcardBounds()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- wildcardBounds ----------------
pub type WildcardBoundsContextAll<'input> = WildcardBoundsContext<'input>;


pub type WildcardBoundsContext<'input> = BaseParserRuleContext<'input,WildcardBoundsContextExt<'input>>;

#[derive(Clone)]
pub struct WildcardBoundsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for WildcardBoundsContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for WildcardBoundsContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_wildcardBounds(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_wildcardBounds(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for WildcardBoundsContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_wildcardBounds(self);
	}
}

impl<'input> CustomRuleContext<'input> for WildcardBoundsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_wildcardBounds }
	//fn type_rule_index() -> usize where Self: Sized { RULE_wildcardBounds }
}
antlr_rust::tid!{WildcardBoundsContextExt<'a>}

impl<'input> WildcardBoundsContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WildcardBoundsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WildcardBoundsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait WildcardBoundsContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<WildcardBoundsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token EXTENDS
/// Returns `None` if there is no child corresponding to token EXTENDS
fn EXTENDS(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(EXTENDS, 0)
}
fn referenceType(&self) -> Option<Rc<ReferenceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SUPER
/// Returns `None` if there is no child corresponding to token SUPER
fn SUPER(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SUPER, 0)
}

}

impl<'input> WildcardBoundsContextAttrs<'input> for WildcardBoundsContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn wildcardBounds(&mut self,)
	-> Result<Rc<WildcardBoundsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WildcardBoundsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 48, RULE_wildcardBounds);
        let mut _localctx: Rc<WildcardBoundsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(688);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 EXTENDS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(684);
					recog.base.match_token(EXTENDS,&mut recog.err_handler)?;

					/*InvokeRule referenceType*/
					recog.base.set_state(685);
					recog.referenceType()?;

					}
				}

			 SUPER 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(686);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					/*InvokeRule referenceType*/
					recog.base.set_state(687);
					recog.referenceType()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- moduleName ----------------
pub type ModuleNameContextAll<'input> = ModuleNameContext<'input>;


pub type ModuleNameContext<'input> = BaseParserRuleContext<'input,ModuleNameContextExt<'input>>;

#[derive(Clone)]
pub struct ModuleNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ModuleNameContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ModuleNameContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_moduleName(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_moduleName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ModuleNameContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_moduleName(self);
	}
}

impl<'input> CustomRuleContext<'input> for ModuleNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_moduleName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_moduleName }
}
antlr_rust::tid!{ModuleNameContextExt<'a>}

impl<'input> ModuleNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ModuleNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ModuleNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ModuleNameContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ModuleNameContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn moduleName(&self) -> Option<Rc<ModuleNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ModuleNameContextAttrs<'input> for ModuleNameContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn moduleName(&mut self,)
	-> Result<Rc<ModuleNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ModuleNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 50, RULE_moduleName);
        let mut _localctx: Rc<ModuleNameContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(690);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			recog.base.set_state(693);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==DOT {
				{
				recog.base.set_state(691);
				recog.base.match_token(DOT,&mut recog.err_handler)?;

				/*InvokeRule moduleName*/
				recog.base.set_state(692);
				recog.moduleName()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- packageName ----------------
pub type PackageNameContextAll<'input> = PackageNameContext<'input>;


pub type PackageNameContext<'input> = BaseParserRuleContext<'input,PackageNameContextExt<'input>>;

#[derive(Clone)]
pub struct PackageNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for PackageNameContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for PackageNameContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_packageName(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_packageName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for PackageNameContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_packageName(self);
	}
}

impl<'input> CustomRuleContext<'input> for PackageNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_packageName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_packageName }
}
antlr_rust::tid!{PackageNameContextExt<'a>}

impl<'input> PackageNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PackageNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PackageNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PackageNameContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<PackageNameContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn packageName(&self) -> Option<Rc<PackageNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PackageNameContextAttrs<'input> for PackageNameContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn packageName(&mut self,)
	-> Result<Rc<PackageNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PackageNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 52, RULE_packageName);
        let mut _localctx: Rc<PackageNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(695);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			recog.base.set_state(698);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(33,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(696);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					/*InvokeRule packageName*/
					recog.base.set_state(697);
					recog.packageName()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeName ----------------
pub type TypeNameContextAll<'input> = TypeNameContext<'input>;


pub type TypeNameContext<'input> = BaseParserRuleContext<'input,TypeNameContextExt<'input>>;

#[derive(Clone)]
pub struct TypeNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for TypeNameContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for TypeNameContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeName(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_typeName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for TypeNameContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_typeName(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeName }
}
antlr_rust::tid!{TypeNameContextExt<'a>}

impl<'input> TypeNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeNameContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<TypeNameContextExt<'input>>{

fn packageName(&self) -> Option<Rc<PackageNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn typeIdentifier(&self) -> Option<Rc<TypeIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypeNameContextAttrs<'input> for TypeNameContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeName(&mut self,)
	-> Result<Rc<TypeNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 54, RULE_typeName);
        let mut _localctx: Rc<TypeNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule packageName*/
			recog.base.set_state(700);
			recog.packageName()?;

			recog.base.set_state(703);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(34,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(701);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					/*InvokeRule typeIdentifier*/
					recog.base.set_state(702);
					recog.typeIdentifier()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- packageOrTypeName ----------------
pub type PackageOrTypeNameContextAll<'input> = PackageOrTypeNameContext<'input>;


pub type PackageOrTypeNameContext<'input> = BaseParserRuleContext<'input,PackageOrTypeNameContextExt<'input>>;

#[derive(Clone)]
pub struct PackageOrTypeNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for PackageOrTypeNameContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for PackageOrTypeNameContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_packageOrTypeName(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_packageOrTypeName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for PackageOrTypeNameContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_packageOrTypeName(self);
	}
}

impl<'input> CustomRuleContext<'input> for PackageOrTypeNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_packageOrTypeName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_packageOrTypeName }
}
antlr_rust::tid!{PackageOrTypeNameContextExt<'a>}

impl<'input> PackageOrTypeNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PackageOrTypeNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PackageOrTypeNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PackageOrTypeNameContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<PackageOrTypeNameContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn packageOrTypeName(&self) -> Option<Rc<PackageOrTypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PackageOrTypeNameContextAttrs<'input> for PackageOrTypeNameContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn packageOrTypeName(&mut self,)
	-> Result<Rc<PackageOrTypeNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PackageOrTypeNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 56, RULE_packageOrTypeName);
        let mut _localctx: Rc<PackageOrTypeNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(705);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			recog.base.set_state(708);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(35,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(706);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					/*InvokeRule packageOrTypeName*/
					recog.base.set_state(707);
					recog.packageOrTypeName()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- expressionName ----------------
pub type ExpressionNameContextAll<'input> = ExpressionNameContext<'input>;


pub type ExpressionNameContext<'input> = BaseParserRuleContext<'input,ExpressionNameContextExt<'input>>;

#[derive(Clone)]
pub struct ExpressionNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ExpressionNameContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ExpressionNameContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_expressionName(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_expressionName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ExpressionNameContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_expressionName(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExpressionNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_expressionName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_expressionName }
}
antlr_rust::tid!{ExpressionNameContextExt<'a>}

impl<'input> ExpressionNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExpressionNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExpressionNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExpressionNameContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ExpressionNameContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
fn ambiguousName(&self) -> Option<Rc<AmbiguousNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> ExpressionNameContextAttrs<'input> for ExpressionNameContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn expressionName(&mut self,)
	-> Result<Rc<ExpressionNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExpressionNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 58, RULE_expressionName);
        let mut _localctx: Rc<ExpressionNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(713);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(36,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule ambiguousName*/
					recog.base.set_state(710);
					recog.ambiguousName()?;

					recog.base.set_state(711);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(715);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodName ----------------
pub type MethodNameContextAll<'input> = MethodNameContext<'input>;


pub type MethodNameContext<'input> = BaseParserRuleContext<'input,MethodNameContextExt<'input>>;

#[derive(Clone)]
pub struct MethodNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for MethodNameContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for MethodNameContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodName(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_methodName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for MethodNameContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_methodName(self);
	}
}

impl<'input> CustomRuleContext<'input> for MethodNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodName }
}
antlr_rust::tid!{MethodNameContextExt<'a>}

impl<'input> MethodNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodNameContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<MethodNameContextExt<'input>>{

fn unqualifiedMethodIdentifier(&self) -> Option<Rc<UnqualifiedMethodIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MethodNameContextAttrs<'input> for MethodNameContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodName(&mut self,)
	-> Result<Rc<MethodNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 60, RULE_methodName);
        let mut _localctx: Rc<MethodNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule unqualifiedMethodIdentifier*/
			recog.base.set_state(717);
			recog.unqualifiedMethodIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ambiguousName ----------------
pub type AmbiguousNameContextAll<'input> = AmbiguousNameContext<'input>;


pub type AmbiguousNameContext<'input> = BaseParserRuleContext<'input,AmbiguousNameContextExt<'input>>;

#[derive(Clone)]
pub struct AmbiguousNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for AmbiguousNameContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for AmbiguousNameContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ambiguousName(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_ambiguousName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for AmbiguousNameContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_ambiguousName(self);
	}
}

impl<'input> CustomRuleContext<'input> for AmbiguousNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ambiguousName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ambiguousName }
}
antlr_rust::tid!{AmbiguousNameContextExt<'a>}

impl<'input> AmbiguousNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AmbiguousNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AmbiguousNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AmbiguousNameContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<AmbiguousNameContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn ambiguousName(&self) -> Option<Rc<AmbiguousNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AmbiguousNameContextAttrs<'input> for AmbiguousNameContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ambiguousName(&mut self,)
	-> Result<Rc<AmbiguousNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AmbiguousNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 62, RULE_ambiguousName);
        let mut _localctx: Rc<AmbiguousNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(719);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			recog.base.set_state(722);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(37,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(720);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					/*InvokeRule ambiguousName*/
					recog.base.set_state(721);
					recog.ambiguousName()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- compilationUnit ----------------
pub type CompilationUnitContextAll<'input> = CompilationUnitContext<'input>;


pub type CompilationUnitContext<'input> = BaseParserRuleContext<'input,CompilationUnitContextExt<'input>>;

#[derive(Clone)]
pub struct CompilationUnitContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for CompilationUnitContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for CompilationUnitContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_compilationUnit(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_compilationUnit(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for CompilationUnitContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_compilationUnit(self);
	}
}

impl<'input> CustomRuleContext<'input> for CompilationUnitContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_compilationUnit }
	//fn type_rule_index() -> usize where Self: Sized { RULE_compilationUnit }
}
antlr_rust::tid!{CompilationUnitContextExt<'a>}

impl<'input> CompilationUnitContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CompilationUnitContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CompilationUnitContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CompilationUnitContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<CompilationUnitContextExt<'input>>{

fn ordinaryCompilationUnit(&self) -> Option<Rc<OrdinaryCompilationUnitContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn modularCompilationUnit(&self) -> Option<Rc<ModularCompilationUnitContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CompilationUnitContextAttrs<'input> for CompilationUnitContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn compilationUnit(&mut self,)
	-> Result<Rc<CompilationUnitContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CompilationUnitContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 64, RULE_compilationUnit);
        let mut _localctx: Rc<CompilationUnitContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(726);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(38,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule ordinaryCompilationUnit*/
					recog.base.set_state(724);
					recog.ordinaryCompilationUnit()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule modularCompilationUnit*/
					recog.base.set_state(725);
					recog.modularCompilationUnit()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ordinaryCompilationUnit ----------------
pub type OrdinaryCompilationUnitContextAll<'input> = OrdinaryCompilationUnitContext<'input>;


pub type OrdinaryCompilationUnitContext<'input> = BaseParserRuleContext<'input,OrdinaryCompilationUnitContextExt<'input>>;

#[derive(Clone)]
pub struct OrdinaryCompilationUnitContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for OrdinaryCompilationUnitContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for OrdinaryCompilationUnitContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ordinaryCompilationUnit(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_ordinaryCompilationUnit(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for OrdinaryCompilationUnitContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_ordinaryCompilationUnit(self);
	}
}

impl<'input> CustomRuleContext<'input> for OrdinaryCompilationUnitContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ordinaryCompilationUnit }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ordinaryCompilationUnit }
}
antlr_rust::tid!{OrdinaryCompilationUnitContextExt<'a>}

impl<'input> OrdinaryCompilationUnitContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OrdinaryCompilationUnitContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OrdinaryCompilationUnitContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait OrdinaryCompilationUnitContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<OrdinaryCompilationUnitContextExt<'input>>{

fn packageDeclaration(&self) -> Option<Rc<PackageDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn importDeclaration_all(&self) ->  Vec<Rc<ImportDeclarationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn importDeclaration(&self, i: usize) -> Option<Rc<ImportDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn topLevelClassOrInterfaceDeclaration_all(&self) ->  Vec<Rc<TopLevelClassOrInterfaceDeclarationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn topLevelClassOrInterfaceDeclaration(&self, i: usize) -> Option<Rc<TopLevelClassOrInterfaceDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> OrdinaryCompilationUnitContextAttrs<'input> for OrdinaryCompilationUnitContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ordinaryCompilationUnit(&mut self,)
	-> Result<Rc<OrdinaryCompilationUnitContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OrdinaryCompilationUnitContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 66, RULE_ordinaryCompilationUnit);
        let mut _localctx: Rc<OrdinaryCompilationUnitContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(729);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(39,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule packageDeclaration*/
					recog.base.set_state(728);
					recog.packageDeclaration()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(734);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==IMPORT {
				{
				{
				/*InvokeRule importDeclaration*/
				recog.base.set_state(731);
				recog.importDeclaration()?;

				}
				}
				recog.base.set_state(736);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(740);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << NONSEALED) | (1usize << RECORD) | (1usize << SEALED) | (1usize << ABSTRACT) | (1usize << CLASS))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (ENUM - 33)) | (1usize << (FINAL - 33)) | (1usize << (INTERFACE - 33)) | (1usize << (PRIVATE - 33)) | (1usize << (PROTECTED - 33)) | (1usize << (PUBLIC - 33)) | (1usize << (STATIC - 33)) | (1usize << (STRICTFP - 33)))) != 0) || _la==SEMI || _la==AT {
				{
				{
				/*InvokeRule topLevelClassOrInterfaceDeclaration*/
				recog.base.set_state(737);
				recog.topLevelClassOrInterfaceDeclaration()?;

				}
				}
				recog.base.set_state(742);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- modularCompilationUnit ----------------
pub type ModularCompilationUnitContextAll<'input> = ModularCompilationUnitContext<'input>;


pub type ModularCompilationUnitContext<'input> = BaseParserRuleContext<'input,ModularCompilationUnitContextExt<'input>>;

#[derive(Clone)]
pub struct ModularCompilationUnitContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ModularCompilationUnitContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ModularCompilationUnitContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_modularCompilationUnit(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_modularCompilationUnit(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ModularCompilationUnitContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_modularCompilationUnit(self);
	}
}

impl<'input> CustomRuleContext<'input> for ModularCompilationUnitContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_modularCompilationUnit }
	//fn type_rule_index() -> usize where Self: Sized { RULE_modularCompilationUnit }
}
antlr_rust::tid!{ModularCompilationUnitContextExt<'a>}

impl<'input> ModularCompilationUnitContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ModularCompilationUnitContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ModularCompilationUnitContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ModularCompilationUnitContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ModularCompilationUnitContextExt<'input>>{

fn moduleDeclaration(&self) -> Option<Rc<ModuleDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn importDeclaration_all(&self) ->  Vec<Rc<ImportDeclarationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn importDeclaration(&self, i: usize) -> Option<Rc<ImportDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ModularCompilationUnitContextAttrs<'input> for ModularCompilationUnitContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn modularCompilationUnit(&mut self,)
	-> Result<Rc<ModularCompilationUnitContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ModularCompilationUnitContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 68, RULE_modularCompilationUnit);
        let mut _localctx: Rc<ModularCompilationUnitContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(746);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==IMPORT {
				{
				{
				/*InvokeRule importDeclaration*/
				recog.base.set_state(743);
				recog.importDeclaration()?;

				}
				}
				recog.base.set_state(748);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule moduleDeclaration*/
			recog.base.set_state(749);
			recog.moduleDeclaration()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- packageDeclaration ----------------
pub type PackageDeclarationContextAll<'input> = PackageDeclarationContext<'input>;


pub type PackageDeclarationContext<'input> = BaseParserRuleContext<'input,PackageDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct PackageDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for PackageDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for PackageDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_packageDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_packageDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for PackageDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_packageDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for PackageDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_packageDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_packageDeclaration }
}
antlr_rust::tid!{PackageDeclarationContextExt<'a>}

impl<'input> PackageDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PackageDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PackageDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PackageDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<PackageDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token PACKAGE
/// Returns `None` if there is no child corresponding to token PACKAGE
fn PACKAGE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(PACKAGE, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token Identifier in current rule
fn Identifier_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Identifier, starting from 0.
/// Returns `None` if number of children corresponding to token Identifier is less or equal than `i`.
fn Identifier(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, i)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}
fn packageModifier_all(&self) ->  Vec<Rc<PackageModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn packageModifier(&self, i: usize) -> Option<Rc<PackageModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
/// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, i)
}

}

impl<'input> PackageDeclarationContextAttrs<'input> for PackageDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn packageDeclaration(&mut self,)
	-> Result<Rc<PackageDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PackageDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 70, RULE_packageDeclaration);
        let mut _localctx: Rc<PackageDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(754);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule packageModifier*/
				recog.base.set_state(751);
				recog.packageModifier()?;

				}
				}
				recog.base.set_state(756);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(757);
			recog.base.match_token(PACKAGE,&mut recog.err_handler)?;

			recog.base.set_state(758);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			recog.base.set_state(763);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==DOT {
				{
				{
				recog.base.set_state(759);
				recog.base.match_token(DOT,&mut recog.err_handler)?;

				recog.base.set_state(760);
				recog.base.match_token(Identifier,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(765);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(766);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- packageModifier ----------------
pub type PackageModifierContextAll<'input> = PackageModifierContext<'input>;


pub type PackageModifierContext<'input> = BaseParserRuleContext<'input,PackageModifierContextExt<'input>>;

#[derive(Clone)]
pub struct PackageModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for PackageModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for PackageModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_packageModifier(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_packageModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for PackageModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_packageModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for PackageModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_packageModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_packageModifier }
}
antlr_rust::tid!{PackageModifierContextExt<'a>}

impl<'input> PackageModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PackageModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PackageModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PackageModifierContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<PackageModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PackageModifierContextAttrs<'input> for PackageModifierContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn packageModifier(&mut self,)
	-> Result<Rc<PackageModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PackageModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 72, RULE_packageModifier);
        let mut _localctx: Rc<PackageModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule annotation*/
			recog.base.set_state(768);
			recog.annotation()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- importDeclaration ----------------
pub type ImportDeclarationContextAll<'input> = ImportDeclarationContext<'input>;


pub type ImportDeclarationContext<'input> = BaseParserRuleContext<'input,ImportDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct ImportDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ImportDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ImportDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_importDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_importDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ImportDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_importDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for ImportDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_importDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_importDeclaration }
}
antlr_rust::tid!{ImportDeclarationContextExt<'a>}

impl<'input> ImportDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ImportDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ImportDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ImportDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ImportDeclarationContextExt<'input>>{

fn singleTypeImportDeclaration(&self) -> Option<Rc<SingleTypeImportDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeImportOnDemandDeclaration(&self) -> Option<Rc<TypeImportOnDemandDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn singleStaticImportDeclaration(&self) -> Option<Rc<SingleStaticImportDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn staticImportOnDemandDeclaration(&self) -> Option<Rc<StaticImportOnDemandDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ImportDeclarationContextAttrs<'input> for ImportDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn importDeclaration(&mut self,)
	-> Result<Rc<ImportDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ImportDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 74, RULE_importDeclaration);
        let mut _localctx: Rc<ImportDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(774);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(45,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule singleTypeImportDeclaration*/
					recog.base.set_state(770);
					recog.singleTypeImportDeclaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule typeImportOnDemandDeclaration*/
					recog.base.set_state(771);
					recog.typeImportOnDemandDeclaration()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule singleStaticImportDeclaration*/
					recog.base.set_state(772);
					recog.singleStaticImportDeclaration()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule staticImportOnDemandDeclaration*/
					recog.base.set_state(773);
					recog.staticImportOnDemandDeclaration()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- singleTypeImportDeclaration ----------------
pub type SingleTypeImportDeclarationContextAll<'input> = SingleTypeImportDeclarationContext<'input>;


pub type SingleTypeImportDeclarationContext<'input> = BaseParserRuleContext<'input,SingleTypeImportDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct SingleTypeImportDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for SingleTypeImportDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for SingleTypeImportDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_singleTypeImportDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_singleTypeImportDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for SingleTypeImportDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_singleTypeImportDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for SingleTypeImportDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_singleTypeImportDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_singleTypeImportDeclaration }
}
antlr_rust::tid!{SingleTypeImportDeclarationContextExt<'a>}

impl<'input> SingleTypeImportDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SingleTypeImportDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SingleTypeImportDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SingleTypeImportDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<SingleTypeImportDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IMPORT
/// Returns `None` if there is no child corresponding to token IMPORT
fn IMPORT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(IMPORT, 0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> SingleTypeImportDeclarationContextAttrs<'input> for SingleTypeImportDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn singleTypeImportDeclaration(&mut self,)
	-> Result<Rc<SingleTypeImportDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SingleTypeImportDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 76, RULE_singleTypeImportDeclaration);
        let mut _localctx: Rc<SingleTypeImportDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(776);
			recog.base.match_token(IMPORT,&mut recog.err_handler)?;

			/*InvokeRule typeName*/
			recog.base.set_state(777);
			recog.typeName()?;

			recog.base.set_state(778);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeImportOnDemandDeclaration ----------------
pub type TypeImportOnDemandDeclarationContextAll<'input> = TypeImportOnDemandDeclarationContext<'input>;


pub type TypeImportOnDemandDeclarationContext<'input> = BaseParserRuleContext<'input,TypeImportOnDemandDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct TypeImportOnDemandDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for TypeImportOnDemandDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for TypeImportOnDemandDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeImportOnDemandDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_typeImportOnDemandDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for TypeImportOnDemandDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_typeImportOnDemandDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeImportOnDemandDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeImportOnDemandDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeImportOnDemandDeclaration }
}
antlr_rust::tid!{TypeImportOnDemandDeclarationContextExt<'a>}

impl<'input> TypeImportOnDemandDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeImportOnDemandDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeImportOnDemandDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeImportOnDemandDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<TypeImportOnDemandDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IMPORT
/// Returns `None` if there is no child corresponding to token IMPORT
fn IMPORT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(IMPORT, 0)
}
fn packageOrTypeName(&self) -> Option<Rc<PackageOrTypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
/// Retrieves first TerminalNode corresponding to token MUL
/// Returns `None` if there is no child corresponding to token MUL
fn MUL(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(MUL, 0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> TypeImportOnDemandDeclarationContextAttrs<'input> for TypeImportOnDemandDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeImportOnDemandDeclaration(&mut self,)
	-> Result<Rc<TypeImportOnDemandDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeImportOnDemandDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 78, RULE_typeImportOnDemandDeclaration);
        let mut _localctx: Rc<TypeImportOnDemandDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(780);
			recog.base.match_token(IMPORT,&mut recog.err_handler)?;

			/*InvokeRule packageOrTypeName*/
			recog.base.set_state(781);
			recog.packageOrTypeName()?;

			recog.base.set_state(782);
			recog.base.match_token(DOT,&mut recog.err_handler)?;

			recog.base.set_state(783);
			recog.base.match_token(MUL,&mut recog.err_handler)?;

			recog.base.set_state(784);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- singleStaticImportDeclaration ----------------
pub type SingleStaticImportDeclarationContextAll<'input> = SingleStaticImportDeclarationContext<'input>;


pub type SingleStaticImportDeclarationContext<'input> = BaseParserRuleContext<'input,SingleStaticImportDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct SingleStaticImportDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for SingleStaticImportDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for SingleStaticImportDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_singleStaticImportDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_singleStaticImportDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for SingleStaticImportDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_singleStaticImportDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for SingleStaticImportDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_singleStaticImportDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_singleStaticImportDeclaration }
}
antlr_rust::tid!{SingleStaticImportDeclarationContextExt<'a>}

impl<'input> SingleStaticImportDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SingleStaticImportDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SingleStaticImportDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SingleStaticImportDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<SingleStaticImportDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IMPORT
/// Returns `None` if there is no child corresponding to token IMPORT
fn IMPORT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(IMPORT, 0)
}
/// Retrieves first TerminalNode corresponding to token STATIC
/// Returns `None` if there is no child corresponding to token STATIC
fn STATIC(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(STATIC, 0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> SingleStaticImportDeclarationContextAttrs<'input> for SingleStaticImportDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn singleStaticImportDeclaration(&mut self,)
	-> Result<Rc<SingleStaticImportDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SingleStaticImportDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 80, RULE_singleStaticImportDeclaration);
        let mut _localctx: Rc<SingleStaticImportDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(786);
			recog.base.match_token(IMPORT,&mut recog.err_handler)?;

			recog.base.set_state(787);
			recog.base.match_token(STATIC,&mut recog.err_handler)?;

			/*InvokeRule typeName*/
			recog.base.set_state(788);
			recog.typeName()?;

			recog.base.set_state(789);
			recog.base.match_token(DOT,&mut recog.err_handler)?;

			recog.base.set_state(790);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			recog.base.set_state(791);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- staticImportOnDemandDeclaration ----------------
pub type StaticImportOnDemandDeclarationContextAll<'input> = StaticImportOnDemandDeclarationContext<'input>;


pub type StaticImportOnDemandDeclarationContext<'input> = BaseParserRuleContext<'input,StaticImportOnDemandDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct StaticImportOnDemandDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for StaticImportOnDemandDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for StaticImportOnDemandDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_staticImportOnDemandDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_staticImportOnDemandDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for StaticImportOnDemandDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_staticImportOnDemandDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for StaticImportOnDemandDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_staticImportOnDemandDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_staticImportOnDemandDeclaration }
}
antlr_rust::tid!{StaticImportOnDemandDeclarationContextExt<'a>}

impl<'input> StaticImportOnDemandDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StaticImportOnDemandDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StaticImportOnDemandDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StaticImportOnDemandDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<StaticImportOnDemandDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IMPORT
/// Returns `None` if there is no child corresponding to token IMPORT
fn IMPORT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(IMPORT, 0)
}
/// Retrieves first TerminalNode corresponding to token STATIC
/// Returns `None` if there is no child corresponding to token STATIC
fn STATIC(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(STATIC, 0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
/// Retrieves first TerminalNode corresponding to token MUL
/// Returns `None` if there is no child corresponding to token MUL
fn MUL(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(MUL, 0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> StaticImportOnDemandDeclarationContextAttrs<'input> for StaticImportOnDemandDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn staticImportOnDemandDeclaration(&mut self,)
	-> Result<Rc<StaticImportOnDemandDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StaticImportOnDemandDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 82, RULE_staticImportOnDemandDeclaration);
        let mut _localctx: Rc<StaticImportOnDemandDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(793);
			recog.base.match_token(IMPORT,&mut recog.err_handler)?;

			recog.base.set_state(794);
			recog.base.match_token(STATIC,&mut recog.err_handler)?;

			/*InvokeRule typeName*/
			recog.base.set_state(795);
			recog.typeName()?;

			recog.base.set_state(796);
			recog.base.match_token(DOT,&mut recog.err_handler)?;

			recog.base.set_state(797);
			recog.base.match_token(MUL,&mut recog.err_handler)?;

			recog.base.set_state(798);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- topLevelClassOrInterfaceDeclaration ----------------
pub type TopLevelClassOrInterfaceDeclarationContextAll<'input> = TopLevelClassOrInterfaceDeclarationContext<'input>;


pub type TopLevelClassOrInterfaceDeclarationContext<'input> = BaseParserRuleContext<'input,TopLevelClassOrInterfaceDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct TopLevelClassOrInterfaceDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for TopLevelClassOrInterfaceDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for TopLevelClassOrInterfaceDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_topLevelClassOrInterfaceDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_topLevelClassOrInterfaceDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for TopLevelClassOrInterfaceDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_topLevelClassOrInterfaceDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for TopLevelClassOrInterfaceDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_topLevelClassOrInterfaceDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_topLevelClassOrInterfaceDeclaration }
}
antlr_rust::tid!{TopLevelClassOrInterfaceDeclarationContextExt<'a>}

impl<'input> TopLevelClassOrInterfaceDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TopLevelClassOrInterfaceDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TopLevelClassOrInterfaceDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TopLevelClassOrInterfaceDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<TopLevelClassOrInterfaceDeclarationContextExt<'input>>{

fn classDeclaration(&self) -> Option<Rc<ClassDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfaceDeclaration(&self) -> Option<Rc<InterfaceDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> TopLevelClassOrInterfaceDeclarationContextAttrs<'input> for TopLevelClassOrInterfaceDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn topLevelClassOrInterfaceDeclaration(&mut self,)
	-> Result<Rc<TopLevelClassOrInterfaceDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TopLevelClassOrInterfaceDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 84, RULE_topLevelClassOrInterfaceDeclaration);
        let mut _localctx: Rc<TopLevelClassOrInterfaceDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(803);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(46,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule classDeclaration*/
					recog.base.set_state(800);
					recog.classDeclaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule interfaceDeclaration*/
					recog.base.set_state(801);
					recog.interfaceDeclaration()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(802);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- moduleDeclaration ----------------
pub type ModuleDeclarationContextAll<'input> = ModuleDeclarationContext<'input>;


pub type ModuleDeclarationContext<'input> = BaseParserRuleContext<'input,ModuleDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct ModuleDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ModuleDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ModuleDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_moduleDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_moduleDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ModuleDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_moduleDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for ModuleDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_moduleDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_moduleDeclaration }
}
antlr_rust::tid!{ModuleDeclarationContextExt<'a>}

impl<'input> ModuleDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ModuleDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ModuleDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ModuleDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ModuleDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token MODULE
/// Returns `None` if there is no child corresponding to token MODULE
fn MODULE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(MODULE, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token Identifier in current rule
fn Identifier_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Identifier, starting from 0.
/// Returns `None` if number of children corresponding to token Identifier is less or equal than `i`.
fn Identifier(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, i)
}
/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token OPEN
/// Returns `None` if there is no child corresponding to token OPEN
fn OPEN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(OPEN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
/// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, i)
}
fn moduleDirective_all(&self) ->  Vec<Rc<ModuleDirectiveContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn moduleDirective(&self, i: usize) -> Option<Rc<ModuleDirectiveContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ModuleDeclarationContextAttrs<'input> for ModuleDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn moduleDeclaration(&mut self,)
	-> Result<Rc<ModuleDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ModuleDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 86, RULE_moduleDeclaration);
        let mut _localctx: Rc<ModuleDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(808);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(805);
				recog.annotation()?;

				}
				}
				recog.base.set_state(810);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(812);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==OPEN {
				{
				recog.base.set_state(811);
				recog.base.match_token(OPEN,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(814);
			recog.base.match_token(MODULE,&mut recog.err_handler)?;

			recog.base.set_state(815);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			recog.base.set_state(820);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==DOT {
				{
				{
				recog.base.set_state(816);
				recog.base.match_token(DOT,&mut recog.err_handler)?;

				recog.base.set_state(817);
				recog.base.match_token(Identifier,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(822);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(823);
			recog.base.match_token(LBRACE,&mut recog.err_handler)?;

			recog.base.set_state(827);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << EXPORTS) | (1usize << OPENS) | (1usize << PROVIDES) | (1usize << REQUIRES) | (1usize << USES))) != 0) {
				{
				{
				/*InvokeRule moduleDirective*/
				recog.base.set_state(824);
				recog.moduleDirective()?;

				}
				}
				recog.base.set_state(829);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(830);
			recog.base.match_token(RBRACE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- moduleDirective ----------------
pub type ModuleDirectiveContextAll<'input> = ModuleDirectiveContext<'input>;


pub type ModuleDirectiveContext<'input> = BaseParserRuleContext<'input,ModuleDirectiveContextExt<'input>>;

#[derive(Clone)]
pub struct ModuleDirectiveContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ModuleDirectiveContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ModuleDirectiveContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_moduleDirective(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_moduleDirective(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ModuleDirectiveContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_moduleDirective(self);
	}
}

impl<'input> CustomRuleContext<'input> for ModuleDirectiveContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_moduleDirective }
	//fn type_rule_index() -> usize where Self: Sized { RULE_moduleDirective }
}
antlr_rust::tid!{ModuleDirectiveContextExt<'a>}

impl<'input> ModuleDirectiveContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ModuleDirectiveContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ModuleDirectiveContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ModuleDirectiveContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ModuleDirectiveContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token REQUIRES
/// Returns `None` if there is no child corresponding to token REQUIRES
fn REQUIRES(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(REQUIRES, 0)
}
fn moduleName_all(&self) ->  Vec<Rc<ModuleNameContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn moduleName(&self, i: usize) -> Option<Rc<ModuleNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}
fn requiresModifier_all(&self) ->  Vec<Rc<RequiresModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn requiresModifier(&self, i: usize) -> Option<Rc<RequiresModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token EXPORTS
/// Returns `None` if there is no child corresponding to token EXPORTS
fn EXPORTS(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(EXPORTS, 0)
}
fn packageName(&self) -> Option<Rc<PackageNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token TO
/// Returns `None` if there is no child corresponding to token TO
fn TO(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(TO, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
/// Retrieves first TerminalNode corresponding to token OPENS
/// Returns `None` if there is no child corresponding to token OPENS
fn OPENS(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(OPENS, 0)
}
/// Retrieves first TerminalNode corresponding to token USES
/// Returns `None` if there is no child corresponding to token USES
fn USES(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(USES, 0)
}
fn typeName_all(&self) ->  Vec<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeName(&self, i: usize) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token PROVIDES
/// Returns `None` if there is no child corresponding to token PROVIDES
fn PROVIDES(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(PROVIDES, 0)
}
/// Retrieves first TerminalNode corresponding to token WITH
/// Returns `None` if there is no child corresponding to token WITH
fn WITH(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(WITH, 0)
}

}

impl<'input> ModuleDirectiveContextAttrs<'input> for ModuleDirectiveContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn moduleDirective(&mut self,)
	-> Result<Rc<ModuleDirectiveContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ModuleDirectiveContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 88, RULE_moduleDirective);
        let mut _localctx: Rc<ModuleDirectiveContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(889);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 REQUIRES 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(832);
					recog.base.match_token(REQUIRES,&mut recog.err_handler)?;

					recog.base.set_state(836);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==TRANSITIVE || _la==STATIC {
						{
						{
						/*InvokeRule requiresModifier*/
						recog.base.set_state(833);
						recog.requiresModifier()?;

						}
						}
						recog.base.set_state(838);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule moduleName*/
					recog.base.set_state(839);
					recog.moduleName()?;

					recog.base.set_state(840);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}

			 EXPORTS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(842);
					recog.base.match_token(EXPORTS,&mut recog.err_handler)?;

					/*InvokeRule packageName*/
					recog.base.set_state(843);
					recog.packageName()?;

					recog.base.set_state(853);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==TO {
						{
						recog.base.set_state(844);
						recog.base.match_token(TO,&mut recog.err_handler)?;

						/*InvokeRule moduleName*/
						recog.base.set_state(845);
						recog.moduleName()?;

						recog.base.set_state(850);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==COMMA {
							{
							{
							recog.base.set_state(846);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule moduleName*/
							recog.base.set_state(847);
							recog.moduleName()?;

							}
							}
							recog.base.set_state(852);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						}
					}

					recog.base.set_state(855);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}

			 OPENS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(857);
					recog.base.match_token(OPENS,&mut recog.err_handler)?;

					/*InvokeRule packageName*/
					recog.base.set_state(858);
					recog.packageName()?;

					recog.base.set_state(868);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==TO {
						{
						recog.base.set_state(859);
						recog.base.match_token(TO,&mut recog.err_handler)?;

						/*InvokeRule moduleName*/
						recog.base.set_state(860);
						recog.moduleName()?;

						recog.base.set_state(865);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==COMMA {
							{
							{
							recog.base.set_state(861);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule moduleName*/
							recog.base.set_state(862);
							recog.moduleName()?;

							}
							}
							recog.base.set_state(867);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						}
					}

					recog.base.set_state(870);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}

			 USES 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(872);
					recog.base.match_token(USES,&mut recog.err_handler)?;

					/*InvokeRule typeName*/
					recog.base.set_state(873);
					recog.typeName()?;

					recog.base.set_state(874);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}

			 PROVIDES 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(876);
					recog.base.match_token(PROVIDES,&mut recog.err_handler)?;

					/*InvokeRule typeName*/
					recog.base.set_state(877);
					recog.typeName()?;

					recog.base.set_state(878);
					recog.base.match_token(WITH,&mut recog.err_handler)?;

					/*InvokeRule typeName*/
					recog.base.set_state(879);
					recog.typeName()?;

					recog.base.set_state(884);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==COMMA {
						{
						{
						recog.base.set_state(880);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						/*InvokeRule typeName*/
						recog.base.set_state(881);
						recog.typeName()?;

						}
						}
						recog.base.set_state(886);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(887);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- requiresModifier ----------------
pub type RequiresModifierContextAll<'input> = RequiresModifierContext<'input>;


pub type RequiresModifierContext<'input> = BaseParserRuleContext<'input,RequiresModifierContextExt<'input>>;

#[derive(Clone)]
pub struct RequiresModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for RequiresModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for RequiresModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_requiresModifier(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_requiresModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for RequiresModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_requiresModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for RequiresModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_requiresModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_requiresModifier }
}
antlr_rust::tid!{RequiresModifierContextExt<'a>}

impl<'input> RequiresModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RequiresModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RequiresModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RequiresModifierContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<RequiresModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token TRANSITIVE
/// Returns `None` if there is no child corresponding to token TRANSITIVE
fn TRANSITIVE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(TRANSITIVE, 0)
}
/// Retrieves first TerminalNode corresponding to token STATIC
/// Returns `None` if there is no child corresponding to token STATIC
fn STATIC(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(STATIC, 0)
}

}

impl<'input> RequiresModifierContextAttrs<'input> for RequiresModifierContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn requiresModifier(&mut self,)
	-> Result<Rc<RequiresModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RequiresModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 90, RULE_requiresModifier);
        let mut _localctx: Rc<RequiresModifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(891);
			_la = recog.base.input.la(1);
			if { !(_la==TRANSITIVE || _la==STATIC) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classDeclaration ----------------
pub type ClassDeclarationContextAll<'input> = ClassDeclarationContext<'input>;


pub type ClassDeclarationContext<'input> = BaseParserRuleContext<'input,ClassDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct ClassDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ClassDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ClassDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_classDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ClassDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_classDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classDeclaration }
}
antlr_rust::tid!{ClassDeclarationContextExt<'a>}

impl<'input> ClassDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ClassDeclarationContextExt<'input>>{

fn normalClassDeclaration(&self) -> Option<Rc<NormalClassDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn enumDeclaration(&self) -> Option<Rc<EnumDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn recordDeclaration(&self) -> Option<Rc<RecordDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ClassDeclarationContextAttrs<'input> for ClassDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classDeclaration(&mut self,)
	-> Result<Rc<ClassDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 92, RULE_classDeclaration);
        let mut _localctx: Rc<ClassDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(896);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(58,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule normalClassDeclaration*/
					recog.base.set_state(893);
					recog.normalClassDeclaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule enumDeclaration*/
					recog.base.set_state(894);
					recog.enumDeclaration()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule recordDeclaration*/
					recog.base.set_state(895);
					recog.recordDeclaration()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- normalClassDeclaration ----------------
pub type NormalClassDeclarationContextAll<'input> = NormalClassDeclarationContext<'input>;


pub type NormalClassDeclarationContext<'input> = BaseParserRuleContext<'input,NormalClassDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct NormalClassDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for NormalClassDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for NormalClassDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_normalClassDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_normalClassDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for NormalClassDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_normalClassDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for NormalClassDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_normalClassDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_normalClassDeclaration }
}
antlr_rust::tid!{NormalClassDeclarationContextExt<'a>}

impl<'input> NormalClassDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NormalClassDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NormalClassDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NormalClassDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<NormalClassDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token CLASS
/// Returns `None` if there is no child corresponding to token CLASS
fn CLASS(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(CLASS, 0)
}
fn typeIdentifier(&self) -> Option<Rc<TypeIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classBody(&self) -> Option<Rc<ClassBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classModifier_all(&self) ->  Vec<Rc<ClassModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn classModifier(&self, i: usize) -> Option<Rc<ClassModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn typeParameters(&self) -> Option<Rc<TypeParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classExtends(&self) -> Option<Rc<ClassExtendsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classImplements(&self) -> Option<Rc<ClassImplementsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classPermits(&self) -> Option<Rc<ClassPermitsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NormalClassDeclarationContextAttrs<'input> for NormalClassDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn normalClassDeclaration(&mut self,)
	-> Result<Rc<NormalClassDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NormalClassDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 94, RULE_normalClassDeclaration);
        let mut _localctx: Rc<NormalClassDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(901);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << NONSEALED) | (1usize << SEALED) | (1usize << ABSTRACT))) != 0) || ((((_la - 35)) & !0x3f) == 0 && ((1usize << (_la - 35)) & ((1usize << (FINAL - 35)) | (1usize << (PRIVATE - 35)) | (1usize << (PROTECTED - 35)) | (1usize << (PUBLIC - 35)) | (1usize << (STATIC - 35)) | (1usize << (STRICTFP - 35)))) != 0) || _la==AT {
				{
				{
				/*InvokeRule classModifier*/
				recog.base.set_state(898);
				recog.classModifier()?;

				}
				}
				recog.base.set_state(903);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(904);
			recog.base.match_token(CLASS,&mut recog.err_handler)?;

			/*InvokeRule typeIdentifier*/
			recog.base.set_state(905);
			recog.typeIdentifier()?;

			recog.base.set_state(907);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LT {
				{
				/*InvokeRule typeParameters*/
				recog.base.set_state(906);
				recog.typeParameters()?;

				}
			}

			recog.base.set_state(910);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==EXTENDS {
				{
				/*InvokeRule classExtends*/
				recog.base.set_state(909);
				recog.classExtends()?;

				}
			}

			recog.base.set_state(913);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==IMPLEMENTS {
				{
				/*InvokeRule classImplements*/
				recog.base.set_state(912);
				recog.classImplements()?;

				}
			}

			recog.base.set_state(916);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==PERMITS {
				{
				/*InvokeRule classPermits*/
				recog.base.set_state(915);
				recog.classPermits()?;

				}
			}

			/*InvokeRule classBody*/
			recog.base.set_state(918);
			recog.classBody()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classModifier ----------------
pub type ClassModifierContextAll<'input> = ClassModifierContext<'input>;


pub type ClassModifierContext<'input> = BaseParserRuleContext<'input,ClassModifierContextExt<'input>>;

#[derive(Clone)]
pub struct ClassModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ClassModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ClassModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classModifier(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_classModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ClassModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_classModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classModifier }
}
antlr_rust::tid!{ClassModifierContextExt<'a>}

impl<'input> ClassModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassModifierContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ClassModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token PUBLIC
/// Returns `None` if there is no child corresponding to token PUBLIC
fn PUBLIC(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(PUBLIC, 0)
}
/// Retrieves first TerminalNode corresponding to token PROTECTED
/// Returns `None` if there is no child corresponding to token PROTECTED
fn PROTECTED(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(PROTECTED, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIVATE
/// Returns `None` if there is no child corresponding to token PRIVATE
fn PRIVATE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(PRIVATE, 0)
}
/// Retrieves first TerminalNode corresponding to token ABSTRACT
/// Returns `None` if there is no child corresponding to token ABSTRACT
fn ABSTRACT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(ABSTRACT, 0)
}
/// Retrieves first TerminalNode corresponding to token STATIC
/// Returns `None` if there is no child corresponding to token STATIC
fn STATIC(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(STATIC, 0)
}
/// Retrieves first TerminalNode corresponding to token FINAL
/// Returns `None` if there is no child corresponding to token FINAL
fn FINAL(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(FINAL, 0)
}
/// Retrieves first TerminalNode corresponding to token SEALED
/// Returns `None` if there is no child corresponding to token SEALED
fn SEALED(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEALED, 0)
}
/// Retrieves first TerminalNode corresponding to token NONSEALED
/// Returns `None` if there is no child corresponding to token NONSEALED
fn NONSEALED(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(NONSEALED, 0)
}
/// Retrieves first TerminalNode corresponding to token STRICTFP
/// Returns `None` if there is no child corresponding to token STRICTFP
fn STRICTFP(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(STRICTFP, 0)
}

}

impl<'input> ClassModifierContextAttrs<'input> for ClassModifierContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classModifier(&mut self,)
	-> Result<Rc<ClassModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 96, RULE_classModifier);
        let mut _localctx: Rc<ClassModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(930);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 AT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(920);
					recog.annotation()?;

					}
				}

			 PUBLIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(921);
					recog.base.match_token(PUBLIC,&mut recog.err_handler)?;

					}
				}

			 PROTECTED 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(922);
					recog.base.match_token(PROTECTED,&mut recog.err_handler)?;

					}
				}

			 PRIVATE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(923);
					recog.base.match_token(PRIVATE,&mut recog.err_handler)?;

					}
				}

			 ABSTRACT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(924);
					recog.base.match_token(ABSTRACT,&mut recog.err_handler)?;

					}
				}

			 STATIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					recog.base.set_state(925);
					recog.base.match_token(STATIC,&mut recog.err_handler)?;

					}
				}

			 FINAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					recog.base.set_state(926);
					recog.base.match_token(FINAL,&mut recog.err_handler)?;

					}
				}

			 SEALED 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					recog.base.set_state(927);
					recog.base.match_token(SEALED,&mut recog.err_handler)?;

					}
				}

			 NONSEALED 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					recog.base.set_state(928);
					recog.base.match_token(NONSEALED,&mut recog.err_handler)?;

					}
				}

			 STRICTFP 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					recog.base.set_state(929);
					recog.base.match_token(STRICTFP,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeParameters ----------------
pub type TypeParametersContextAll<'input> = TypeParametersContext<'input>;


pub type TypeParametersContext<'input> = BaseParserRuleContext<'input,TypeParametersContextExt<'input>>;

#[derive(Clone)]
pub struct TypeParametersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for TypeParametersContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for TypeParametersContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeParameters(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_typeParameters(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for TypeParametersContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_typeParameters(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeParametersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeParameters }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeParameters }
}
antlr_rust::tid!{TypeParametersContextExt<'a>}

impl<'input> TypeParametersContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeParametersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeParametersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeParametersContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<TypeParametersContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LT
/// Returns `None` if there is no child corresponding to token LT
fn LT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LT, 0)
}
fn typeParameterList(&self) -> Option<Rc<TypeParameterListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token GT
/// Returns `None` if there is no child corresponding to token GT
fn GT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(GT, 0)
}

}

impl<'input> TypeParametersContextAttrs<'input> for TypeParametersContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeParameters(&mut self,)
	-> Result<Rc<TypeParametersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeParametersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 98, RULE_typeParameters);
        let mut _localctx: Rc<TypeParametersContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(932);
			recog.base.match_token(LT,&mut recog.err_handler)?;

			/*InvokeRule typeParameterList*/
			recog.base.set_state(933);
			recog.typeParameterList()?;

			recog.base.set_state(934);
			recog.base.match_token(GT,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeParameterList ----------------
pub type TypeParameterListContextAll<'input> = TypeParameterListContext<'input>;


pub type TypeParameterListContext<'input> = BaseParserRuleContext<'input,TypeParameterListContextExt<'input>>;

#[derive(Clone)]
pub struct TypeParameterListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for TypeParameterListContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for TypeParameterListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeParameterList(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_typeParameterList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for TypeParameterListContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_typeParameterList(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeParameterListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeParameterList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeParameterList }
}
antlr_rust::tid!{TypeParameterListContextExt<'a>}

impl<'input> TypeParameterListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeParameterListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeParameterListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeParameterListContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<TypeParameterListContextExt<'input>>{

fn typeParameter_all(&self) ->  Vec<Rc<TypeParameterContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeParameter(&self, i: usize) -> Option<Rc<TypeParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> TypeParameterListContextAttrs<'input> for TypeParameterListContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeParameterList(&mut self,)
	-> Result<Rc<TypeParameterListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeParameterListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 100, RULE_typeParameterList);
        let mut _localctx: Rc<TypeParameterListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule typeParameter*/
			recog.base.set_state(936);
			recog.typeParameter()?;

			recog.base.set_state(941);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				recog.base.set_state(937);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				/*InvokeRule typeParameter*/
				recog.base.set_state(938);
				recog.typeParameter()?;

				}
				}
				recog.base.set_state(943);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classExtends ----------------
pub type ClassExtendsContextAll<'input> = ClassExtendsContext<'input>;


pub type ClassExtendsContext<'input> = BaseParserRuleContext<'input,ClassExtendsContextExt<'input>>;

#[derive(Clone)]
pub struct ClassExtendsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ClassExtendsContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ClassExtendsContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classExtends(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_classExtends(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ClassExtendsContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_classExtends(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassExtendsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classExtends }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classExtends }
}
antlr_rust::tid!{ClassExtendsContextExt<'a>}

impl<'input> ClassExtendsContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassExtendsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassExtendsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassExtendsContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ClassExtendsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token EXTENDS
/// Returns `None` if there is no child corresponding to token EXTENDS
fn EXTENDS(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(EXTENDS, 0)
}
fn classType(&self) -> Option<Rc<ClassTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ClassExtendsContextAttrs<'input> for ClassExtendsContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classExtends(&mut self,)
	-> Result<Rc<ClassExtendsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassExtendsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 102, RULE_classExtends);
        let mut _localctx: Rc<ClassExtendsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(944);
			recog.base.match_token(EXTENDS,&mut recog.err_handler)?;

			/*InvokeRule classType*/
			recog.base.set_state(945);
			recog.classType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classImplements ----------------
pub type ClassImplementsContextAll<'input> = ClassImplementsContext<'input>;


pub type ClassImplementsContext<'input> = BaseParserRuleContext<'input,ClassImplementsContextExt<'input>>;

#[derive(Clone)]
pub struct ClassImplementsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ClassImplementsContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ClassImplementsContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classImplements(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_classImplements(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ClassImplementsContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_classImplements(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassImplementsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classImplements }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classImplements }
}
antlr_rust::tid!{ClassImplementsContextExt<'a>}

impl<'input> ClassImplementsContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassImplementsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassImplementsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassImplementsContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ClassImplementsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IMPLEMENTS
/// Returns `None` if there is no child corresponding to token IMPLEMENTS
fn IMPLEMENTS(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(IMPLEMENTS, 0)
}
fn interfaceTypeList(&self) -> Option<Rc<InterfaceTypeListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ClassImplementsContextAttrs<'input> for ClassImplementsContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classImplements(&mut self,)
	-> Result<Rc<ClassImplementsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassImplementsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 104, RULE_classImplements);
        let mut _localctx: Rc<ClassImplementsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(947);
			recog.base.match_token(IMPLEMENTS,&mut recog.err_handler)?;

			/*InvokeRule interfaceTypeList*/
			recog.base.set_state(948);
			recog.interfaceTypeList()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfaceTypeList ----------------
pub type InterfaceTypeListContextAll<'input> = InterfaceTypeListContext<'input>;


pub type InterfaceTypeListContext<'input> = BaseParserRuleContext<'input,InterfaceTypeListContextExt<'input>>;

#[derive(Clone)]
pub struct InterfaceTypeListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for InterfaceTypeListContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for InterfaceTypeListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_interfaceTypeList(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_interfaceTypeList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for InterfaceTypeListContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_interfaceTypeList(self);
	}
}

impl<'input> CustomRuleContext<'input> for InterfaceTypeListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfaceTypeList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfaceTypeList }
}
antlr_rust::tid!{InterfaceTypeListContextExt<'a>}

impl<'input> InterfaceTypeListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfaceTypeListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfaceTypeListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfaceTypeListContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<InterfaceTypeListContextExt<'input>>{

fn interfaceType_all(&self) ->  Vec<Rc<InterfaceTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn interfaceType(&self, i: usize) -> Option<Rc<InterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> InterfaceTypeListContextAttrs<'input> for InterfaceTypeListContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfaceTypeList(&mut self,)
	-> Result<Rc<InterfaceTypeListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfaceTypeListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 106, RULE_interfaceTypeList);
        let mut _localctx: Rc<InterfaceTypeListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule interfaceType*/
			recog.base.set_state(950);
			recog.interfaceType()?;

			recog.base.set_state(955);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				recog.base.set_state(951);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				/*InvokeRule interfaceType*/
				recog.base.set_state(952);
				recog.interfaceType()?;

				}
				}
				recog.base.set_state(957);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classPermits ----------------
pub type ClassPermitsContextAll<'input> = ClassPermitsContext<'input>;


pub type ClassPermitsContext<'input> = BaseParserRuleContext<'input,ClassPermitsContextExt<'input>>;

#[derive(Clone)]
pub struct ClassPermitsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ClassPermitsContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ClassPermitsContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classPermits(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_classPermits(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ClassPermitsContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_classPermits(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassPermitsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classPermits }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classPermits }
}
antlr_rust::tid!{ClassPermitsContextExt<'a>}

impl<'input> ClassPermitsContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassPermitsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassPermitsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassPermitsContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ClassPermitsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token PERMITS
/// Returns `None` if there is no child corresponding to token PERMITS
fn PERMITS(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(PERMITS, 0)
}
fn typeName_all(&self) ->  Vec<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeName(&self, i: usize) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> ClassPermitsContextAttrs<'input> for ClassPermitsContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classPermits(&mut self,)
	-> Result<Rc<ClassPermitsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassPermitsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 108, RULE_classPermits);
        let mut _localctx: Rc<ClassPermitsContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(958);
			recog.base.match_token(PERMITS,&mut recog.err_handler)?;

			/*InvokeRule typeName*/
			recog.base.set_state(959);
			recog.typeName()?;

			recog.base.set_state(964);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				recog.base.set_state(960);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				/*InvokeRule typeName*/
				recog.base.set_state(961);
				recog.typeName()?;

				}
				}
				recog.base.set_state(966);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classBody ----------------
pub type ClassBodyContextAll<'input> = ClassBodyContext<'input>;


pub type ClassBodyContext<'input> = BaseParserRuleContext<'input,ClassBodyContextExt<'input>>;

#[derive(Clone)]
pub struct ClassBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ClassBodyContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ClassBodyContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classBody(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_classBody(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ClassBodyContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_classBody(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classBody }
}
antlr_rust::tid!{ClassBodyContextExt<'a>}

impl<'input> ClassBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassBodyContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ClassBodyContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}
fn classBodyDeclaration_all(&self) ->  Vec<Rc<ClassBodyDeclarationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn classBodyDeclaration(&self, i: usize) -> Option<Rc<ClassBodyDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ClassBodyContextAttrs<'input> for ClassBodyContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classBody(&mut self,)
	-> Result<Rc<ClassBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 110, RULE_classBody);
        let mut _localctx: Rc<ClassBodyContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(967);
			recog.base.match_token(LBRACE,&mut recog.err_handler)?;

			recog.base.set_state(971);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << NONSEALED) | (1usize << RECORD) | (1usize << SEALED) | (1usize << ABSTRACT) | (1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << CLASS) | (1usize << DOUBLE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (ENUM - 33)) | (1usize << (FINAL - 33)) | (1usize << (FLOAT - 33)) | (1usize << (INT - 33)) | (1usize << (INTERFACE - 33)) | (1usize << (LONG - 33)) | (1usize << (NATIVE - 33)) | (1usize << (PRIVATE - 33)) | (1usize << (PROTECTED - 33)) | (1usize << (PUBLIC - 33)) | (1usize << (SHORT - 33)) | (1usize << (STATIC - 33)) | (1usize << (STRICTFP - 33)) | (1usize << (SYNCHRONIZED - 33)) | (1usize << (TRANSIENT - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (VOID - 65)) | (1usize << (VOLATILE - 65)) | (1usize << (LBRACE - 65)) | (1usize << (SEMI - 65)) | (1usize << (AT - 65)) | (1usize << (LT - 65)))) != 0) || _la==Identifier {
				{
				{
				/*InvokeRule classBodyDeclaration*/
				recog.base.set_state(968);
				recog.classBodyDeclaration()?;

				}
				}
				recog.base.set_state(973);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(974);
			recog.base.match_token(RBRACE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classBodyDeclaration ----------------
pub type ClassBodyDeclarationContextAll<'input> = ClassBodyDeclarationContext<'input>;


pub type ClassBodyDeclarationContext<'input> = BaseParserRuleContext<'input,ClassBodyDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct ClassBodyDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ClassBodyDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ClassBodyDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classBodyDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_classBodyDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ClassBodyDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_classBodyDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassBodyDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classBodyDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classBodyDeclaration }
}
antlr_rust::tid!{ClassBodyDeclarationContextExt<'a>}

impl<'input> ClassBodyDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassBodyDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassBodyDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassBodyDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ClassBodyDeclarationContextExt<'input>>{

fn classMemberDeclaration(&self) -> Option<Rc<ClassMemberDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn instanceInitializer(&self) -> Option<Rc<InstanceInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn staticInitializer(&self) -> Option<Rc<StaticInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constructorDeclaration(&self) -> Option<Rc<ConstructorDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ClassBodyDeclarationContextAttrs<'input> for ClassBodyDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classBodyDeclaration(&mut self,)
	-> Result<Rc<ClassBodyDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassBodyDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 112, RULE_classBodyDeclaration);
        let mut _localctx: Rc<ClassBodyDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(980);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(69,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule classMemberDeclaration*/
					recog.base.set_state(976);
					recog.classMemberDeclaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule instanceInitializer*/
					recog.base.set_state(977);
					recog.instanceInitializer()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule staticInitializer*/
					recog.base.set_state(978);
					recog.staticInitializer()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule constructorDeclaration*/
					recog.base.set_state(979);
					recog.constructorDeclaration()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classMemberDeclaration ----------------
pub type ClassMemberDeclarationContextAll<'input> = ClassMemberDeclarationContext<'input>;


pub type ClassMemberDeclarationContext<'input> = BaseParserRuleContext<'input,ClassMemberDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct ClassMemberDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ClassMemberDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ClassMemberDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classMemberDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_classMemberDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ClassMemberDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_classMemberDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassMemberDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classMemberDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classMemberDeclaration }
}
antlr_rust::tid!{ClassMemberDeclarationContextExt<'a>}

impl<'input> ClassMemberDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassMemberDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassMemberDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassMemberDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ClassMemberDeclarationContextExt<'input>>{

fn fieldDeclaration(&self) -> Option<Rc<FieldDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodDeclaration(&self) -> Option<Rc<MethodDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classDeclaration(&self) -> Option<Rc<ClassDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfaceDeclaration(&self) -> Option<Rc<InterfaceDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> ClassMemberDeclarationContextAttrs<'input> for ClassMemberDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classMemberDeclaration(&mut self,)
	-> Result<Rc<ClassMemberDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassMemberDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 114, RULE_classMemberDeclaration);
        let mut _localctx: Rc<ClassMemberDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(987);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(70,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule fieldDeclaration*/
					recog.base.set_state(982);
					recog.fieldDeclaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule methodDeclaration*/
					recog.base.set_state(983);
					recog.methodDeclaration()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule classDeclaration*/
					recog.base.set_state(984);
					recog.classDeclaration()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule interfaceDeclaration*/
					recog.base.set_state(985);
					recog.interfaceDeclaration()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(986);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- fieldDeclaration ----------------
pub type FieldDeclarationContextAll<'input> = FieldDeclarationContext<'input>;


pub type FieldDeclarationContext<'input> = BaseParserRuleContext<'input,FieldDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct FieldDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for FieldDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for FieldDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_fieldDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_fieldDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for FieldDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_fieldDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for FieldDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_fieldDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_fieldDeclaration }
}
antlr_rust::tid!{FieldDeclarationContextExt<'a>}

impl<'input> FieldDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FieldDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FieldDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FieldDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<FieldDeclarationContextExt<'input>>{

fn unannType(&self) -> Option<Rc<UnannTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableDeclaratorList(&self) -> Option<Rc<VariableDeclaratorListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}
fn fieldModifier_all(&self) ->  Vec<Rc<FieldModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn fieldModifier(&self, i: usize) -> Option<Rc<FieldModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> FieldDeclarationContextAttrs<'input> for FieldDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn fieldDeclaration(&mut self,)
	-> Result<Rc<FieldDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FieldDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 116, RULE_fieldDeclaration);
        let mut _localctx: Rc<FieldDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(992);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while ((((_la - 35)) & !0x3f) == 0 && ((1usize << (_la - 35)) & ((1usize << (FINAL - 35)) | (1usize << (PRIVATE - 35)) | (1usize << (PROTECTED - 35)) | (1usize << (PUBLIC - 35)) | (1usize << (STATIC - 35)) | (1usize << (TRANSIENT - 35)) | (1usize << (VOLATILE - 35)))) != 0) || _la==AT {
				{
				{
				/*InvokeRule fieldModifier*/
				recog.base.set_state(989);
				recog.fieldModifier()?;

				}
				}
				recog.base.set_state(994);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule unannType*/
			recog.base.set_state(995);
			recog.unannType()?;

			/*InvokeRule variableDeclaratorList*/
			recog.base.set_state(996);
			recog.variableDeclaratorList()?;

			recog.base.set_state(997);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- fieldModifier ----------------
pub type FieldModifierContextAll<'input> = FieldModifierContext<'input>;


pub type FieldModifierContext<'input> = BaseParserRuleContext<'input,FieldModifierContextExt<'input>>;

#[derive(Clone)]
pub struct FieldModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for FieldModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for FieldModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_fieldModifier(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_fieldModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for FieldModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_fieldModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for FieldModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_fieldModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_fieldModifier }
}
antlr_rust::tid!{FieldModifierContextExt<'a>}

impl<'input> FieldModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FieldModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FieldModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FieldModifierContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<FieldModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token PUBLIC
/// Returns `None` if there is no child corresponding to token PUBLIC
fn PUBLIC(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(PUBLIC, 0)
}
/// Retrieves first TerminalNode corresponding to token PROTECTED
/// Returns `None` if there is no child corresponding to token PROTECTED
fn PROTECTED(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(PROTECTED, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIVATE
/// Returns `None` if there is no child corresponding to token PRIVATE
fn PRIVATE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(PRIVATE, 0)
}
/// Retrieves first TerminalNode corresponding to token STATIC
/// Returns `None` if there is no child corresponding to token STATIC
fn STATIC(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(STATIC, 0)
}
/// Retrieves first TerminalNode corresponding to token FINAL
/// Returns `None` if there is no child corresponding to token FINAL
fn FINAL(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(FINAL, 0)
}
/// Retrieves first TerminalNode corresponding to token TRANSIENT
/// Returns `None` if there is no child corresponding to token TRANSIENT
fn TRANSIENT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(TRANSIENT, 0)
}
/// Retrieves first TerminalNode corresponding to token VOLATILE
/// Returns `None` if there is no child corresponding to token VOLATILE
fn VOLATILE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(VOLATILE, 0)
}

}

impl<'input> FieldModifierContextAttrs<'input> for FieldModifierContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn fieldModifier(&mut self,)
	-> Result<Rc<FieldModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FieldModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 118, RULE_fieldModifier);
        let mut _localctx: Rc<FieldModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1007);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 AT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(999);
					recog.annotation()?;

					}
				}

			 PUBLIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1000);
					recog.base.match_token(PUBLIC,&mut recog.err_handler)?;

					}
				}

			 PROTECTED 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(1001);
					recog.base.match_token(PROTECTED,&mut recog.err_handler)?;

					}
				}

			 PRIVATE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(1002);
					recog.base.match_token(PRIVATE,&mut recog.err_handler)?;

					}
				}

			 STATIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(1003);
					recog.base.match_token(STATIC,&mut recog.err_handler)?;

					}
				}

			 FINAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					recog.base.set_state(1004);
					recog.base.match_token(FINAL,&mut recog.err_handler)?;

					}
				}

			 TRANSIENT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					recog.base.set_state(1005);
					recog.base.match_token(TRANSIENT,&mut recog.err_handler)?;

					}
				}

			 VOLATILE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					recog.base.set_state(1006);
					recog.base.match_token(VOLATILE,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- variableDeclaratorList ----------------
pub type VariableDeclaratorListContextAll<'input> = VariableDeclaratorListContext<'input>;


pub type VariableDeclaratorListContext<'input> = BaseParserRuleContext<'input,VariableDeclaratorListContextExt<'input>>;

#[derive(Clone)]
pub struct VariableDeclaratorListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for VariableDeclaratorListContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for VariableDeclaratorListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_variableDeclaratorList(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_variableDeclaratorList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for VariableDeclaratorListContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_variableDeclaratorList(self);
	}
}

impl<'input> CustomRuleContext<'input> for VariableDeclaratorListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_variableDeclaratorList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_variableDeclaratorList }
}
antlr_rust::tid!{VariableDeclaratorListContextExt<'a>}

impl<'input> VariableDeclaratorListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VariableDeclaratorListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VariableDeclaratorListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VariableDeclaratorListContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<VariableDeclaratorListContextExt<'input>>{

fn variableDeclarator_all(&self) ->  Vec<Rc<VariableDeclaratorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn variableDeclarator(&self, i: usize) -> Option<Rc<VariableDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> VariableDeclaratorListContextAttrs<'input> for VariableDeclaratorListContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn variableDeclaratorList(&mut self,)
	-> Result<Rc<VariableDeclaratorListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VariableDeclaratorListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 120, RULE_variableDeclaratorList);
        let mut _localctx: Rc<VariableDeclaratorListContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule variableDeclarator*/
			recog.base.set_state(1009);
			recog.variableDeclarator()?;

			recog.base.set_state(1014);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(73,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1010);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule variableDeclarator*/
					recog.base.set_state(1011);
					recog.variableDeclarator()?;

					}
					} 
				}
				recog.base.set_state(1016);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(73,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- variableDeclarator ----------------
pub type VariableDeclaratorContextAll<'input> = VariableDeclaratorContext<'input>;


pub type VariableDeclaratorContext<'input> = BaseParserRuleContext<'input,VariableDeclaratorContextExt<'input>>;

#[derive(Clone)]
pub struct VariableDeclaratorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for VariableDeclaratorContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for VariableDeclaratorContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_variableDeclarator(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_variableDeclarator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for VariableDeclaratorContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_variableDeclarator(self);
	}
}

impl<'input> CustomRuleContext<'input> for VariableDeclaratorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_variableDeclarator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_variableDeclarator }
}
antlr_rust::tid!{VariableDeclaratorContextExt<'a>}

impl<'input> VariableDeclaratorContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VariableDeclaratorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VariableDeclaratorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VariableDeclaratorContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<VariableDeclaratorContextExt<'input>>{

fn variableDeclaratorId(&self) -> Option<Rc<VariableDeclaratorIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ASSIGN
/// Returns `None` if there is no child corresponding to token ASSIGN
fn ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(ASSIGN, 0)
}
fn variableInitializer(&self) -> Option<Rc<VariableInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> VariableDeclaratorContextAttrs<'input> for VariableDeclaratorContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn variableDeclarator(&mut self,)
	-> Result<Rc<VariableDeclaratorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VariableDeclaratorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 122, RULE_variableDeclarator);
        let mut _localctx: Rc<VariableDeclaratorContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule variableDeclaratorId*/
			recog.base.set_state(1017);
			recog.variableDeclaratorId()?;

			recog.base.set_state(1020);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(74,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1018);
					recog.base.match_token(ASSIGN,&mut recog.err_handler)?;

					/*InvokeRule variableInitializer*/
					recog.base.set_state(1019);
					recog.variableInitializer()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- variableDeclaratorId ----------------
pub type VariableDeclaratorIdContextAll<'input> = VariableDeclaratorIdContext<'input>;


pub type VariableDeclaratorIdContext<'input> = BaseParserRuleContext<'input,VariableDeclaratorIdContextExt<'input>>;

#[derive(Clone)]
pub struct VariableDeclaratorIdContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for VariableDeclaratorIdContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for VariableDeclaratorIdContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_variableDeclaratorId(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_variableDeclaratorId(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for VariableDeclaratorIdContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_variableDeclaratorId(self);
	}
}

impl<'input> CustomRuleContext<'input> for VariableDeclaratorIdContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_variableDeclaratorId }
	//fn type_rule_index() -> usize where Self: Sized { RULE_variableDeclaratorId }
}
antlr_rust::tid!{VariableDeclaratorIdContextExt<'a>}

impl<'input> VariableDeclaratorIdContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VariableDeclaratorIdContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VariableDeclaratorIdContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VariableDeclaratorIdContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<VariableDeclaratorIdContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
fn dims(&self) -> Option<Rc<DimsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> VariableDeclaratorIdContextAttrs<'input> for VariableDeclaratorIdContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn variableDeclaratorId(&mut self,)
	-> Result<Rc<VariableDeclaratorIdContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VariableDeclaratorIdContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 124, RULE_variableDeclaratorId);
        let mut _localctx: Rc<VariableDeclaratorIdContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1022);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			recog.base.set_state(1024);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(75,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule dims*/
					recog.base.set_state(1023);
					recog.dims()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- variableInitializer ----------------
pub type VariableInitializerContextAll<'input> = VariableInitializerContext<'input>;


pub type VariableInitializerContext<'input> = BaseParserRuleContext<'input,VariableInitializerContextExt<'input>>;

#[derive(Clone)]
pub struct VariableInitializerContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for VariableInitializerContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for VariableInitializerContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_variableInitializer(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_variableInitializer(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for VariableInitializerContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_variableInitializer(self);
	}
}

impl<'input> CustomRuleContext<'input> for VariableInitializerContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_variableInitializer }
	//fn type_rule_index() -> usize where Self: Sized { RULE_variableInitializer }
}
antlr_rust::tid!{VariableInitializerContextExt<'a>}

impl<'input> VariableInitializerContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VariableInitializerContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VariableInitializerContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VariableInitializerContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<VariableInitializerContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn arrayInitializer(&self) -> Option<Rc<ArrayInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> VariableInitializerContextAttrs<'input> for VariableInitializerContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn variableInitializer(&mut self,)
	-> Result<Rc<VariableInitializerContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VariableInitializerContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 126, RULE_variableInitializer);
        let mut _localctx: Rc<VariableInitializerContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1028);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 BOOLEAN | BYTE | CHAR | DOUBLE | FLOAT | INT | LONG | NEW | SHORT | SUPER |
			 SWITCH | THIS | VOID | IntegerLiteral | FloatingPointLiteral | BooleanLiteral |
			 CharacterLiteral | StringLiteral | TextBlock | NullLiteral | LPAREN |
			 AT | BANG | TILDE | INC | DEC | ADD | SUB | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule expression*/
					recog.base.set_state(1026);
					recog.expression()?;

					}
				}

			 LBRACE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule arrayInitializer*/
					recog.base.set_state(1027);
					recog.arrayInitializer()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unannType ----------------
pub type UnannTypeContextAll<'input> = UnannTypeContext<'input>;


pub type UnannTypeContext<'input> = BaseParserRuleContext<'input,UnannTypeContextExt<'input>>;

#[derive(Clone)]
pub struct UnannTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for UnannTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for UnannTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unannType(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_unannType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for UnannTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_unannType(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnannTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unannType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unannType }
}
antlr_rust::tid!{UnannTypeContextExt<'a>}

impl<'input> UnannTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnannTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnannTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnannTypeContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<UnannTypeContextExt<'input>>{

fn unannPrimitiveType(&self) -> Option<Rc<UnannPrimitiveTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn unannReferenceType(&self) -> Option<Rc<UnannReferenceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UnannTypeContextAttrs<'input> for UnannTypeContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unannType(&mut self,)
	-> Result<Rc<UnannTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnannTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 128, RULE_unannType);
        let mut _localctx: Rc<UnannTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1032);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(77,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule unannPrimitiveType*/
					recog.base.set_state(1030);
					recog.unannPrimitiveType()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule unannReferenceType*/
					recog.base.set_state(1031);
					recog.unannReferenceType()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unannPrimitiveType ----------------
pub type UnannPrimitiveTypeContextAll<'input> = UnannPrimitiveTypeContext<'input>;


pub type UnannPrimitiveTypeContext<'input> = BaseParserRuleContext<'input,UnannPrimitiveTypeContextExt<'input>>;

#[derive(Clone)]
pub struct UnannPrimitiveTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for UnannPrimitiveTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for UnannPrimitiveTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unannPrimitiveType(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_unannPrimitiveType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for UnannPrimitiveTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_unannPrimitiveType(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnannPrimitiveTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unannPrimitiveType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unannPrimitiveType }
}
antlr_rust::tid!{UnannPrimitiveTypeContextExt<'a>}

impl<'input> UnannPrimitiveTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnannPrimitiveTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnannPrimitiveTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnannPrimitiveTypeContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<UnannPrimitiveTypeContextExt<'input>>{

fn numericType(&self) -> Option<Rc<NumericTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token BOOLEAN
/// Returns `None` if there is no child corresponding to token BOOLEAN
fn BOOLEAN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(BOOLEAN, 0)
}

}

impl<'input> UnannPrimitiveTypeContextAttrs<'input> for UnannPrimitiveTypeContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unannPrimitiveType(&mut self,)
	-> Result<Rc<UnannPrimitiveTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnannPrimitiveTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 130, RULE_unannPrimitiveType);
        let mut _localctx: Rc<UnannPrimitiveTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1036);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 BYTE | CHAR | DOUBLE | FLOAT | INT | LONG | SHORT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule numericType*/
					recog.base.set_state(1034);
					recog.numericType()?;

					}
				}

			 BOOLEAN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1035);
					recog.base.match_token(BOOLEAN,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unannReferenceType ----------------
pub type UnannReferenceTypeContextAll<'input> = UnannReferenceTypeContext<'input>;


pub type UnannReferenceTypeContext<'input> = BaseParserRuleContext<'input,UnannReferenceTypeContextExt<'input>>;

#[derive(Clone)]
pub struct UnannReferenceTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for UnannReferenceTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for UnannReferenceTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unannReferenceType(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_unannReferenceType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for UnannReferenceTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_unannReferenceType(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnannReferenceTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unannReferenceType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unannReferenceType }
}
antlr_rust::tid!{UnannReferenceTypeContextExt<'a>}

impl<'input> UnannReferenceTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnannReferenceTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnannReferenceTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnannReferenceTypeContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<UnannReferenceTypeContextExt<'input>>{

fn unannClassOrInterfaceType(&self) -> Option<Rc<UnannClassOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn unannTypeVariable(&self) -> Option<Rc<UnannTypeVariableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn unannArrayType(&self) -> Option<Rc<UnannArrayTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UnannReferenceTypeContextAttrs<'input> for UnannReferenceTypeContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unannReferenceType(&mut self,)
	-> Result<Rc<UnannReferenceTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnannReferenceTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 132, RULE_unannReferenceType);
        let mut _localctx: Rc<UnannReferenceTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1041);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(79,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule unannClassOrInterfaceType*/
					recog.base.set_state(1038);
					recog.unannClassOrInterfaceType()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule unannTypeVariable*/
					recog.base.set_state(1039);
					recog.unannTypeVariable()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule unannArrayType*/
					recog.base.set_state(1040);
					recog.unannArrayType()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unannClassOrInterfaceType ----------------
pub type UnannClassOrInterfaceTypeContextAll<'input> = UnannClassOrInterfaceTypeContext<'input>;


pub type UnannClassOrInterfaceTypeContext<'input> = BaseParserRuleContext<'input,UnannClassOrInterfaceTypeContextExt<'input>>;

#[derive(Clone)]
pub struct UnannClassOrInterfaceTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for UnannClassOrInterfaceTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for UnannClassOrInterfaceTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unannClassOrInterfaceType(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_unannClassOrInterfaceType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for UnannClassOrInterfaceTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_unannClassOrInterfaceType(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnannClassOrInterfaceTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unannClassOrInterfaceType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unannClassOrInterfaceType }
}
antlr_rust::tid!{UnannClassOrInterfaceTypeContextExt<'a>}

impl<'input> UnannClassOrInterfaceTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnannClassOrInterfaceTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnannClassOrInterfaceTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnannClassOrInterfaceTypeContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<UnannClassOrInterfaceTypeContextExt<'input>>{

fn typeIdentifier(&self) -> Option<Rc<TypeIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn packageName(&self) -> Option<Rc<PackageNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn uCOIT(&self) -> Option<Rc<UCOITContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> UnannClassOrInterfaceTypeContextAttrs<'input> for UnannClassOrInterfaceTypeContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unannClassOrInterfaceType(&mut self,)
	-> Result<Rc<UnannClassOrInterfaceTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnannClassOrInterfaceTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 134, RULE_unannClassOrInterfaceType);
        let mut _localctx: Rc<UnannClassOrInterfaceTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1051);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(81,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule packageName*/
					recog.base.set_state(1043);
					recog.packageName()?;

					recog.base.set_state(1044);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(1048);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==AT {
						{
						{
						/*InvokeRule annotation*/
						recog.base.set_state(1045);
						recog.annotation()?;

						}
						}
						recog.base.set_state(1050);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}

				_ => {}
			}
			/*InvokeRule typeIdentifier*/
			recog.base.set_state(1053);
			recog.typeIdentifier()?;

			recog.base.set_state(1055);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(82,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule typeArguments*/
					recog.base.set_state(1054);
					recog.typeArguments()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1058);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(83,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule uCOIT*/
					recog.base.set_state(1057);
					recog.uCOIT()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- uCOIT ----------------
pub type UCOITContextAll<'input> = UCOITContext<'input>;


pub type UCOITContext<'input> = BaseParserRuleContext<'input,UCOITContextExt<'input>>;

#[derive(Clone)]
pub struct UCOITContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for UCOITContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for UCOITContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_uCOIT(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_uCOIT(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for UCOITContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_uCOIT(self);
	}
}

impl<'input> CustomRuleContext<'input> for UCOITContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_uCOIT }
	//fn type_rule_index() -> usize where Self: Sized { RULE_uCOIT }
}
antlr_rust::tid!{UCOITContextExt<'a>}

impl<'input> UCOITContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UCOITContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UCOITContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UCOITContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<UCOITContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn typeIdentifier(&self) -> Option<Rc<TypeIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn uCOIT(&self) -> Option<Rc<UCOITContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UCOITContextAttrs<'input> for UCOITContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn uCOIT(&mut self,)
	-> Result<Rc<UCOITContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UCOITContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 136, RULE_uCOIT);
        let mut _localctx: Rc<UCOITContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1060);
			recog.base.match_token(DOT,&mut recog.err_handler)?;

			recog.base.set_state(1064);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(1061);
				recog.annotation()?;

				}
				}
				recog.base.set_state(1066);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule typeIdentifier*/
			recog.base.set_state(1067);
			recog.typeIdentifier()?;

			recog.base.set_state(1069);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(85,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule typeArguments*/
					recog.base.set_state(1068);
					recog.typeArguments()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1072);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(86,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule uCOIT*/
					recog.base.set_state(1071);
					recog.uCOIT()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unannClassType ----------------
pub type UnannClassTypeContextAll<'input> = UnannClassTypeContext<'input>;


pub type UnannClassTypeContext<'input> = BaseParserRuleContext<'input,UnannClassTypeContextExt<'input>>;

#[derive(Clone)]
pub struct UnannClassTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for UnannClassTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for UnannClassTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unannClassType(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_unannClassType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for UnannClassTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_unannClassType(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnannClassTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unannClassType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unannClassType }
}
antlr_rust::tid!{UnannClassTypeContextExt<'a>}

impl<'input> UnannClassTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnannClassTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnannClassTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnannClassTypeContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<UnannClassTypeContextExt<'input>>{

fn typeIdentifier(&self) -> Option<Rc<TypeIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn packageName(&self) -> Option<Rc<PackageNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn unannClassOrInterfaceType(&self) -> Option<Rc<UnannClassOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> UnannClassTypeContextAttrs<'input> for UnannClassTypeContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unannClassType(&mut self,)
	-> Result<Rc<UnannClassTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnannClassTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 138, RULE_unannClassType);
        let mut _localctx: Rc<UnannClassTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1093);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(91,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule typeIdentifier*/
					recog.base.set_state(1074);
					recog.typeIdentifier()?;

					recog.base.set_state(1076);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(1075);
						recog.typeArguments()?;

						}
					}

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1080);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(88,&mut recog.base)? {
						1 =>{
							{
							/*InvokeRule packageName*/
							recog.base.set_state(1078);
							recog.packageName()?;

							}
						}
					,
						2 =>{
							{
							/*InvokeRule unannClassOrInterfaceType*/
							recog.base.set_state(1079);
							recog.unannClassOrInterfaceType()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1082);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(1086);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==AT {
						{
						{
						/*InvokeRule annotation*/
						recog.base.set_state(1083);
						recog.annotation()?;

						}
						}
						recog.base.set_state(1088);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeIdentifier*/
					recog.base.set_state(1089);
					recog.typeIdentifier()?;

					recog.base.set_state(1091);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(1090);
						recog.typeArguments()?;

						}
					}

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unannInterfaceType ----------------
pub type UnannInterfaceTypeContextAll<'input> = UnannInterfaceTypeContext<'input>;


pub type UnannInterfaceTypeContext<'input> = BaseParserRuleContext<'input,UnannInterfaceTypeContextExt<'input>>;

#[derive(Clone)]
pub struct UnannInterfaceTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for UnannInterfaceTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for UnannInterfaceTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unannInterfaceType(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_unannInterfaceType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for UnannInterfaceTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_unannInterfaceType(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnannInterfaceTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unannInterfaceType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unannInterfaceType }
}
antlr_rust::tid!{UnannInterfaceTypeContextExt<'a>}

impl<'input> UnannInterfaceTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnannInterfaceTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnannInterfaceTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnannInterfaceTypeContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<UnannInterfaceTypeContextExt<'input>>{

fn unannClassType(&self) -> Option<Rc<UnannClassTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UnannInterfaceTypeContextAttrs<'input> for UnannInterfaceTypeContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unannInterfaceType(&mut self,)
	-> Result<Rc<UnannInterfaceTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnannInterfaceTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 140, RULE_unannInterfaceType);
        let mut _localctx: Rc<UnannInterfaceTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule unannClassType*/
			recog.base.set_state(1095);
			recog.unannClassType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unannTypeVariable ----------------
pub type UnannTypeVariableContextAll<'input> = UnannTypeVariableContext<'input>;


pub type UnannTypeVariableContext<'input> = BaseParserRuleContext<'input,UnannTypeVariableContextExt<'input>>;

#[derive(Clone)]
pub struct UnannTypeVariableContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for UnannTypeVariableContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for UnannTypeVariableContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unannTypeVariable(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_unannTypeVariable(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for UnannTypeVariableContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_unannTypeVariable(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnannTypeVariableContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unannTypeVariable }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unannTypeVariable }
}
antlr_rust::tid!{UnannTypeVariableContextExt<'a>}

impl<'input> UnannTypeVariableContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnannTypeVariableContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnannTypeVariableContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnannTypeVariableContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<UnannTypeVariableContextExt<'input>>{

fn typeIdentifier(&self) -> Option<Rc<TypeIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UnannTypeVariableContextAttrs<'input> for UnannTypeVariableContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unannTypeVariable(&mut self,)
	-> Result<Rc<UnannTypeVariableContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnannTypeVariableContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 142, RULE_unannTypeVariable);
        let mut _localctx: Rc<UnannTypeVariableContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule typeIdentifier*/
			recog.base.set_state(1097);
			recog.typeIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unannArrayType ----------------
pub type UnannArrayTypeContextAll<'input> = UnannArrayTypeContext<'input>;


pub type UnannArrayTypeContext<'input> = BaseParserRuleContext<'input,UnannArrayTypeContextExt<'input>>;

#[derive(Clone)]
pub struct UnannArrayTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for UnannArrayTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for UnannArrayTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unannArrayType(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_unannArrayType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for UnannArrayTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_unannArrayType(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnannArrayTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unannArrayType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unannArrayType }
}
antlr_rust::tid!{UnannArrayTypeContextExt<'a>}

impl<'input> UnannArrayTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnannArrayTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnannArrayTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnannArrayTypeContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<UnannArrayTypeContextExt<'input>>{

fn dims(&self) -> Option<Rc<DimsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn unannPrimitiveType(&self) -> Option<Rc<UnannPrimitiveTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn unannClassOrInterfaceType(&self) -> Option<Rc<UnannClassOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn unannTypeVariable(&self) -> Option<Rc<UnannTypeVariableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UnannArrayTypeContextAttrs<'input> for UnannArrayTypeContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unannArrayType(&mut self,)
	-> Result<Rc<UnannArrayTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnannArrayTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 144, RULE_unannArrayType);
        let mut _localctx: Rc<UnannArrayTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1102);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(92,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule unannPrimitiveType*/
					recog.base.set_state(1099);
					recog.unannPrimitiveType()?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule unannClassOrInterfaceType*/
					recog.base.set_state(1100);
					recog.unannClassOrInterfaceType()?;

					}
				}
			,
				3 =>{
					{
					/*InvokeRule unannTypeVariable*/
					recog.base.set_state(1101);
					recog.unannTypeVariable()?;

					}
				}

				_ => {}
			}
			/*InvokeRule dims*/
			recog.base.set_state(1104);
			recog.dims()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodDeclaration ----------------
pub type MethodDeclarationContextAll<'input> = MethodDeclarationContext<'input>;


pub type MethodDeclarationContext<'input> = BaseParserRuleContext<'input,MethodDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct MethodDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for MethodDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for MethodDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_methodDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for MethodDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_methodDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for MethodDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodDeclaration }
}
antlr_rust::tid!{MethodDeclarationContextExt<'a>}

impl<'input> MethodDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<MethodDeclarationContextExt<'input>>{

fn methodHeader(&self) -> Option<Rc<MethodHeaderContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodBody(&self) -> Option<Rc<MethodBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodModifier_all(&self) ->  Vec<Rc<MethodModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn methodModifier(&self, i: usize) -> Option<Rc<MethodModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> MethodDeclarationContextAttrs<'input> for MethodDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodDeclaration(&mut self,)
	-> Result<Rc<MethodDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 146, RULE_methodDeclaration);
        let mut _localctx: Rc<MethodDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1109);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==ABSTRACT || ((((_la - 35)) & !0x3f) == 0 && ((1usize << (_la - 35)) & ((1usize << (FINAL - 35)) | (1usize << (NATIVE - 35)) | (1usize << (PRIVATE - 35)) | (1usize << (PROTECTED - 35)) | (1usize << (PUBLIC - 35)) | (1usize << (STATIC - 35)) | (1usize << (STRICTFP - 35)) | (1usize << (SYNCHRONIZED - 35)))) != 0) || _la==AT {
				{
				{
				/*InvokeRule methodModifier*/
				recog.base.set_state(1106);
				recog.methodModifier()?;

				}
				}
				recog.base.set_state(1111);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule methodHeader*/
			recog.base.set_state(1112);
			recog.methodHeader()?;

			/*InvokeRule methodBody*/
			recog.base.set_state(1113);
			recog.methodBody()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodModifier ----------------
pub type MethodModifierContextAll<'input> = MethodModifierContext<'input>;


pub type MethodModifierContext<'input> = BaseParserRuleContext<'input,MethodModifierContextExt<'input>>;

#[derive(Clone)]
pub struct MethodModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for MethodModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for MethodModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodModifier(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_methodModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for MethodModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_methodModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for MethodModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodModifier }
}
antlr_rust::tid!{MethodModifierContextExt<'a>}

impl<'input> MethodModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodModifierContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<MethodModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token PUBLIC
/// Returns `None` if there is no child corresponding to token PUBLIC
fn PUBLIC(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(PUBLIC, 0)
}
/// Retrieves first TerminalNode corresponding to token PROTECTED
/// Returns `None` if there is no child corresponding to token PROTECTED
fn PROTECTED(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(PROTECTED, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIVATE
/// Returns `None` if there is no child corresponding to token PRIVATE
fn PRIVATE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(PRIVATE, 0)
}
/// Retrieves first TerminalNode corresponding to token ABSTRACT
/// Returns `None` if there is no child corresponding to token ABSTRACT
fn ABSTRACT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(ABSTRACT, 0)
}
/// Retrieves first TerminalNode corresponding to token STATIC
/// Returns `None` if there is no child corresponding to token STATIC
fn STATIC(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(STATIC, 0)
}
/// Retrieves first TerminalNode corresponding to token FINAL
/// Returns `None` if there is no child corresponding to token FINAL
fn FINAL(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(FINAL, 0)
}
/// Retrieves first TerminalNode corresponding to token SYNCHRONIZED
/// Returns `None` if there is no child corresponding to token SYNCHRONIZED
fn SYNCHRONIZED(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SYNCHRONIZED, 0)
}
/// Retrieves first TerminalNode corresponding to token NATIVE
/// Returns `None` if there is no child corresponding to token NATIVE
fn NATIVE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(NATIVE, 0)
}
/// Retrieves first TerminalNode corresponding to token STRICTFP
/// Returns `None` if there is no child corresponding to token STRICTFP
fn STRICTFP(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(STRICTFP, 0)
}

}

impl<'input> MethodModifierContextAttrs<'input> for MethodModifierContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodModifier(&mut self,)
	-> Result<Rc<MethodModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 148, RULE_methodModifier);
        let mut _localctx: Rc<MethodModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1125);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 AT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(1115);
					recog.annotation()?;

					}
				}

			 PUBLIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1116);
					recog.base.match_token(PUBLIC,&mut recog.err_handler)?;

					}
				}

			 PROTECTED 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(1117);
					recog.base.match_token(PROTECTED,&mut recog.err_handler)?;

					}
				}

			 PRIVATE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(1118);
					recog.base.match_token(PRIVATE,&mut recog.err_handler)?;

					}
				}

			 ABSTRACT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(1119);
					recog.base.match_token(ABSTRACT,&mut recog.err_handler)?;

					}
				}

			 STATIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					recog.base.set_state(1120);
					recog.base.match_token(STATIC,&mut recog.err_handler)?;

					}
				}

			 FINAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					recog.base.set_state(1121);
					recog.base.match_token(FINAL,&mut recog.err_handler)?;

					}
				}

			 SYNCHRONIZED 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					recog.base.set_state(1122);
					recog.base.match_token(SYNCHRONIZED,&mut recog.err_handler)?;

					}
				}

			 NATIVE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					recog.base.set_state(1123);
					recog.base.match_token(NATIVE,&mut recog.err_handler)?;

					}
				}

			 STRICTFP 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					recog.base.set_state(1124);
					recog.base.match_token(STRICTFP,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodHeader ----------------
pub type MethodHeaderContextAll<'input> = MethodHeaderContext<'input>;


pub type MethodHeaderContext<'input> = BaseParserRuleContext<'input,MethodHeaderContextExt<'input>>;

#[derive(Clone)]
pub struct MethodHeaderContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for MethodHeaderContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for MethodHeaderContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodHeader(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_methodHeader(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for MethodHeaderContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_methodHeader(self);
	}
}

impl<'input> CustomRuleContext<'input> for MethodHeaderContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodHeader }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodHeader }
}
antlr_rust::tid!{MethodHeaderContextExt<'a>}

impl<'input> MethodHeaderContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodHeaderContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodHeaderContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodHeaderContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<MethodHeaderContextExt<'input>>{

fn result(&self) -> Option<Rc<ResultContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodDeclarator(&self) -> Option<Rc<MethodDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeParameters(&self) -> Option<Rc<TypeParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn throwsT(&self) -> Option<Rc<ThrowsTContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> MethodHeaderContextAttrs<'input> for MethodHeaderContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodHeader(&mut self,)
	-> Result<Rc<MethodHeaderContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodHeaderContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 150, RULE_methodHeader);
        let mut _localctx: Rc<MethodHeaderContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1134);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LT {
				{
				/*InvokeRule typeParameters*/
				recog.base.set_state(1127);
				recog.typeParameters()?;

				recog.base.set_state(1131);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				while _la==AT {
					{
					{
					/*InvokeRule annotation*/
					recog.base.set_state(1128);
					recog.annotation()?;

					}
					}
					recog.base.set_state(1133);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
				}
				}
			}

			/*InvokeRule result*/
			recog.base.set_state(1136);
			recog.result()?;

			/*InvokeRule methodDeclarator*/
			recog.base.set_state(1137);
			recog.methodDeclarator()?;

			recog.base.set_state(1139);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==THROWS {
				{
				/*InvokeRule throwsT*/
				recog.base.set_state(1138);
				recog.throwsT()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- result ----------------
pub type ResultContextAll<'input> = ResultContext<'input>;


pub type ResultContext<'input> = BaseParserRuleContext<'input,ResultContextExt<'input>>;

#[derive(Clone)]
pub struct ResultContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ResultContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ResultContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_result(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_result(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ResultContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_result(self);
	}
}

impl<'input> CustomRuleContext<'input> for ResultContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_result }
	//fn type_rule_index() -> usize where Self: Sized { RULE_result }
}
antlr_rust::tid!{ResultContextExt<'a>}

impl<'input> ResultContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ResultContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ResultContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ResultContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ResultContextExt<'input>>{

fn unannType(&self) -> Option<Rc<UnannTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token VOID
/// Returns `None` if there is no child corresponding to token VOID
fn VOID(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(VOID, 0)
}

}

impl<'input> ResultContextAttrs<'input> for ResultContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn result(&mut self,)
	-> Result<Rc<ResultContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ResultContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 152, RULE_result);
        let mut _localctx: Rc<ResultContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1143);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 BOOLEAN | BYTE | CHAR | DOUBLE | FLOAT | INT | LONG | SHORT | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule unannType*/
					recog.base.set_state(1141);
					recog.unannType()?;

					}
				}

			 VOID 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1142);
					recog.base.match_token(VOID,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodDeclarator ----------------
pub type MethodDeclaratorContextAll<'input> = MethodDeclaratorContext<'input>;


pub type MethodDeclaratorContext<'input> = BaseParserRuleContext<'input,MethodDeclaratorContextExt<'input>>;

#[derive(Clone)]
pub struct MethodDeclaratorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for MethodDeclaratorContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for MethodDeclaratorContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodDeclarator(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_methodDeclarator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for MethodDeclaratorContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_methodDeclarator(self);
	}
}

impl<'input> CustomRuleContext<'input> for MethodDeclaratorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodDeclarator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodDeclarator }
}
antlr_rust::tid!{MethodDeclaratorContextExt<'a>}

impl<'input> MethodDeclaratorContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodDeclaratorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodDeclaratorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodDeclaratorContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<MethodDeclaratorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn receiverParameter(&self) -> Option<Rc<ReceiverParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn formalParameterList(&self) -> Option<Rc<FormalParameterListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dims(&self) -> Option<Rc<DimsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MethodDeclaratorContextAttrs<'input> for MethodDeclaratorContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodDeclarator(&mut self,)
	-> Result<Rc<MethodDeclaratorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodDeclaratorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 154, RULE_methodDeclarator);
        let mut _localctx: Rc<MethodDeclaratorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1145);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			recog.base.set_state(1146);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1150);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(99,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule receiverParameter*/
					recog.base.set_state(1147);
					recog.receiverParameter()?;

					recog.base.set_state(1148);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1153);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 35)) & !0x3f) == 0 && ((1usize << (_la - 35)) & ((1usize << (FINAL - 35)) | (1usize << (FLOAT - 35)) | (1usize << (INT - 35)) | (1usize << (LONG - 35)) | (1usize << (SHORT - 35)))) != 0) || _la==AT || _la==Identifier {
				{
				/*InvokeRule formalParameterList*/
				recog.base.set_state(1152);
				recog.formalParameterList()?;

				}
			}

			recog.base.set_state(1155);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1157);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LBRACK || _la==AT {
				{
				/*InvokeRule dims*/
				recog.base.set_state(1156);
				recog.dims()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- receiverParameter ----------------
pub type ReceiverParameterContextAll<'input> = ReceiverParameterContext<'input>;


pub type ReceiverParameterContext<'input> = BaseParserRuleContext<'input,ReceiverParameterContextExt<'input>>;

#[derive(Clone)]
pub struct ReceiverParameterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ReceiverParameterContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ReceiverParameterContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_receiverParameter(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_receiverParameter(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ReceiverParameterContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_receiverParameter(self);
	}
}

impl<'input> CustomRuleContext<'input> for ReceiverParameterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_receiverParameter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_receiverParameter }
}
antlr_rust::tid!{ReceiverParameterContextExt<'a>}

impl<'input> ReceiverParameterContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ReceiverParameterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ReceiverParameterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ReceiverParameterContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ReceiverParameterContextExt<'input>>{

fn unannType(&self) -> Option<Rc<UnannTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token THIS
/// Returns `None` if there is no child corresponding to token THIS
fn THIS(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(THIS, 0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> ReceiverParameterContextAttrs<'input> for ReceiverParameterContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn receiverParameter(&mut self,)
	-> Result<Rc<ReceiverParameterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ReceiverParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 156, RULE_receiverParameter);
        let mut _localctx: Rc<ReceiverParameterContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1162);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(1159);
				recog.annotation()?;

				}
				}
				recog.base.set_state(1164);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule unannType*/
			recog.base.set_state(1165);
			recog.unannType()?;

			recog.base.set_state(1168);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Identifier {
				{
				recog.base.set_state(1166);
				recog.base.match_token(Identifier,&mut recog.err_handler)?;

				recog.base.set_state(1167);
				recog.base.match_token(DOT,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(1170);
			recog.base.match_token(THIS,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- formalParameterList ----------------
pub type FormalParameterListContextAll<'input> = FormalParameterListContext<'input>;


pub type FormalParameterListContext<'input> = BaseParserRuleContext<'input,FormalParameterListContextExt<'input>>;

#[derive(Clone)]
pub struct FormalParameterListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for FormalParameterListContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for FormalParameterListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_formalParameterList(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_formalParameterList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for FormalParameterListContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_formalParameterList(self);
	}
}

impl<'input> CustomRuleContext<'input> for FormalParameterListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_formalParameterList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_formalParameterList }
}
antlr_rust::tid!{FormalParameterListContextExt<'a>}

impl<'input> FormalParameterListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FormalParameterListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FormalParameterListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FormalParameterListContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<FormalParameterListContextExt<'input>>{

fn formalParameter_all(&self) ->  Vec<Rc<FormalParameterContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn formalParameter(&self, i: usize) -> Option<Rc<FormalParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> FormalParameterListContextAttrs<'input> for FormalParameterListContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn formalParameterList(&mut self,)
	-> Result<Rc<FormalParameterListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FormalParameterListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 158, RULE_formalParameterList);
        let mut _localctx: Rc<FormalParameterListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule formalParameter*/
			recog.base.set_state(1172);
			recog.formalParameter()?;

			recog.base.set_state(1177);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				recog.base.set_state(1173);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				/*InvokeRule formalParameter*/
				recog.base.set_state(1174);
				recog.formalParameter()?;

				}
				}
				recog.base.set_state(1179);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- formalParameter ----------------
pub type FormalParameterContextAll<'input> = FormalParameterContext<'input>;


pub type FormalParameterContext<'input> = BaseParserRuleContext<'input,FormalParameterContextExt<'input>>;

#[derive(Clone)]
pub struct FormalParameterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for FormalParameterContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for FormalParameterContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_formalParameter(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_formalParameter(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for FormalParameterContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_formalParameter(self);
	}
}

impl<'input> CustomRuleContext<'input> for FormalParameterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_formalParameter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_formalParameter }
}
antlr_rust::tid!{FormalParameterContextExt<'a>}

impl<'input> FormalParameterContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FormalParameterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FormalParameterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FormalParameterContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<FormalParameterContextExt<'input>>{

fn unannType(&self) -> Option<Rc<UnannTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableDeclaratorId(&self) -> Option<Rc<VariableDeclaratorIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableModifier_all(&self) ->  Vec<Rc<VariableModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn variableModifier(&self, i: usize) -> Option<Rc<VariableModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn variableArityParameter(&self) -> Option<Rc<VariableArityParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FormalParameterContextAttrs<'input> for FormalParameterContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn formalParameter(&mut self,)
	-> Result<Rc<FormalParameterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FormalParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 160, RULE_formalParameter);
        let mut _localctx: Rc<FormalParameterContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1190);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(106,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1183);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==FINAL || _la==AT {
						{
						{
						/*InvokeRule variableModifier*/
						recog.base.set_state(1180);
						recog.variableModifier()?;

						}
						}
						recog.base.set_state(1185);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule unannType*/
					recog.base.set_state(1186);
					recog.unannType()?;

					/*InvokeRule variableDeclaratorId*/
					recog.base.set_state(1187);
					recog.variableDeclaratorId()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule variableArityParameter*/
					recog.base.set_state(1189);
					recog.variableArityParameter()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- variableArityParameter ----------------
pub type VariableArityParameterContextAll<'input> = VariableArityParameterContext<'input>;


pub type VariableArityParameterContext<'input> = BaseParserRuleContext<'input,VariableArityParameterContextExt<'input>>;

#[derive(Clone)]
pub struct VariableArityParameterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for VariableArityParameterContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for VariableArityParameterContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_variableArityParameter(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_variableArityParameter(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for VariableArityParameterContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_variableArityParameter(self);
	}
}

impl<'input> CustomRuleContext<'input> for VariableArityParameterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_variableArityParameter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_variableArityParameter }
}
antlr_rust::tid!{VariableArityParameterContextExt<'a>}

impl<'input> VariableArityParameterContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VariableArityParameterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VariableArityParameterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VariableArityParameterContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<VariableArityParameterContextExt<'input>>{

fn unannType(&self) -> Option<Rc<UnannTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ELLIPSIS
/// Returns `None` if there is no child corresponding to token ELLIPSIS
fn ELLIPSIS(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(ELLIPSIS, 0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
fn variableModifier_all(&self) ->  Vec<Rc<VariableModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn variableModifier(&self, i: usize) -> Option<Rc<VariableModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> VariableArityParameterContextAttrs<'input> for VariableArityParameterContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn variableArityParameter(&mut self,)
	-> Result<Rc<VariableArityParameterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VariableArityParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 162, RULE_variableArityParameter);
        let mut _localctx: Rc<VariableArityParameterContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1195);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==FINAL || _la==AT {
				{
				{
				/*InvokeRule variableModifier*/
				recog.base.set_state(1192);
				recog.variableModifier()?;

				}
				}
				recog.base.set_state(1197);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule unannType*/
			recog.base.set_state(1198);
			recog.unannType()?;

			recog.base.set_state(1202);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(1199);
				recog.annotation()?;

				}
				}
				recog.base.set_state(1204);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1205);
			recog.base.match_token(ELLIPSIS,&mut recog.err_handler)?;

			recog.base.set_state(1206);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- variableModifier ----------------
pub type VariableModifierContextAll<'input> = VariableModifierContext<'input>;


pub type VariableModifierContext<'input> = BaseParserRuleContext<'input,VariableModifierContextExt<'input>>;

#[derive(Clone)]
pub struct VariableModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for VariableModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for VariableModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_variableModifier(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_variableModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for VariableModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_variableModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for VariableModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_variableModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_variableModifier }
}
antlr_rust::tid!{VariableModifierContextExt<'a>}

impl<'input> VariableModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VariableModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VariableModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VariableModifierContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<VariableModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token FINAL
/// Returns `None` if there is no child corresponding to token FINAL
fn FINAL(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(FINAL, 0)
}

}

impl<'input> VariableModifierContextAttrs<'input> for VariableModifierContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn variableModifier(&mut self,)
	-> Result<Rc<VariableModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VariableModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 164, RULE_variableModifier);
        let mut _localctx: Rc<VariableModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1210);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 AT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(1208);
					recog.annotation()?;

					}
				}

			 FINAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1209);
					recog.base.match_token(FINAL,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- throwsT ----------------
pub type ThrowsTContextAll<'input> = ThrowsTContext<'input>;


pub type ThrowsTContext<'input> = BaseParserRuleContext<'input,ThrowsTContextExt<'input>>;

#[derive(Clone)]
pub struct ThrowsTContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ThrowsTContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ThrowsTContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_throwsT(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_throwsT(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ThrowsTContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_throwsT(self);
	}
}

impl<'input> CustomRuleContext<'input> for ThrowsTContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_throwsT }
	//fn type_rule_index() -> usize where Self: Sized { RULE_throwsT }
}
antlr_rust::tid!{ThrowsTContextExt<'a>}

impl<'input> ThrowsTContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ThrowsTContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ThrowsTContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ThrowsTContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ThrowsTContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token THROWS
/// Returns `None` if there is no child corresponding to token THROWS
fn THROWS(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(THROWS, 0)
}
fn exceptionTypeList(&self) -> Option<Rc<ExceptionTypeListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ThrowsTContextAttrs<'input> for ThrowsTContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn throwsT(&mut self,)
	-> Result<Rc<ThrowsTContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ThrowsTContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 166, RULE_throwsT);
        let mut _localctx: Rc<ThrowsTContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1212);
			recog.base.match_token(THROWS,&mut recog.err_handler)?;

			/*InvokeRule exceptionTypeList*/
			recog.base.set_state(1213);
			recog.exceptionTypeList()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- exceptionTypeList ----------------
pub type ExceptionTypeListContextAll<'input> = ExceptionTypeListContext<'input>;


pub type ExceptionTypeListContext<'input> = BaseParserRuleContext<'input,ExceptionTypeListContextExt<'input>>;

#[derive(Clone)]
pub struct ExceptionTypeListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ExceptionTypeListContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ExceptionTypeListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_exceptionTypeList(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_exceptionTypeList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ExceptionTypeListContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_exceptionTypeList(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExceptionTypeListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_exceptionTypeList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_exceptionTypeList }
}
antlr_rust::tid!{ExceptionTypeListContextExt<'a>}

impl<'input> ExceptionTypeListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExceptionTypeListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExceptionTypeListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExceptionTypeListContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ExceptionTypeListContextExt<'input>>{

fn exceptionType_all(&self) ->  Vec<Rc<ExceptionTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn exceptionType(&self, i: usize) -> Option<Rc<ExceptionTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> ExceptionTypeListContextAttrs<'input> for ExceptionTypeListContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn exceptionTypeList(&mut self,)
	-> Result<Rc<ExceptionTypeListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExceptionTypeListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 168, RULE_exceptionTypeList);
        let mut _localctx: Rc<ExceptionTypeListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule exceptionType*/
			recog.base.set_state(1215);
			recog.exceptionType()?;

			recog.base.set_state(1220);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				recog.base.set_state(1216);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				/*InvokeRule exceptionType*/
				recog.base.set_state(1217);
				recog.exceptionType()?;

				}
				}
				recog.base.set_state(1222);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- exceptionType ----------------
pub type ExceptionTypeContextAll<'input> = ExceptionTypeContext<'input>;


pub type ExceptionTypeContext<'input> = BaseParserRuleContext<'input,ExceptionTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ExceptionTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ExceptionTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ExceptionTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_exceptionType(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_exceptionType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ExceptionTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_exceptionType(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExceptionTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_exceptionType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_exceptionType }
}
antlr_rust::tid!{ExceptionTypeContextExt<'a>}

impl<'input> ExceptionTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExceptionTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExceptionTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExceptionTypeContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ExceptionTypeContextExt<'input>>{

fn classType(&self) -> Option<Rc<ClassTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeVariable(&self) -> Option<Rc<TypeVariableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ExceptionTypeContextAttrs<'input> for ExceptionTypeContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn exceptionType(&mut self,)
	-> Result<Rc<ExceptionTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExceptionTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 170, RULE_exceptionType);
        let mut _localctx: Rc<ExceptionTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1225);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(111,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule classType*/
					recog.base.set_state(1223);
					recog.classType()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule typeVariable*/
					recog.base.set_state(1224);
					recog.typeVariable()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodBody ----------------
pub type MethodBodyContextAll<'input> = MethodBodyContext<'input>;


pub type MethodBodyContext<'input> = BaseParserRuleContext<'input,MethodBodyContextExt<'input>>;

#[derive(Clone)]
pub struct MethodBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for MethodBodyContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for MethodBodyContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodBody(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_methodBody(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for MethodBodyContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_methodBody(self);
	}
}

impl<'input> CustomRuleContext<'input> for MethodBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodBody }
}
antlr_rust::tid!{MethodBodyContextExt<'a>}

impl<'input> MethodBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodBodyContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<MethodBodyContextExt<'input>>{

fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> MethodBodyContextAttrs<'input> for MethodBodyContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodBody(&mut self,)
	-> Result<Rc<MethodBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 172, RULE_methodBody);
        let mut _localctx: Rc<MethodBodyContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1229);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LBRACE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule block*/
					recog.base.set_state(1227);
					recog.block()?;

					}
				}

			 SEMI 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1228);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- instanceInitializer ----------------
pub type InstanceInitializerContextAll<'input> = InstanceInitializerContext<'input>;


pub type InstanceInitializerContext<'input> = BaseParserRuleContext<'input,InstanceInitializerContextExt<'input>>;

#[derive(Clone)]
pub struct InstanceInitializerContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for InstanceInitializerContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for InstanceInitializerContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_instanceInitializer(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_instanceInitializer(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for InstanceInitializerContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_instanceInitializer(self);
	}
}

impl<'input> CustomRuleContext<'input> for InstanceInitializerContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_instanceInitializer }
	//fn type_rule_index() -> usize where Self: Sized { RULE_instanceInitializer }
}
antlr_rust::tid!{InstanceInitializerContextExt<'a>}

impl<'input> InstanceInitializerContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InstanceInitializerContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InstanceInitializerContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InstanceInitializerContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<InstanceInitializerContextExt<'input>>{

fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InstanceInitializerContextAttrs<'input> for InstanceInitializerContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn instanceInitializer(&mut self,)
	-> Result<Rc<InstanceInitializerContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InstanceInitializerContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 174, RULE_instanceInitializer);
        let mut _localctx: Rc<InstanceInitializerContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule block*/
			recog.base.set_state(1231);
			recog.block()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- staticInitializer ----------------
pub type StaticInitializerContextAll<'input> = StaticInitializerContext<'input>;


pub type StaticInitializerContext<'input> = BaseParserRuleContext<'input,StaticInitializerContextExt<'input>>;

#[derive(Clone)]
pub struct StaticInitializerContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for StaticInitializerContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for StaticInitializerContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_staticInitializer(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_staticInitializer(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for StaticInitializerContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_staticInitializer(self);
	}
}

impl<'input> CustomRuleContext<'input> for StaticInitializerContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_staticInitializer }
	//fn type_rule_index() -> usize where Self: Sized { RULE_staticInitializer }
}
antlr_rust::tid!{StaticInitializerContextExt<'a>}

impl<'input> StaticInitializerContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StaticInitializerContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StaticInitializerContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StaticInitializerContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<StaticInitializerContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token STATIC
/// Returns `None` if there is no child corresponding to token STATIC
fn STATIC(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(STATIC, 0)
}
fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> StaticInitializerContextAttrs<'input> for StaticInitializerContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn staticInitializer(&mut self,)
	-> Result<Rc<StaticInitializerContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StaticInitializerContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 176, RULE_staticInitializer);
        let mut _localctx: Rc<StaticInitializerContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1233);
			recog.base.match_token(STATIC,&mut recog.err_handler)?;

			/*InvokeRule block*/
			recog.base.set_state(1234);
			recog.block()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constructorDeclaration ----------------
pub type ConstructorDeclarationContextAll<'input> = ConstructorDeclarationContext<'input>;


pub type ConstructorDeclarationContext<'input> = BaseParserRuleContext<'input,ConstructorDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct ConstructorDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ConstructorDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ConstructorDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constructorDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_constructorDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ConstructorDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_constructorDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for ConstructorDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constructorDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constructorDeclaration }
}
antlr_rust::tid!{ConstructorDeclarationContextExt<'a>}

impl<'input> ConstructorDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstructorDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstructorDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstructorDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ConstructorDeclarationContextExt<'input>>{

fn constructorDeclarator(&self) -> Option<Rc<ConstructorDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constructorBody(&self) -> Option<Rc<ConstructorBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constructorModifier_all(&self) ->  Vec<Rc<ConstructorModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn constructorModifier(&self, i: usize) -> Option<Rc<ConstructorModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn throwsT(&self) -> Option<Rc<ThrowsTContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConstructorDeclarationContextAttrs<'input> for ConstructorDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constructorDeclaration(&mut self,)
	-> Result<Rc<ConstructorDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstructorDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 178, RULE_constructorDeclaration);
        let mut _localctx: Rc<ConstructorDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1239);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while ((((_la - 50)) & !0x3f) == 0 && ((1usize << (_la - 50)) & ((1usize << (PRIVATE - 50)) | (1usize << (PROTECTED - 50)) | (1usize << (PUBLIC - 50)))) != 0) || _la==AT {
				{
				{
				/*InvokeRule constructorModifier*/
				recog.base.set_state(1236);
				recog.constructorModifier()?;

				}
				}
				recog.base.set_state(1241);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule constructorDeclarator*/
			recog.base.set_state(1242);
			recog.constructorDeclarator()?;

			recog.base.set_state(1244);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==THROWS {
				{
				/*InvokeRule throwsT*/
				recog.base.set_state(1243);
				recog.throwsT()?;

				}
			}

			/*InvokeRule constructorBody*/
			recog.base.set_state(1246);
			recog.constructorBody()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constructorModifier ----------------
pub type ConstructorModifierContextAll<'input> = ConstructorModifierContext<'input>;


pub type ConstructorModifierContext<'input> = BaseParserRuleContext<'input,ConstructorModifierContextExt<'input>>;

#[derive(Clone)]
pub struct ConstructorModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ConstructorModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ConstructorModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constructorModifier(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_constructorModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ConstructorModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_constructorModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for ConstructorModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constructorModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constructorModifier }
}
antlr_rust::tid!{ConstructorModifierContextExt<'a>}

impl<'input> ConstructorModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstructorModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstructorModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstructorModifierContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ConstructorModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token PUBLIC
/// Returns `None` if there is no child corresponding to token PUBLIC
fn PUBLIC(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(PUBLIC, 0)
}
/// Retrieves first TerminalNode corresponding to token PROTECTED
/// Returns `None` if there is no child corresponding to token PROTECTED
fn PROTECTED(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(PROTECTED, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIVATE
/// Returns `None` if there is no child corresponding to token PRIVATE
fn PRIVATE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(PRIVATE, 0)
}

}

impl<'input> ConstructorModifierContextAttrs<'input> for ConstructorModifierContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constructorModifier(&mut self,)
	-> Result<Rc<ConstructorModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstructorModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 180, RULE_constructorModifier);
        let mut _localctx: Rc<ConstructorModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1252);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 AT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(1248);
					recog.annotation()?;

					}
				}

			 PUBLIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1249);
					recog.base.match_token(PUBLIC,&mut recog.err_handler)?;

					}
				}

			 PROTECTED 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(1250);
					recog.base.match_token(PROTECTED,&mut recog.err_handler)?;

					}
				}

			 PRIVATE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(1251);
					recog.base.match_token(PRIVATE,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constructorDeclarator ----------------
pub type ConstructorDeclaratorContextAll<'input> = ConstructorDeclaratorContext<'input>;


pub type ConstructorDeclaratorContext<'input> = BaseParserRuleContext<'input,ConstructorDeclaratorContextExt<'input>>;

#[derive(Clone)]
pub struct ConstructorDeclaratorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ConstructorDeclaratorContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ConstructorDeclaratorContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constructorDeclarator(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_constructorDeclarator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ConstructorDeclaratorContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_constructorDeclarator(self);
	}
}

impl<'input> CustomRuleContext<'input> for ConstructorDeclaratorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constructorDeclarator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constructorDeclarator }
}
antlr_rust::tid!{ConstructorDeclaratorContextExt<'a>}

impl<'input> ConstructorDeclaratorContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstructorDeclaratorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstructorDeclaratorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstructorDeclaratorContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ConstructorDeclaratorContextExt<'input>>{

fn simpleTypeName(&self) -> Option<Rc<SimpleTypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn typeParameters(&self) -> Option<Rc<TypeParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn receiverParameter(&self) -> Option<Rc<ReceiverParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn formalParameterList(&self) -> Option<Rc<FormalParameterListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConstructorDeclaratorContextAttrs<'input> for ConstructorDeclaratorContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constructorDeclarator(&mut self,)
	-> Result<Rc<ConstructorDeclaratorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstructorDeclaratorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 182, RULE_constructorDeclarator);
        let mut _localctx: Rc<ConstructorDeclaratorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1255);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LT {
				{
				/*InvokeRule typeParameters*/
				recog.base.set_state(1254);
				recog.typeParameters()?;

				}
			}

			/*InvokeRule simpleTypeName*/
			recog.base.set_state(1257);
			recog.simpleTypeName()?;

			recog.base.set_state(1258);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1262);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(117,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule receiverParameter*/
					recog.base.set_state(1259);
					recog.receiverParameter()?;

					recog.base.set_state(1260);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1265);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 35)) & !0x3f) == 0 && ((1usize << (_la - 35)) & ((1usize << (FINAL - 35)) | (1usize << (FLOAT - 35)) | (1usize << (INT - 35)) | (1usize << (LONG - 35)) | (1usize << (SHORT - 35)))) != 0) || _la==AT || _la==Identifier {
				{
				/*InvokeRule formalParameterList*/
				recog.base.set_state(1264);
				recog.formalParameterList()?;

				}
			}

			recog.base.set_state(1267);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- simpleTypeName ----------------
pub type SimpleTypeNameContextAll<'input> = SimpleTypeNameContext<'input>;


pub type SimpleTypeNameContext<'input> = BaseParserRuleContext<'input,SimpleTypeNameContextExt<'input>>;

#[derive(Clone)]
pub struct SimpleTypeNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for SimpleTypeNameContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for SimpleTypeNameContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_simpleTypeName(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_simpleTypeName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for SimpleTypeNameContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_simpleTypeName(self);
	}
}

impl<'input> CustomRuleContext<'input> for SimpleTypeNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_simpleTypeName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_simpleTypeName }
}
antlr_rust::tid!{SimpleTypeNameContextExt<'a>}

impl<'input> SimpleTypeNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SimpleTypeNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SimpleTypeNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SimpleTypeNameContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<SimpleTypeNameContextExt<'input>>{

fn typeIdentifier(&self) -> Option<Rc<TypeIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SimpleTypeNameContextAttrs<'input> for SimpleTypeNameContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn simpleTypeName(&mut self,)
	-> Result<Rc<SimpleTypeNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SimpleTypeNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 184, RULE_simpleTypeName);
        let mut _localctx: Rc<SimpleTypeNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule typeIdentifier*/
			recog.base.set_state(1269);
			recog.typeIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constructorBody ----------------
pub type ConstructorBodyContextAll<'input> = ConstructorBodyContext<'input>;


pub type ConstructorBodyContext<'input> = BaseParserRuleContext<'input,ConstructorBodyContextExt<'input>>;

#[derive(Clone)]
pub struct ConstructorBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ConstructorBodyContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ConstructorBodyContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constructorBody(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_constructorBody(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ConstructorBodyContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_constructorBody(self);
	}
}

impl<'input> CustomRuleContext<'input> for ConstructorBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constructorBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constructorBody }
}
antlr_rust::tid!{ConstructorBodyContextExt<'a>}

impl<'input> ConstructorBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstructorBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstructorBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstructorBodyContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ConstructorBodyContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}
fn explicitConstructorInvocation(&self) -> Option<Rc<ExplicitConstructorInvocationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn blockStatements(&self) -> Option<Rc<BlockStatementsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConstructorBodyContextAttrs<'input> for ConstructorBodyContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constructorBody(&mut self,)
	-> Result<Rc<ConstructorBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstructorBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 186, RULE_constructorBody);
        let mut _localctx: Rc<ConstructorBodyContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1271);
			recog.base.match_token(LBRACE,&mut recog.err_handler)?;

			recog.base.set_state(1273);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(119,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule explicitConstructorInvocation*/
					recog.base.set_state(1272);
					recog.explicitConstructorInvocation()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1276);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << NONSEALED) | (1usize << RECORD) | (1usize << SEALED) | (1usize << VAR) | (1usize << YIELD) | (1usize << ABSTRACT) | (1usize << ASSERT) | (1usize << BOOLEAN) | (1usize << BREAK) | (1usize << BYTE) | (1usize << CHAR) | (1usize << CLASS) | (1usize << CONTINUE) | (1usize << DO) | (1usize << DOUBLE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (ENUM - 33)) | (1usize << (FINAL - 33)) | (1usize << (FLOAT - 33)) | (1usize << (FOR - 33)) | (1usize << (IF - 33)) | (1usize << (INT - 33)) | (1usize << (INTERFACE - 33)) | (1usize << (LONG - 33)) | (1usize << (NEW - 33)) | (1usize << (PRIVATE - 33)) | (1usize << (PROTECTED - 33)) | (1usize << (PUBLIC - 33)) | (1usize << (RETURN - 33)) | (1usize << (SHORT - 33)) | (1usize << (STATIC - 33)) | (1usize << (STRICTFP - 33)) | (1usize << (SUPER - 33)) | (1usize << (SWITCH - 33)) | (1usize << (SYNCHRONIZED - 33)) | (1usize << (THIS - 33)) | (1usize << (THROW - 33)) | (1usize << (TRY - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (VOID - 65)) | (1usize << (WHILE - 65)) | (1usize << (IntegerLiteral - 65)) | (1usize << (FloatingPointLiteral - 65)) | (1usize << (BooleanLiteral - 65)) | (1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (TextBlock - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (LBRACE - 65)) | (1usize << (SEMI - 65)) | (1usize << (AT - 65)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (Identifier - 102)))) != 0) {
				{
				/*InvokeRule blockStatements*/
				recog.base.set_state(1275);
				recog.blockStatements()?;

				}
			}

			recog.base.set_state(1278);
			recog.base.match_token(RBRACE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- explicitConstructorInvocation ----------------
pub type ExplicitConstructorInvocationContextAll<'input> = ExplicitConstructorInvocationContext<'input>;


pub type ExplicitConstructorInvocationContext<'input> = BaseParserRuleContext<'input,ExplicitConstructorInvocationContextExt<'input>>;

#[derive(Clone)]
pub struct ExplicitConstructorInvocationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ExplicitConstructorInvocationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ExplicitConstructorInvocationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_explicitConstructorInvocation(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_explicitConstructorInvocation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ExplicitConstructorInvocationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_explicitConstructorInvocation(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExplicitConstructorInvocationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_explicitConstructorInvocation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_explicitConstructorInvocation }
}
antlr_rust::tid!{ExplicitConstructorInvocationContextExt<'a>}

impl<'input> ExplicitConstructorInvocationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExplicitConstructorInvocationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExplicitConstructorInvocationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExplicitConstructorInvocationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ExplicitConstructorInvocationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}
/// Retrieves first TerminalNode corresponding to token THIS
/// Returns `None` if there is no child corresponding to token THIS
fn THIS(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(THIS, 0)
}
/// Retrieves first TerminalNode corresponding to token SUPER
/// Returns `None` if there is no child corresponding to token SUPER
fn SUPER(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SUPER, 0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn argumentList(&self) -> Option<Rc<ArgumentListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn expressionName(&self) -> Option<Rc<ExpressionNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn primary(&self) -> Option<Rc<PrimaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ExplicitConstructorInvocationContextAttrs<'input> for ExplicitConstructorInvocationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn explicitConstructorInvocation(&mut self,)
	-> Result<Rc<ExplicitConstructorInvocationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExplicitConstructorInvocationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 188, RULE_explicitConstructorInvocation);
        let mut _localctx: Rc<ExplicitConstructorInvocationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1306);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(126,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1281);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(1280);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(1283);
					_la = recog.base.input.la(1);
					if { !(_la==SUPER || _la==THIS) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					recog.base.set_state(1284);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1286);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (FLOAT - 37)) | (1usize << (INT - 37)) | (1usize << (LONG - 37)) | (1usize << (NEW - 37)) | (1usize << (SHORT - 37)) | (1usize << (SUPER - 37)) | (1usize << (SWITCH - 37)) | (1usize << (THIS - 37)) | (1usize << (VOID - 37)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (AT - 69)) | (1usize << (BANG - 69)) | (1usize << (TILDE - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (ADD - 102)) | (1usize << (SUB - 102)) | (1usize << (Identifier - 102)))) != 0) {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(1285);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(1288);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1289);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1292);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(123,&mut recog.base)? {
						1 =>{
							{
							/*InvokeRule expressionName*/
							recog.base.set_state(1290);
							recog.expressionName()?;

							}
						}
					,
						2 =>{
							{
							/*InvokeRule primary*/
							recog.base.set_state(1291);
							recog.primary()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1294);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(1296);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(1295);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(1298);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(1299);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1301);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (FLOAT - 37)) | (1usize << (INT - 37)) | (1usize << (LONG - 37)) | (1usize << (NEW - 37)) | (1usize << (SHORT - 37)) | (1usize << (SUPER - 37)) | (1usize << (SWITCH - 37)) | (1usize << (THIS - 37)) | (1usize << (VOID - 37)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (AT - 69)) | (1usize << (BANG - 69)) | (1usize << (TILDE - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (ADD - 102)) | (1usize << (SUB - 102)) | (1usize << (Identifier - 102)))) != 0) {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(1300);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(1303);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1304);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumDeclaration ----------------
pub type EnumDeclarationContextAll<'input> = EnumDeclarationContext<'input>;


pub type EnumDeclarationContext<'input> = BaseParserRuleContext<'input,EnumDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct EnumDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for EnumDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for EnumDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enumDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_enumDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for EnumDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_enumDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for EnumDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumDeclaration }
}
antlr_rust::tid!{EnumDeclarationContextExt<'a>}

impl<'input> EnumDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<EnumDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ENUM
/// Returns `None` if there is no child corresponding to token ENUM
fn ENUM(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(ENUM, 0)
}
fn typeIdentifier(&self) -> Option<Rc<TypeIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn enumBody(&self) -> Option<Rc<EnumBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classModifier_all(&self) ->  Vec<Rc<ClassModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn classModifier(&self, i: usize) -> Option<Rc<ClassModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn classImplements(&self) -> Option<Rc<ClassImplementsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> EnumDeclarationContextAttrs<'input> for EnumDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumDeclaration(&mut self,)
	-> Result<Rc<EnumDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 190, RULE_enumDeclaration);
        let mut _localctx: Rc<EnumDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1311);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << NONSEALED) | (1usize << SEALED) | (1usize << ABSTRACT))) != 0) || ((((_la - 35)) & !0x3f) == 0 && ((1usize << (_la - 35)) & ((1usize << (FINAL - 35)) | (1usize << (PRIVATE - 35)) | (1usize << (PROTECTED - 35)) | (1usize << (PUBLIC - 35)) | (1usize << (STATIC - 35)) | (1usize << (STRICTFP - 35)))) != 0) || _la==AT {
				{
				{
				/*InvokeRule classModifier*/
				recog.base.set_state(1308);
				recog.classModifier()?;

				}
				}
				recog.base.set_state(1313);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1314);
			recog.base.match_token(ENUM,&mut recog.err_handler)?;

			/*InvokeRule typeIdentifier*/
			recog.base.set_state(1315);
			recog.typeIdentifier()?;

			recog.base.set_state(1317);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==IMPLEMENTS {
				{
				/*InvokeRule classImplements*/
				recog.base.set_state(1316);
				recog.classImplements()?;

				}
			}

			/*InvokeRule enumBody*/
			recog.base.set_state(1319);
			recog.enumBody()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumBody ----------------
pub type EnumBodyContextAll<'input> = EnumBodyContext<'input>;


pub type EnumBodyContext<'input> = BaseParserRuleContext<'input,EnumBodyContextExt<'input>>;

#[derive(Clone)]
pub struct EnumBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for EnumBodyContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for EnumBodyContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enumBody(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_enumBody(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for EnumBodyContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_enumBody(self);
	}
}

impl<'input> CustomRuleContext<'input> for EnumBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumBody }
}
antlr_rust::tid!{EnumBodyContextExt<'a>}

impl<'input> EnumBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumBodyContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<EnumBodyContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}
fn enumConstantList(&self) -> Option<Rc<EnumConstantListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn enumBodyDeclarations(&self) -> Option<Rc<EnumBodyDeclarationsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> EnumBodyContextAttrs<'input> for EnumBodyContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumBody(&mut self,)
	-> Result<Rc<EnumBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 192, RULE_enumBody);
        let mut _localctx: Rc<EnumBodyContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1321);
			recog.base.match_token(LBRACE,&mut recog.err_handler)?;

			recog.base.set_state(1323);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AT || _la==Identifier {
				{
				/*InvokeRule enumConstantList*/
				recog.base.set_state(1322);
				recog.enumConstantList()?;

				}
			}

			recog.base.set_state(1326);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COMMA {
				{
				recog.base.set_state(1325);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(1329);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==SEMI {
				{
				/*InvokeRule enumBodyDeclarations*/
				recog.base.set_state(1328);
				recog.enumBodyDeclarations()?;

				}
			}

			recog.base.set_state(1331);
			recog.base.match_token(RBRACE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumConstantList ----------------
pub type EnumConstantListContextAll<'input> = EnumConstantListContext<'input>;


pub type EnumConstantListContext<'input> = BaseParserRuleContext<'input,EnumConstantListContextExt<'input>>;

#[derive(Clone)]
pub struct EnumConstantListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for EnumConstantListContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for EnumConstantListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enumConstantList(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_enumConstantList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for EnumConstantListContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_enumConstantList(self);
	}
}

impl<'input> CustomRuleContext<'input> for EnumConstantListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumConstantList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumConstantList }
}
antlr_rust::tid!{EnumConstantListContextExt<'a>}

impl<'input> EnumConstantListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumConstantListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumConstantListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumConstantListContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<EnumConstantListContextExt<'input>>{

fn enumConstant_all(&self) ->  Vec<Rc<EnumConstantContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn enumConstant(&self, i: usize) -> Option<Rc<EnumConstantContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> EnumConstantListContextAttrs<'input> for EnumConstantListContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumConstantList(&mut self,)
	-> Result<Rc<EnumConstantListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumConstantListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 194, RULE_enumConstantList);
        let mut _localctx: Rc<EnumConstantListContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule enumConstant*/
			recog.base.set_state(1333);
			recog.enumConstant()?;

			recog.base.set_state(1338);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(132,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1334);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule enumConstant*/
					recog.base.set_state(1335);
					recog.enumConstant()?;

					}
					} 
				}
				recog.base.set_state(1340);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(132,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumConstant ----------------
pub type EnumConstantContextAll<'input> = EnumConstantContext<'input>;


pub type EnumConstantContext<'input> = BaseParserRuleContext<'input,EnumConstantContextExt<'input>>;

#[derive(Clone)]
pub struct EnumConstantContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for EnumConstantContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for EnumConstantContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enumConstant(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_enumConstant(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for EnumConstantContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_enumConstant(self);
	}
}

impl<'input> CustomRuleContext<'input> for EnumConstantContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumConstant }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumConstant }
}
antlr_rust::tid!{EnumConstantContextExt<'a>}

impl<'input> EnumConstantContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumConstantContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumConstantContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumConstantContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<EnumConstantContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
fn enumConstantModifier_all(&self) ->  Vec<Rc<EnumConstantModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn enumConstantModifier(&self, i: usize) -> Option<Rc<EnumConstantModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn classBody(&self) -> Option<Rc<ClassBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn argumentList(&self) -> Option<Rc<ArgumentListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> EnumConstantContextAttrs<'input> for EnumConstantContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumConstant(&mut self,)
	-> Result<Rc<EnumConstantContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumConstantContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 196, RULE_enumConstant);
        let mut _localctx: Rc<EnumConstantContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1344);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule enumConstantModifier*/
				recog.base.set_state(1341);
				recog.enumConstantModifier()?;

				}
				}
				recog.base.set_state(1346);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1347);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			recog.base.set_state(1353);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LPAREN {
				{
				recog.base.set_state(1348);
				recog.base.match_token(LPAREN,&mut recog.err_handler)?;

				recog.base.set_state(1350);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (FLOAT - 37)) | (1usize << (INT - 37)) | (1usize << (LONG - 37)) | (1usize << (NEW - 37)) | (1usize << (SHORT - 37)) | (1usize << (SUPER - 37)) | (1usize << (SWITCH - 37)) | (1usize << (THIS - 37)) | (1usize << (VOID - 37)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (AT - 69)) | (1usize << (BANG - 69)) | (1usize << (TILDE - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (ADD - 102)) | (1usize << (SUB - 102)) | (1usize << (Identifier - 102)))) != 0) {
					{
					/*InvokeRule argumentList*/
					recog.base.set_state(1349);
					recog.argumentList()?;

					}
				}

				recog.base.set_state(1352);
				recog.base.match_token(RPAREN,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(1356);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LBRACE {
				{
				/*InvokeRule classBody*/
				recog.base.set_state(1355);
				recog.classBody()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumConstantModifier ----------------
pub type EnumConstantModifierContextAll<'input> = EnumConstantModifierContext<'input>;


pub type EnumConstantModifierContext<'input> = BaseParserRuleContext<'input,EnumConstantModifierContextExt<'input>>;

#[derive(Clone)]
pub struct EnumConstantModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for EnumConstantModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for EnumConstantModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enumConstantModifier(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_enumConstantModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for EnumConstantModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_enumConstantModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for EnumConstantModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumConstantModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumConstantModifier }
}
antlr_rust::tid!{EnumConstantModifierContextExt<'a>}

impl<'input> EnumConstantModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumConstantModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumConstantModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumConstantModifierContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<EnumConstantModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> EnumConstantModifierContextAttrs<'input> for EnumConstantModifierContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumConstantModifier(&mut self,)
	-> Result<Rc<EnumConstantModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumConstantModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 198, RULE_enumConstantModifier);
        let mut _localctx: Rc<EnumConstantModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule annotation*/
			recog.base.set_state(1358);
			recog.annotation()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumBodyDeclarations ----------------
pub type EnumBodyDeclarationsContextAll<'input> = EnumBodyDeclarationsContext<'input>;


pub type EnumBodyDeclarationsContext<'input> = BaseParserRuleContext<'input,EnumBodyDeclarationsContextExt<'input>>;

#[derive(Clone)]
pub struct EnumBodyDeclarationsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for EnumBodyDeclarationsContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for EnumBodyDeclarationsContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enumBodyDeclarations(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_enumBodyDeclarations(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for EnumBodyDeclarationsContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_enumBodyDeclarations(self);
	}
}

impl<'input> CustomRuleContext<'input> for EnumBodyDeclarationsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumBodyDeclarations }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumBodyDeclarations }
}
antlr_rust::tid!{EnumBodyDeclarationsContextExt<'a>}

impl<'input> EnumBodyDeclarationsContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumBodyDeclarationsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumBodyDeclarationsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumBodyDeclarationsContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<EnumBodyDeclarationsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}
fn classBodyDeclaration_all(&self) ->  Vec<Rc<ClassBodyDeclarationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn classBodyDeclaration(&self, i: usize) -> Option<Rc<ClassBodyDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> EnumBodyDeclarationsContextAttrs<'input> for EnumBodyDeclarationsContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumBodyDeclarations(&mut self,)
	-> Result<Rc<EnumBodyDeclarationsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumBodyDeclarationsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 200, RULE_enumBodyDeclarations);
        let mut _localctx: Rc<EnumBodyDeclarationsContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1360);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			recog.base.set_state(1364);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << NONSEALED) | (1usize << RECORD) | (1usize << SEALED) | (1usize << ABSTRACT) | (1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << CLASS) | (1usize << DOUBLE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (ENUM - 33)) | (1usize << (FINAL - 33)) | (1usize << (FLOAT - 33)) | (1usize << (INT - 33)) | (1usize << (INTERFACE - 33)) | (1usize << (LONG - 33)) | (1usize << (NATIVE - 33)) | (1usize << (PRIVATE - 33)) | (1usize << (PROTECTED - 33)) | (1usize << (PUBLIC - 33)) | (1usize << (SHORT - 33)) | (1usize << (STATIC - 33)) | (1usize << (STRICTFP - 33)) | (1usize << (SYNCHRONIZED - 33)) | (1usize << (TRANSIENT - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (VOID - 65)) | (1usize << (VOLATILE - 65)) | (1usize << (LBRACE - 65)) | (1usize << (SEMI - 65)) | (1usize << (AT - 65)) | (1usize << (LT - 65)))) != 0) || _la==Identifier {
				{
				{
				/*InvokeRule classBodyDeclaration*/
				recog.base.set_state(1361);
				recog.classBodyDeclaration()?;

				}
				}
				recog.base.set_state(1366);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- recordDeclaration ----------------
pub type RecordDeclarationContextAll<'input> = RecordDeclarationContext<'input>;


pub type RecordDeclarationContext<'input> = BaseParserRuleContext<'input,RecordDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct RecordDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for RecordDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for RecordDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_recordDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_recordDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for RecordDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_recordDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for RecordDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_recordDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_recordDeclaration }
}
antlr_rust::tid!{RecordDeclarationContextExt<'a>}

impl<'input> RecordDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RecordDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RecordDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RecordDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<RecordDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token RECORD
/// Returns `None` if there is no child corresponding to token RECORD
fn RECORD(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RECORD, 0)
}
fn typeIdentifier(&self) -> Option<Rc<TypeIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn recordHeader(&self) -> Option<Rc<RecordHeaderContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn recordBody(&self) -> Option<Rc<RecordBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classModifier_all(&self) ->  Vec<Rc<ClassModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn classModifier(&self, i: usize) -> Option<Rc<ClassModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn typeParameters(&self) -> Option<Rc<TypeParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classImplements(&self) -> Option<Rc<ClassImplementsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RecordDeclarationContextAttrs<'input> for RecordDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn recordDeclaration(&mut self,)
	-> Result<Rc<RecordDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RecordDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 202, RULE_recordDeclaration);
        let mut _localctx: Rc<RecordDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1370);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << NONSEALED) | (1usize << SEALED) | (1usize << ABSTRACT))) != 0) || ((((_la - 35)) & !0x3f) == 0 && ((1usize << (_la - 35)) & ((1usize << (FINAL - 35)) | (1usize << (PRIVATE - 35)) | (1usize << (PROTECTED - 35)) | (1usize << (PUBLIC - 35)) | (1usize << (STATIC - 35)) | (1usize << (STRICTFP - 35)))) != 0) || _la==AT {
				{
				{
				/*InvokeRule classModifier*/
				recog.base.set_state(1367);
				recog.classModifier()?;

				}
				}
				recog.base.set_state(1372);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1373);
			recog.base.match_token(RECORD,&mut recog.err_handler)?;

			/*InvokeRule typeIdentifier*/
			recog.base.set_state(1374);
			recog.typeIdentifier()?;

			recog.base.set_state(1376);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LT {
				{
				/*InvokeRule typeParameters*/
				recog.base.set_state(1375);
				recog.typeParameters()?;

				}
			}

			/*InvokeRule recordHeader*/
			recog.base.set_state(1378);
			recog.recordHeader()?;

			recog.base.set_state(1380);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==IMPLEMENTS {
				{
				/*InvokeRule classImplements*/
				recog.base.set_state(1379);
				recog.classImplements()?;

				}
			}

			/*InvokeRule recordBody*/
			recog.base.set_state(1382);
			recog.recordBody()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- recordHeader ----------------
pub type RecordHeaderContextAll<'input> = RecordHeaderContext<'input>;


pub type RecordHeaderContext<'input> = BaseParserRuleContext<'input,RecordHeaderContextExt<'input>>;

#[derive(Clone)]
pub struct RecordHeaderContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for RecordHeaderContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for RecordHeaderContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_recordHeader(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_recordHeader(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for RecordHeaderContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_recordHeader(self);
	}
}

impl<'input> CustomRuleContext<'input> for RecordHeaderContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_recordHeader }
	//fn type_rule_index() -> usize where Self: Sized { RULE_recordHeader }
}
antlr_rust::tid!{RecordHeaderContextExt<'a>}

impl<'input> RecordHeaderContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RecordHeaderContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RecordHeaderContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RecordHeaderContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<RecordHeaderContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn recordComponentList(&self) -> Option<Rc<RecordComponentListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RecordHeaderContextAttrs<'input> for RecordHeaderContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn recordHeader(&mut self,)
	-> Result<Rc<RecordHeaderContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RecordHeaderContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 204, RULE_recordHeader);
        let mut _localctx: Rc<RecordHeaderContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1384);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1386);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (FLOAT - 37)) | (1usize << (INT - 37)) | (1usize << (LONG - 37)) | (1usize << (SHORT - 37)))) != 0) || _la==AT || _la==Identifier {
				{
				/*InvokeRule recordComponentList*/
				recog.base.set_state(1385);
				recog.recordComponentList()?;

				}
			}

			recog.base.set_state(1388);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- recordComponentList ----------------
pub type RecordComponentListContextAll<'input> = RecordComponentListContext<'input>;


pub type RecordComponentListContext<'input> = BaseParserRuleContext<'input,RecordComponentListContextExt<'input>>;

#[derive(Clone)]
pub struct RecordComponentListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for RecordComponentListContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for RecordComponentListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_recordComponentList(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_recordComponentList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for RecordComponentListContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_recordComponentList(self);
	}
}

impl<'input> CustomRuleContext<'input> for RecordComponentListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_recordComponentList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_recordComponentList }
}
antlr_rust::tid!{RecordComponentListContextExt<'a>}

impl<'input> RecordComponentListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RecordComponentListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RecordComponentListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RecordComponentListContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<RecordComponentListContextExt<'input>>{

fn recordComponent_all(&self) ->  Vec<Rc<RecordComponentContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn recordComponent(&self, i: usize) -> Option<Rc<RecordComponentContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> RecordComponentListContextAttrs<'input> for RecordComponentListContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn recordComponentList(&mut self,)
	-> Result<Rc<RecordComponentListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RecordComponentListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 206, RULE_recordComponentList);
        let mut _localctx: Rc<RecordComponentListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule recordComponent*/
			recog.base.set_state(1390);
			recog.recordComponent()?;

			recog.base.set_state(1395);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				recog.base.set_state(1391);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				/*InvokeRule recordComponent*/
				recog.base.set_state(1392);
				recog.recordComponent()?;

				}
				}
				recog.base.set_state(1397);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- recordComponent ----------------
pub type RecordComponentContextAll<'input> = RecordComponentContext<'input>;


pub type RecordComponentContext<'input> = BaseParserRuleContext<'input,RecordComponentContextExt<'input>>;

#[derive(Clone)]
pub struct RecordComponentContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for RecordComponentContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for RecordComponentContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_recordComponent(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_recordComponent(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for RecordComponentContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_recordComponent(self);
	}
}

impl<'input> CustomRuleContext<'input> for RecordComponentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_recordComponent }
	//fn type_rule_index() -> usize where Self: Sized { RULE_recordComponent }
}
antlr_rust::tid!{RecordComponentContextExt<'a>}

impl<'input> RecordComponentContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RecordComponentContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RecordComponentContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RecordComponentContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<RecordComponentContextExt<'input>>{

fn unannType(&self) -> Option<Rc<UnannTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
fn recordComponentModifier_all(&self) ->  Vec<Rc<RecordComponentModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn recordComponentModifier(&self, i: usize) -> Option<Rc<RecordComponentModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn variableArityRecordComponent(&self) -> Option<Rc<VariableArityRecordComponentContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RecordComponentContextAttrs<'input> for RecordComponentContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn recordComponent(&mut self,)
	-> Result<Rc<RecordComponentContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RecordComponentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 208, RULE_recordComponent);
        let mut _localctx: Rc<RecordComponentContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1408);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(144,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1401);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==AT {
						{
						{
						/*InvokeRule recordComponentModifier*/
						recog.base.set_state(1398);
						recog.recordComponentModifier()?;

						}
						}
						recog.base.set_state(1403);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule unannType*/
					recog.base.set_state(1404);
					recog.unannType()?;

					recog.base.set_state(1405);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule variableArityRecordComponent*/
					recog.base.set_state(1407);
					recog.variableArityRecordComponent()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- variableArityRecordComponent ----------------
pub type VariableArityRecordComponentContextAll<'input> = VariableArityRecordComponentContext<'input>;


pub type VariableArityRecordComponentContext<'input> = BaseParserRuleContext<'input,VariableArityRecordComponentContextExt<'input>>;

#[derive(Clone)]
pub struct VariableArityRecordComponentContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for VariableArityRecordComponentContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for VariableArityRecordComponentContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_variableArityRecordComponent(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_variableArityRecordComponent(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for VariableArityRecordComponentContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_variableArityRecordComponent(self);
	}
}

impl<'input> CustomRuleContext<'input> for VariableArityRecordComponentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_variableArityRecordComponent }
	//fn type_rule_index() -> usize where Self: Sized { RULE_variableArityRecordComponent }
}
antlr_rust::tid!{VariableArityRecordComponentContextExt<'a>}

impl<'input> VariableArityRecordComponentContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VariableArityRecordComponentContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VariableArityRecordComponentContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VariableArityRecordComponentContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<VariableArityRecordComponentContextExt<'input>>{

fn unannType(&self) -> Option<Rc<UnannTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ELLIPSIS
/// Returns `None` if there is no child corresponding to token ELLIPSIS
fn ELLIPSIS(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(ELLIPSIS, 0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
fn recordComponentModifier_all(&self) ->  Vec<Rc<RecordComponentModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn recordComponentModifier(&self, i: usize) -> Option<Rc<RecordComponentModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> VariableArityRecordComponentContextAttrs<'input> for VariableArityRecordComponentContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn variableArityRecordComponent(&mut self,)
	-> Result<Rc<VariableArityRecordComponentContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VariableArityRecordComponentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 210, RULE_variableArityRecordComponent);
        let mut _localctx: Rc<VariableArityRecordComponentContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1413);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule recordComponentModifier*/
				recog.base.set_state(1410);
				recog.recordComponentModifier()?;

				}
				}
				recog.base.set_state(1415);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule unannType*/
			recog.base.set_state(1416);
			recog.unannType()?;

			recog.base.set_state(1420);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(1417);
				recog.annotation()?;

				}
				}
				recog.base.set_state(1422);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1423);
			recog.base.match_token(ELLIPSIS,&mut recog.err_handler)?;

			recog.base.set_state(1424);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- recordComponentModifier ----------------
pub type RecordComponentModifierContextAll<'input> = RecordComponentModifierContext<'input>;


pub type RecordComponentModifierContext<'input> = BaseParserRuleContext<'input,RecordComponentModifierContextExt<'input>>;

#[derive(Clone)]
pub struct RecordComponentModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for RecordComponentModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for RecordComponentModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_recordComponentModifier(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_recordComponentModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for RecordComponentModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_recordComponentModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for RecordComponentModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_recordComponentModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_recordComponentModifier }
}
antlr_rust::tid!{RecordComponentModifierContextExt<'a>}

impl<'input> RecordComponentModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RecordComponentModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RecordComponentModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RecordComponentModifierContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<RecordComponentModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RecordComponentModifierContextAttrs<'input> for RecordComponentModifierContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn recordComponentModifier(&mut self,)
	-> Result<Rc<RecordComponentModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RecordComponentModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 212, RULE_recordComponentModifier);
        let mut _localctx: Rc<RecordComponentModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule annotation*/
			recog.base.set_state(1426);
			recog.annotation()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- recordBody ----------------
pub type RecordBodyContextAll<'input> = RecordBodyContext<'input>;


pub type RecordBodyContext<'input> = BaseParserRuleContext<'input,RecordBodyContextExt<'input>>;

#[derive(Clone)]
pub struct RecordBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for RecordBodyContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for RecordBodyContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_recordBody(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_recordBody(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for RecordBodyContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_recordBody(self);
	}
}

impl<'input> CustomRuleContext<'input> for RecordBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_recordBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_recordBody }
}
antlr_rust::tid!{RecordBodyContextExt<'a>}

impl<'input> RecordBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RecordBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RecordBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RecordBodyContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<RecordBodyContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}
fn recordBodyDeclaration_all(&self) ->  Vec<Rc<RecordBodyDeclarationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn recordBodyDeclaration(&self, i: usize) -> Option<Rc<RecordBodyDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> RecordBodyContextAttrs<'input> for RecordBodyContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn recordBody(&mut self,)
	-> Result<Rc<RecordBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RecordBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 214, RULE_recordBody);
        let mut _localctx: Rc<RecordBodyContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1428);
			recog.base.match_token(LBRACE,&mut recog.err_handler)?;

			recog.base.set_state(1432);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << NONSEALED) | (1usize << RECORD) | (1usize << SEALED) | (1usize << ABSTRACT) | (1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << CLASS) | (1usize << DOUBLE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (ENUM - 33)) | (1usize << (FINAL - 33)) | (1usize << (FLOAT - 33)) | (1usize << (INT - 33)) | (1usize << (INTERFACE - 33)) | (1usize << (LONG - 33)) | (1usize << (NATIVE - 33)) | (1usize << (PRIVATE - 33)) | (1usize << (PROTECTED - 33)) | (1usize << (PUBLIC - 33)) | (1usize << (SHORT - 33)) | (1usize << (STATIC - 33)) | (1usize << (STRICTFP - 33)) | (1usize << (SYNCHRONIZED - 33)) | (1usize << (TRANSIENT - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (VOID - 65)) | (1usize << (VOLATILE - 65)) | (1usize << (LBRACE - 65)) | (1usize << (SEMI - 65)) | (1usize << (AT - 65)) | (1usize << (LT - 65)))) != 0) || _la==Identifier {
				{
				{
				/*InvokeRule recordBodyDeclaration*/
				recog.base.set_state(1429);
				recog.recordBodyDeclaration()?;

				}
				}
				recog.base.set_state(1434);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1435);
			recog.base.match_token(RBRACE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- recordBodyDeclaration ----------------
pub type RecordBodyDeclarationContextAll<'input> = RecordBodyDeclarationContext<'input>;


pub type RecordBodyDeclarationContext<'input> = BaseParserRuleContext<'input,RecordBodyDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct RecordBodyDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for RecordBodyDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for RecordBodyDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_recordBodyDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_recordBodyDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for RecordBodyDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_recordBodyDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for RecordBodyDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_recordBodyDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_recordBodyDeclaration }
}
antlr_rust::tid!{RecordBodyDeclarationContextExt<'a>}

impl<'input> RecordBodyDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RecordBodyDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RecordBodyDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RecordBodyDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<RecordBodyDeclarationContextExt<'input>>{

fn classBodyDeclaration(&self) -> Option<Rc<ClassBodyDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn compactConstructorDeclaration(&self) -> Option<Rc<CompactConstructorDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RecordBodyDeclarationContextAttrs<'input> for RecordBodyDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn recordBodyDeclaration(&mut self,)
	-> Result<Rc<RecordBodyDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RecordBodyDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 216, RULE_recordBodyDeclaration);
        let mut _localctx: Rc<RecordBodyDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1439);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(148,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule classBodyDeclaration*/
					recog.base.set_state(1437);
					recog.classBodyDeclaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule compactConstructorDeclaration*/
					recog.base.set_state(1438);
					recog.compactConstructorDeclaration()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- compactConstructorDeclaration ----------------
pub type CompactConstructorDeclarationContextAll<'input> = CompactConstructorDeclarationContext<'input>;


pub type CompactConstructorDeclarationContext<'input> = BaseParserRuleContext<'input,CompactConstructorDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct CompactConstructorDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for CompactConstructorDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for CompactConstructorDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_compactConstructorDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_compactConstructorDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for CompactConstructorDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_compactConstructorDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for CompactConstructorDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_compactConstructorDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_compactConstructorDeclaration }
}
antlr_rust::tid!{CompactConstructorDeclarationContextExt<'a>}

impl<'input> CompactConstructorDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CompactConstructorDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CompactConstructorDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CompactConstructorDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<CompactConstructorDeclarationContextExt<'input>>{

fn simpleTypeName(&self) -> Option<Rc<SimpleTypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constructorBody(&self) -> Option<Rc<ConstructorBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constructorModifier_all(&self) ->  Vec<Rc<ConstructorModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn constructorModifier(&self, i: usize) -> Option<Rc<ConstructorModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> CompactConstructorDeclarationContextAttrs<'input> for CompactConstructorDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn compactConstructorDeclaration(&mut self,)
	-> Result<Rc<CompactConstructorDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CompactConstructorDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 218, RULE_compactConstructorDeclaration);
        let mut _localctx: Rc<CompactConstructorDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1444);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while ((((_la - 50)) & !0x3f) == 0 && ((1usize << (_la - 50)) & ((1usize << (PRIVATE - 50)) | (1usize << (PROTECTED - 50)) | (1usize << (PUBLIC - 50)))) != 0) || _la==AT {
				{
				{
				/*InvokeRule constructorModifier*/
				recog.base.set_state(1441);
				recog.constructorModifier()?;

				}
				}
				recog.base.set_state(1446);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule simpleTypeName*/
			recog.base.set_state(1447);
			recog.simpleTypeName()?;

			/*InvokeRule constructorBody*/
			recog.base.set_state(1448);
			recog.constructorBody()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfaceDeclaration ----------------
pub type InterfaceDeclarationContextAll<'input> = InterfaceDeclarationContext<'input>;


pub type InterfaceDeclarationContext<'input> = BaseParserRuleContext<'input,InterfaceDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct InterfaceDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for InterfaceDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for InterfaceDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_interfaceDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_interfaceDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for InterfaceDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_interfaceDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for InterfaceDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfaceDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfaceDeclaration }
}
antlr_rust::tid!{InterfaceDeclarationContextExt<'a>}

impl<'input> InterfaceDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfaceDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfaceDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfaceDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<InterfaceDeclarationContextExt<'input>>{

fn normalInterfaceDeclaration(&self) -> Option<Rc<NormalInterfaceDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotationInterfaceDeclaration(&self) -> Option<Rc<AnnotationInterfaceDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InterfaceDeclarationContextAttrs<'input> for InterfaceDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfaceDeclaration(&mut self,)
	-> Result<Rc<InterfaceDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfaceDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 220, RULE_interfaceDeclaration);
        let mut _localctx: Rc<InterfaceDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1452);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(150,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule normalInterfaceDeclaration*/
					recog.base.set_state(1450);
					recog.normalInterfaceDeclaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule annotationInterfaceDeclaration*/
					recog.base.set_state(1451);
					recog.annotationInterfaceDeclaration()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- normalInterfaceDeclaration ----------------
pub type NormalInterfaceDeclarationContextAll<'input> = NormalInterfaceDeclarationContext<'input>;


pub type NormalInterfaceDeclarationContext<'input> = BaseParserRuleContext<'input,NormalInterfaceDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct NormalInterfaceDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for NormalInterfaceDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for NormalInterfaceDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_normalInterfaceDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_normalInterfaceDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for NormalInterfaceDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_normalInterfaceDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for NormalInterfaceDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_normalInterfaceDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_normalInterfaceDeclaration }
}
antlr_rust::tid!{NormalInterfaceDeclarationContextExt<'a>}

impl<'input> NormalInterfaceDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NormalInterfaceDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NormalInterfaceDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NormalInterfaceDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<NormalInterfaceDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token INTERFACE
/// Returns `None` if there is no child corresponding to token INTERFACE
fn INTERFACE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(INTERFACE, 0)
}
fn typeIdentifier(&self) -> Option<Rc<TypeIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfaceBody(&self) -> Option<Rc<InterfaceBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfaceModifier_all(&self) ->  Vec<Rc<InterfaceModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn interfaceModifier(&self, i: usize) -> Option<Rc<InterfaceModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn typeParameters(&self) -> Option<Rc<TypeParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfaceExtends(&self) -> Option<Rc<InterfaceExtendsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfacePermits(&self) -> Option<Rc<InterfacePermitsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NormalInterfaceDeclarationContextAttrs<'input> for NormalInterfaceDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn normalInterfaceDeclaration(&mut self,)
	-> Result<Rc<NormalInterfaceDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NormalInterfaceDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 222, RULE_normalInterfaceDeclaration);
        let mut _localctx: Rc<NormalInterfaceDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1457);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << NONSEALED) | (1usize << SEALED) | (1usize << ABSTRACT))) != 0) || ((((_la - 50)) & !0x3f) == 0 && ((1usize << (_la - 50)) & ((1usize << (PRIVATE - 50)) | (1usize << (PROTECTED - 50)) | (1usize << (PUBLIC - 50)) | (1usize << (STATIC - 50)) | (1usize << (STRICTFP - 50)))) != 0) || _la==AT {
				{
				{
				/*InvokeRule interfaceModifier*/
				recog.base.set_state(1454);
				recog.interfaceModifier()?;

				}
				}
				recog.base.set_state(1459);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1460);
			recog.base.match_token(INTERFACE,&mut recog.err_handler)?;

			/*InvokeRule typeIdentifier*/
			recog.base.set_state(1461);
			recog.typeIdentifier()?;

			recog.base.set_state(1463);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LT {
				{
				/*InvokeRule typeParameters*/
				recog.base.set_state(1462);
				recog.typeParameters()?;

				}
			}

			recog.base.set_state(1466);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==EXTENDS {
				{
				/*InvokeRule interfaceExtends*/
				recog.base.set_state(1465);
				recog.interfaceExtends()?;

				}
			}

			recog.base.set_state(1469);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==PERMITS {
				{
				/*InvokeRule interfacePermits*/
				recog.base.set_state(1468);
				recog.interfacePermits()?;

				}
			}

			/*InvokeRule interfaceBody*/
			recog.base.set_state(1471);
			recog.interfaceBody()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfaceModifier ----------------
pub type InterfaceModifierContextAll<'input> = InterfaceModifierContext<'input>;


pub type InterfaceModifierContext<'input> = BaseParserRuleContext<'input,InterfaceModifierContextExt<'input>>;

#[derive(Clone)]
pub struct InterfaceModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for InterfaceModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for InterfaceModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_interfaceModifier(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_interfaceModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for InterfaceModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_interfaceModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for InterfaceModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfaceModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfaceModifier }
}
antlr_rust::tid!{InterfaceModifierContextExt<'a>}

impl<'input> InterfaceModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfaceModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfaceModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfaceModifierContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<InterfaceModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token PUBLIC
/// Returns `None` if there is no child corresponding to token PUBLIC
fn PUBLIC(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(PUBLIC, 0)
}
/// Retrieves first TerminalNode corresponding to token PROTECTED
/// Returns `None` if there is no child corresponding to token PROTECTED
fn PROTECTED(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(PROTECTED, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIVATE
/// Returns `None` if there is no child corresponding to token PRIVATE
fn PRIVATE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(PRIVATE, 0)
}
/// Retrieves first TerminalNode corresponding to token ABSTRACT
/// Returns `None` if there is no child corresponding to token ABSTRACT
fn ABSTRACT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(ABSTRACT, 0)
}
/// Retrieves first TerminalNode corresponding to token STATIC
/// Returns `None` if there is no child corresponding to token STATIC
fn STATIC(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(STATIC, 0)
}
/// Retrieves first TerminalNode corresponding to token SEALED
/// Returns `None` if there is no child corresponding to token SEALED
fn SEALED(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEALED, 0)
}
/// Retrieves first TerminalNode corresponding to token NONSEALED
/// Returns `None` if there is no child corresponding to token NONSEALED
fn NONSEALED(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(NONSEALED, 0)
}
/// Retrieves first TerminalNode corresponding to token STRICTFP
/// Returns `None` if there is no child corresponding to token STRICTFP
fn STRICTFP(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(STRICTFP, 0)
}

}

impl<'input> InterfaceModifierContextAttrs<'input> for InterfaceModifierContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfaceModifier(&mut self,)
	-> Result<Rc<InterfaceModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfaceModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 224, RULE_interfaceModifier);
        let mut _localctx: Rc<InterfaceModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1482);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 AT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(1473);
					recog.annotation()?;

					}
				}

			 PUBLIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1474);
					recog.base.match_token(PUBLIC,&mut recog.err_handler)?;

					}
				}

			 PROTECTED 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(1475);
					recog.base.match_token(PROTECTED,&mut recog.err_handler)?;

					}
				}

			 PRIVATE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(1476);
					recog.base.match_token(PRIVATE,&mut recog.err_handler)?;

					}
				}

			 ABSTRACT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(1477);
					recog.base.match_token(ABSTRACT,&mut recog.err_handler)?;

					}
				}

			 STATIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					recog.base.set_state(1478);
					recog.base.match_token(STATIC,&mut recog.err_handler)?;

					}
				}

			 SEALED 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					recog.base.set_state(1479);
					recog.base.match_token(SEALED,&mut recog.err_handler)?;

					}
				}

			 NONSEALED 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					recog.base.set_state(1480);
					recog.base.match_token(NONSEALED,&mut recog.err_handler)?;

					}
				}

			 STRICTFP 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					recog.base.set_state(1481);
					recog.base.match_token(STRICTFP,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfaceExtends ----------------
pub type InterfaceExtendsContextAll<'input> = InterfaceExtendsContext<'input>;


pub type InterfaceExtendsContext<'input> = BaseParserRuleContext<'input,InterfaceExtendsContextExt<'input>>;

#[derive(Clone)]
pub struct InterfaceExtendsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for InterfaceExtendsContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for InterfaceExtendsContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_interfaceExtends(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_interfaceExtends(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for InterfaceExtendsContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_interfaceExtends(self);
	}
}

impl<'input> CustomRuleContext<'input> for InterfaceExtendsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfaceExtends }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfaceExtends }
}
antlr_rust::tid!{InterfaceExtendsContextExt<'a>}

impl<'input> InterfaceExtendsContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfaceExtendsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfaceExtendsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfaceExtendsContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<InterfaceExtendsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token EXTENDS
/// Returns `None` if there is no child corresponding to token EXTENDS
fn EXTENDS(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(EXTENDS, 0)
}
fn interfaceTypeList(&self) -> Option<Rc<InterfaceTypeListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InterfaceExtendsContextAttrs<'input> for InterfaceExtendsContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfaceExtends(&mut self,)
	-> Result<Rc<InterfaceExtendsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfaceExtendsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 226, RULE_interfaceExtends);
        let mut _localctx: Rc<InterfaceExtendsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1484);
			recog.base.match_token(EXTENDS,&mut recog.err_handler)?;

			/*InvokeRule interfaceTypeList*/
			recog.base.set_state(1485);
			recog.interfaceTypeList()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfacePermits ----------------
pub type InterfacePermitsContextAll<'input> = InterfacePermitsContext<'input>;


pub type InterfacePermitsContext<'input> = BaseParserRuleContext<'input,InterfacePermitsContextExt<'input>>;

#[derive(Clone)]
pub struct InterfacePermitsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for InterfacePermitsContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for InterfacePermitsContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_interfacePermits(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_interfacePermits(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for InterfacePermitsContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_interfacePermits(self);
	}
}

impl<'input> CustomRuleContext<'input> for InterfacePermitsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfacePermits }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfacePermits }
}
antlr_rust::tid!{InterfacePermitsContextExt<'a>}

impl<'input> InterfacePermitsContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfacePermitsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfacePermitsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfacePermitsContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<InterfacePermitsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token PERMITS
/// Returns `None` if there is no child corresponding to token PERMITS
fn PERMITS(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(PERMITS, 0)
}
fn typeName_all(&self) ->  Vec<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeName(&self, i: usize) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> InterfacePermitsContextAttrs<'input> for InterfacePermitsContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfacePermits(&mut self,)
	-> Result<Rc<InterfacePermitsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfacePermitsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 228, RULE_interfacePermits);
        let mut _localctx: Rc<InterfacePermitsContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1487);
			recog.base.match_token(PERMITS,&mut recog.err_handler)?;

			/*InvokeRule typeName*/
			recog.base.set_state(1488);
			recog.typeName()?;

			recog.base.set_state(1493);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				recog.base.set_state(1489);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				/*InvokeRule typeName*/
				recog.base.set_state(1490);
				recog.typeName()?;

				}
				}
				recog.base.set_state(1495);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfaceBody ----------------
pub type InterfaceBodyContextAll<'input> = InterfaceBodyContext<'input>;


pub type InterfaceBodyContext<'input> = BaseParserRuleContext<'input,InterfaceBodyContextExt<'input>>;

#[derive(Clone)]
pub struct InterfaceBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for InterfaceBodyContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for InterfaceBodyContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_interfaceBody(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_interfaceBody(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for InterfaceBodyContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_interfaceBody(self);
	}
}

impl<'input> CustomRuleContext<'input> for InterfaceBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfaceBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfaceBody }
}
antlr_rust::tid!{InterfaceBodyContextExt<'a>}

impl<'input> InterfaceBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfaceBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfaceBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfaceBodyContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<InterfaceBodyContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}
fn interfaceMemberDeclaration_all(&self) ->  Vec<Rc<InterfaceMemberDeclarationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn interfaceMemberDeclaration(&self, i: usize) -> Option<Rc<InterfaceMemberDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> InterfaceBodyContextAttrs<'input> for InterfaceBodyContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfaceBody(&mut self,)
	-> Result<Rc<InterfaceBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfaceBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 230, RULE_interfaceBody);
        let mut _localctx: Rc<InterfaceBodyContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1496);
			recog.base.match_token(LBRACE,&mut recog.err_handler)?;

			recog.base.set_state(1500);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << NONSEALED) | (1usize << RECORD) | (1usize << SEALED) | (1usize << ABSTRACT) | (1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << CLASS) | (1usize << DEFAULT) | (1usize << DOUBLE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (ENUM - 33)) | (1usize << (FINAL - 33)) | (1usize << (FLOAT - 33)) | (1usize << (INT - 33)) | (1usize << (INTERFACE - 33)) | (1usize << (LONG - 33)) | (1usize << (PRIVATE - 33)) | (1usize << (PROTECTED - 33)) | (1usize << (PUBLIC - 33)) | (1usize << (SHORT - 33)) | (1usize << (STATIC - 33)) | (1usize << (STRICTFP - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (VOID - 65)) | (1usize << (SEMI - 65)) | (1usize << (AT - 65)) | (1usize << (LT - 65)))) != 0) || _la==Identifier {
				{
				{
				/*InvokeRule interfaceMemberDeclaration*/
				recog.base.set_state(1497);
				recog.interfaceMemberDeclaration()?;

				}
				}
				recog.base.set_state(1502);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1503);
			recog.base.match_token(RBRACE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfaceMemberDeclaration ----------------
pub type InterfaceMemberDeclarationContextAll<'input> = InterfaceMemberDeclarationContext<'input>;


pub type InterfaceMemberDeclarationContext<'input> = BaseParserRuleContext<'input,InterfaceMemberDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct InterfaceMemberDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for InterfaceMemberDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for InterfaceMemberDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_interfaceMemberDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_interfaceMemberDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for InterfaceMemberDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_interfaceMemberDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for InterfaceMemberDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfaceMemberDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfaceMemberDeclaration }
}
antlr_rust::tid!{InterfaceMemberDeclarationContextExt<'a>}

impl<'input> InterfaceMemberDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfaceMemberDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfaceMemberDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfaceMemberDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<InterfaceMemberDeclarationContextExt<'input>>{

fn constantDeclaration(&self) -> Option<Rc<ConstantDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfaceMethodDeclaration(&self) -> Option<Rc<InterfaceMethodDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classDeclaration(&self) -> Option<Rc<ClassDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfaceDeclaration(&self) -> Option<Rc<InterfaceDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> InterfaceMemberDeclarationContextAttrs<'input> for InterfaceMemberDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfaceMemberDeclaration(&mut self,)
	-> Result<Rc<InterfaceMemberDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfaceMemberDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 232, RULE_interfaceMemberDeclaration);
        let mut _localctx: Rc<InterfaceMemberDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1510);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(158,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule constantDeclaration*/
					recog.base.set_state(1505);
					recog.constantDeclaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule interfaceMethodDeclaration*/
					recog.base.set_state(1506);
					recog.interfaceMethodDeclaration()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule classDeclaration*/
					recog.base.set_state(1507);
					recog.classDeclaration()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule interfaceDeclaration*/
					recog.base.set_state(1508);
					recog.interfaceDeclaration()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(1509);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constantDeclaration ----------------
pub type ConstantDeclarationContextAll<'input> = ConstantDeclarationContext<'input>;


pub type ConstantDeclarationContext<'input> = BaseParserRuleContext<'input,ConstantDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct ConstantDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ConstantDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ConstantDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constantDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_constantDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ConstantDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_constantDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for ConstantDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constantDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constantDeclaration }
}
antlr_rust::tid!{ConstantDeclarationContextExt<'a>}

impl<'input> ConstantDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstantDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstantDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstantDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ConstantDeclarationContextExt<'input>>{

fn unannType(&self) -> Option<Rc<UnannTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableDeclaratorList(&self) -> Option<Rc<VariableDeclaratorListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}
fn constantModifier_all(&self) ->  Vec<Rc<ConstantModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn constantModifier(&self, i: usize) -> Option<Rc<ConstantModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ConstantDeclarationContextAttrs<'input> for ConstantDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constantDeclaration(&mut self,)
	-> Result<Rc<ConstantDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstantDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 234, RULE_constantDeclaration);
        let mut _localctx: Rc<ConstantDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1515);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while ((((_la - 35)) & !0x3f) == 0 && ((1usize << (_la - 35)) & ((1usize << (FINAL - 35)) | (1usize << (PUBLIC - 35)) | (1usize << (STATIC - 35)))) != 0) || _la==AT {
				{
				{
				/*InvokeRule constantModifier*/
				recog.base.set_state(1512);
				recog.constantModifier()?;

				}
				}
				recog.base.set_state(1517);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule unannType*/
			recog.base.set_state(1518);
			recog.unannType()?;

			/*InvokeRule variableDeclaratorList*/
			recog.base.set_state(1519);
			recog.variableDeclaratorList()?;

			recog.base.set_state(1520);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constantModifier ----------------
pub type ConstantModifierContextAll<'input> = ConstantModifierContext<'input>;


pub type ConstantModifierContext<'input> = BaseParserRuleContext<'input,ConstantModifierContextExt<'input>>;

#[derive(Clone)]
pub struct ConstantModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ConstantModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ConstantModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constantModifier(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_constantModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ConstantModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_constantModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for ConstantModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constantModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constantModifier }
}
antlr_rust::tid!{ConstantModifierContextExt<'a>}

impl<'input> ConstantModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstantModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstantModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstantModifierContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ConstantModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token PUBLIC
/// Returns `None` if there is no child corresponding to token PUBLIC
fn PUBLIC(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(PUBLIC, 0)
}
/// Retrieves first TerminalNode corresponding to token STATIC
/// Returns `None` if there is no child corresponding to token STATIC
fn STATIC(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(STATIC, 0)
}
/// Retrieves first TerminalNode corresponding to token FINAL
/// Returns `None` if there is no child corresponding to token FINAL
fn FINAL(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(FINAL, 0)
}

}

impl<'input> ConstantModifierContextAttrs<'input> for ConstantModifierContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constantModifier(&mut self,)
	-> Result<Rc<ConstantModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstantModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 236, RULE_constantModifier);
        let mut _localctx: Rc<ConstantModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1526);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 AT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(1522);
					recog.annotation()?;

					}
				}

			 PUBLIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1523);
					recog.base.match_token(PUBLIC,&mut recog.err_handler)?;

					}
				}

			 STATIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(1524);
					recog.base.match_token(STATIC,&mut recog.err_handler)?;

					}
				}

			 FINAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(1525);
					recog.base.match_token(FINAL,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfaceMethodDeclaration ----------------
pub type InterfaceMethodDeclarationContextAll<'input> = InterfaceMethodDeclarationContext<'input>;


pub type InterfaceMethodDeclarationContext<'input> = BaseParserRuleContext<'input,InterfaceMethodDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct InterfaceMethodDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for InterfaceMethodDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for InterfaceMethodDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_interfaceMethodDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_interfaceMethodDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for InterfaceMethodDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_interfaceMethodDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for InterfaceMethodDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfaceMethodDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfaceMethodDeclaration }
}
antlr_rust::tid!{InterfaceMethodDeclarationContextExt<'a>}

impl<'input> InterfaceMethodDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfaceMethodDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfaceMethodDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfaceMethodDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<InterfaceMethodDeclarationContextExt<'input>>{

fn methodHeader(&self) -> Option<Rc<MethodHeaderContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodBody(&self) -> Option<Rc<MethodBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfaceMethodModifier_all(&self) ->  Vec<Rc<InterfaceMethodModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn interfaceMethodModifier(&self, i: usize) -> Option<Rc<InterfaceMethodModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> InterfaceMethodDeclarationContextAttrs<'input> for InterfaceMethodDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfaceMethodDeclaration(&mut self,)
	-> Result<Rc<InterfaceMethodDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfaceMethodDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 238, RULE_interfaceMethodDeclaration);
        let mut _localctx: Rc<InterfaceMethodDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1531);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==ABSTRACT || _la==DEFAULT || ((((_la - 50)) & !0x3f) == 0 && ((1usize << (_la - 50)) & ((1usize << (PRIVATE - 50)) | (1usize << (PUBLIC - 50)) | (1usize << (STATIC - 50)) | (1usize << (STRICTFP - 50)))) != 0) || _la==AT {
				{
				{
				/*InvokeRule interfaceMethodModifier*/
				recog.base.set_state(1528);
				recog.interfaceMethodModifier()?;

				}
				}
				recog.base.set_state(1533);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule methodHeader*/
			recog.base.set_state(1534);
			recog.methodHeader()?;

			/*InvokeRule methodBody*/
			recog.base.set_state(1535);
			recog.methodBody()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfaceMethodModifier ----------------
pub type InterfaceMethodModifierContextAll<'input> = InterfaceMethodModifierContext<'input>;


pub type InterfaceMethodModifierContext<'input> = BaseParserRuleContext<'input,InterfaceMethodModifierContextExt<'input>>;

#[derive(Clone)]
pub struct InterfaceMethodModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for InterfaceMethodModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for InterfaceMethodModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_interfaceMethodModifier(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_interfaceMethodModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for InterfaceMethodModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_interfaceMethodModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for InterfaceMethodModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfaceMethodModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfaceMethodModifier }
}
antlr_rust::tid!{InterfaceMethodModifierContextExt<'a>}

impl<'input> InterfaceMethodModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfaceMethodModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfaceMethodModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfaceMethodModifierContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<InterfaceMethodModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token PUBLIC
/// Returns `None` if there is no child corresponding to token PUBLIC
fn PUBLIC(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(PUBLIC, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIVATE
/// Returns `None` if there is no child corresponding to token PRIVATE
fn PRIVATE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(PRIVATE, 0)
}
/// Retrieves first TerminalNode corresponding to token ABSTRACT
/// Returns `None` if there is no child corresponding to token ABSTRACT
fn ABSTRACT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(ABSTRACT, 0)
}
/// Retrieves first TerminalNode corresponding to token DEFAULT
/// Returns `None` if there is no child corresponding to token DEFAULT
fn DEFAULT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DEFAULT, 0)
}
/// Retrieves first TerminalNode corresponding to token STATIC
/// Returns `None` if there is no child corresponding to token STATIC
fn STATIC(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(STATIC, 0)
}
/// Retrieves first TerminalNode corresponding to token STRICTFP
/// Returns `None` if there is no child corresponding to token STRICTFP
fn STRICTFP(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(STRICTFP, 0)
}

}

impl<'input> InterfaceMethodModifierContextAttrs<'input> for InterfaceMethodModifierContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfaceMethodModifier(&mut self,)
	-> Result<Rc<InterfaceMethodModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfaceMethodModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 240, RULE_interfaceMethodModifier);
        let mut _localctx: Rc<InterfaceMethodModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1544);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 AT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(1537);
					recog.annotation()?;

					}
				}

			 PUBLIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1538);
					recog.base.match_token(PUBLIC,&mut recog.err_handler)?;

					}
				}

			 PRIVATE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(1539);
					recog.base.match_token(PRIVATE,&mut recog.err_handler)?;

					}
				}

			 ABSTRACT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(1540);
					recog.base.match_token(ABSTRACT,&mut recog.err_handler)?;

					}
				}

			 DEFAULT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(1541);
					recog.base.match_token(DEFAULT,&mut recog.err_handler)?;

					}
				}

			 STATIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					recog.base.set_state(1542);
					recog.base.match_token(STATIC,&mut recog.err_handler)?;

					}
				}

			 STRICTFP 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					recog.base.set_state(1543);
					recog.base.match_token(STRICTFP,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotationInterfaceDeclaration ----------------
pub type AnnotationInterfaceDeclarationContextAll<'input> = AnnotationInterfaceDeclarationContext<'input>;


pub type AnnotationInterfaceDeclarationContext<'input> = BaseParserRuleContext<'input,AnnotationInterfaceDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationInterfaceDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for AnnotationInterfaceDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for AnnotationInterfaceDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_annotationInterfaceDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_annotationInterfaceDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for AnnotationInterfaceDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_annotationInterfaceDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for AnnotationInterfaceDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotationInterfaceDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotationInterfaceDeclaration }
}
antlr_rust::tid!{AnnotationInterfaceDeclarationContextExt<'a>}

impl<'input> AnnotationInterfaceDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotationInterfaceDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotationInterfaceDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotationInterfaceDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<AnnotationInterfaceDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token AT
/// Returns `None` if there is no child corresponding to token AT
fn AT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(AT, 0)
}
/// Retrieves first TerminalNode corresponding to token INTERFACE
/// Returns `None` if there is no child corresponding to token INTERFACE
fn INTERFACE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(INTERFACE, 0)
}
fn typeIdentifier(&self) -> Option<Rc<TypeIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotationInterfaceBody(&self) -> Option<Rc<AnnotationInterfaceBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfaceModifier_all(&self) ->  Vec<Rc<InterfaceModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn interfaceModifier(&self, i: usize) -> Option<Rc<InterfaceModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> AnnotationInterfaceDeclarationContextAttrs<'input> for AnnotationInterfaceDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotationInterfaceDeclaration(&mut self,)
	-> Result<Rc<AnnotationInterfaceDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotationInterfaceDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 242, RULE_annotationInterfaceDeclaration);
        let mut _localctx: Rc<AnnotationInterfaceDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1549);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(163,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule interfaceModifier*/
					recog.base.set_state(1546);
					recog.interfaceModifier()?;

					}
					} 
				}
				recog.base.set_state(1551);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(163,&mut recog.base)?;
			}
			recog.base.set_state(1552);
			recog.base.match_token(AT,&mut recog.err_handler)?;

			recog.base.set_state(1553);
			recog.base.match_token(INTERFACE,&mut recog.err_handler)?;

			/*InvokeRule typeIdentifier*/
			recog.base.set_state(1554);
			recog.typeIdentifier()?;

			/*InvokeRule annotationInterfaceBody*/
			recog.base.set_state(1555);
			recog.annotationInterfaceBody()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotationInterfaceBody ----------------
pub type AnnotationInterfaceBodyContextAll<'input> = AnnotationInterfaceBodyContext<'input>;


pub type AnnotationInterfaceBodyContext<'input> = BaseParserRuleContext<'input,AnnotationInterfaceBodyContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationInterfaceBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for AnnotationInterfaceBodyContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for AnnotationInterfaceBodyContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_annotationInterfaceBody(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_annotationInterfaceBody(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for AnnotationInterfaceBodyContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_annotationInterfaceBody(self);
	}
}

impl<'input> CustomRuleContext<'input> for AnnotationInterfaceBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotationInterfaceBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotationInterfaceBody }
}
antlr_rust::tid!{AnnotationInterfaceBodyContextExt<'a>}

impl<'input> AnnotationInterfaceBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotationInterfaceBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotationInterfaceBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotationInterfaceBodyContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<AnnotationInterfaceBodyContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}
fn annotationInterfaceMemberDeclaration_all(&self) ->  Vec<Rc<AnnotationInterfaceMemberDeclarationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotationInterfaceMemberDeclaration(&self, i: usize) -> Option<Rc<AnnotationInterfaceMemberDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> AnnotationInterfaceBodyContextAttrs<'input> for AnnotationInterfaceBodyContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotationInterfaceBody(&mut self,)
	-> Result<Rc<AnnotationInterfaceBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotationInterfaceBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 244, RULE_annotationInterfaceBody);
        let mut _localctx: Rc<AnnotationInterfaceBodyContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1557);
			recog.base.match_token(LBRACE,&mut recog.err_handler)?;

			recog.base.set_state(1561);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << NONSEALED) | (1usize << RECORD) | (1usize << SEALED) | (1usize << ABSTRACT) | (1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << CLASS) | (1usize << DOUBLE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (ENUM - 33)) | (1usize << (FINAL - 33)) | (1usize << (FLOAT - 33)) | (1usize << (INT - 33)) | (1usize << (INTERFACE - 33)) | (1usize << (LONG - 33)) | (1usize << (PRIVATE - 33)) | (1usize << (PROTECTED - 33)) | (1usize << (PUBLIC - 33)) | (1usize << (SHORT - 33)) | (1usize << (STATIC - 33)) | (1usize << (STRICTFP - 33)))) != 0) || _la==SEMI || _la==AT || _la==Identifier {
				{
				{
				/*InvokeRule annotationInterfaceMemberDeclaration*/
				recog.base.set_state(1558);
				recog.annotationInterfaceMemberDeclaration()?;

				}
				}
				recog.base.set_state(1563);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1564);
			recog.base.match_token(RBRACE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotationInterfaceMemberDeclaration ----------------
pub type AnnotationInterfaceMemberDeclarationContextAll<'input> = AnnotationInterfaceMemberDeclarationContext<'input>;


pub type AnnotationInterfaceMemberDeclarationContext<'input> = BaseParserRuleContext<'input,AnnotationInterfaceMemberDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationInterfaceMemberDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for AnnotationInterfaceMemberDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for AnnotationInterfaceMemberDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_annotationInterfaceMemberDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_annotationInterfaceMemberDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for AnnotationInterfaceMemberDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_annotationInterfaceMemberDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for AnnotationInterfaceMemberDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotationInterfaceMemberDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotationInterfaceMemberDeclaration }
}
antlr_rust::tid!{AnnotationInterfaceMemberDeclarationContextExt<'a>}

impl<'input> AnnotationInterfaceMemberDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotationInterfaceMemberDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotationInterfaceMemberDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotationInterfaceMemberDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<AnnotationInterfaceMemberDeclarationContextExt<'input>>{

fn annotationInterfaceElementDeclaration(&self) -> Option<Rc<AnnotationInterfaceElementDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constantDeclaration(&self) -> Option<Rc<ConstantDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classDeclaration(&self) -> Option<Rc<ClassDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfaceDeclaration(&self) -> Option<Rc<InterfaceDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> AnnotationInterfaceMemberDeclarationContextAttrs<'input> for AnnotationInterfaceMemberDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotationInterfaceMemberDeclaration(&mut self,)
	-> Result<Rc<AnnotationInterfaceMemberDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotationInterfaceMemberDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 246, RULE_annotationInterfaceMemberDeclaration);
        let mut _localctx: Rc<AnnotationInterfaceMemberDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1571);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(165,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule annotationInterfaceElementDeclaration*/
					recog.base.set_state(1566);
					recog.annotationInterfaceElementDeclaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule constantDeclaration*/
					recog.base.set_state(1567);
					recog.constantDeclaration()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule classDeclaration*/
					recog.base.set_state(1568);
					recog.classDeclaration()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule interfaceDeclaration*/
					recog.base.set_state(1569);
					recog.interfaceDeclaration()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(1570);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotationInterfaceElementDeclaration ----------------
pub type AnnotationInterfaceElementDeclarationContextAll<'input> = AnnotationInterfaceElementDeclarationContext<'input>;


pub type AnnotationInterfaceElementDeclarationContext<'input> = BaseParserRuleContext<'input,AnnotationInterfaceElementDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationInterfaceElementDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for AnnotationInterfaceElementDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for AnnotationInterfaceElementDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_annotationInterfaceElementDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_annotationInterfaceElementDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for AnnotationInterfaceElementDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_annotationInterfaceElementDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for AnnotationInterfaceElementDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotationInterfaceElementDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotationInterfaceElementDeclaration }
}
antlr_rust::tid!{AnnotationInterfaceElementDeclarationContextExt<'a>}

impl<'input> AnnotationInterfaceElementDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotationInterfaceElementDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotationInterfaceElementDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotationInterfaceElementDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<AnnotationInterfaceElementDeclarationContextExt<'input>>{

fn unannType(&self) -> Option<Rc<UnannTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}
fn annotationInterfaceElementModifier_all(&self) ->  Vec<Rc<AnnotationInterfaceElementModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotationInterfaceElementModifier(&self, i: usize) -> Option<Rc<AnnotationInterfaceElementModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn dims(&self) -> Option<Rc<DimsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn defaultValue(&self) -> Option<Rc<DefaultValueContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AnnotationInterfaceElementDeclarationContextAttrs<'input> for AnnotationInterfaceElementDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotationInterfaceElementDeclaration(&mut self,)
	-> Result<Rc<AnnotationInterfaceElementDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotationInterfaceElementDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 248, RULE_annotationInterfaceElementDeclaration);
        let mut _localctx: Rc<AnnotationInterfaceElementDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1576);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==ABSTRACT || _la==PUBLIC || _la==AT {
				{
				{
				/*InvokeRule annotationInterfaceElementModifier*/
				recog.base.set_state(1573);
				recog.annotationInterfaceElementModifier()?;

				}
				}
				recog.base.set_state(1578);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule unannType*/
			recog.base.set_state(1579);
			recog.unannType()?;

			recog.base.set_state(1580);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			recog.base.set_state(1581);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1582);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1584);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LBRACK || _la==AT {
				{
				/*InvokeRule dims*/
				recog.base.set_state(1583);
				recog.dims()?;

				}
			}

			recog.base.set_state(1587);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==DEFAULT {
				{
				/*InvokeRule defaultValue*/
				recog.base.set_state(1586);
				recog.defaultValue()?;

				}
			}

			recog.base.set_state(1589);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotationInterfaceElementModifier ----------------
pub type AnnotationInterfaceElementModifierContextAll<'input> = AnnotationInterfaceElementModifierContext<'input>;


pub type AnnotationInterfaceElementModifierContext<'input> = BaseParserRuleContext<'input,AnnotationInterfaceElementModifierContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationInterfaceElementModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for AnnotationInterfaceElementModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for AnnotationInterfaceElementModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_annotationInterfaceElementModifier(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_annotationInterfaceElementModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for AnnotationInterfaceElementModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_annotationInterfaceElementModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for AnnotationInterfaceElementModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotationInterfaceElementModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotationInterfaceElementModifier }
}
antlr_rust::tid!{AnnotationInterfaceElementModifierContextExt<'a>}

impl<'input> AnnotationInterfaceElementModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotationInterfaceElementModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotationInterfaceElementModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotationInterfaceElementModifierContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<AnnotationInterfaceElementModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token PUBLIC
/// Returns `None` if there is no child corresponding to token PUBLIC
fn PUBLIC(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(PUBLIC, 0)
}
/// Retrieves first TerminalNode corresponding to token ABSTRACT
/// Returns `None` if there is no child corresponding to token ABSTRACT
fn ABSTRACT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(ABSTRACT, 0)
}

}

impl<'input> AnnotationInterfaceElementModifierContextAttrs<'input> for AnnotationInterfaceElementModifierContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotationInterfaceElementModifier(&mut self,)
	-> Result<Rc<AnnotationInterfaceElementModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotationInterfaceElementModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 250, RULE_annotationInterfaceElementModifier);
        let mut _localctx: Rc<AnnotationInterfaceElementModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1594);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 AT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(1591);
					recog.annotation()?;

					}
				}

			 PUBLIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1592);
					recog.base.match_token(PUBLIC,&mut recog.err_handler)?;

					}
				}

			 ABSTRACT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(1593);
					recog.base.match_token(ABSTRACT,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- defaultValue ----------------
pub type DefaultValueContextAll<'input> = DefaultValueContext<'input>;


pub type DefaultValueContext<'input> = BaseParserRuleContext<'input,DefaultValueContextExt<'input>>;

#[derive(Clone)]
pub struct DefaultValueContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for DefaultValueContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for DefaultValueContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_defaultValue(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_defaultValue(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for DefaultValueContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_defaultValue(self);
	}
}

impl<'input> CustomRuleContext<'input> for DefaultValueContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_defaultValue }
	//fn type_rule_index() -> usize where Self: Sized { RULE_defaultValue }
}
antlr_rust::tid!{DefaultValueContextExt<'a>}

impl<'input> DefaultValueContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DefaultValueContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DefaultValueContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DefaultValueContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<DefaultValueContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DEFAULT
/// Returns `None` if there is no child corresponding to token DEFAULT
fn DEFAULT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DEFAULT, 0)
}
fn elementValue(&self) -> Option<Rc<ElementValueContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DefaultValueContextAttrs<'input> for DefaultValueContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn defaultValue(&mut self,)
	-> Result<Rc<DefaultValueContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DefaultValueContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 252, RULE_defaultValue);
        let mut _localctx: Rc<DefaultValueContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1596);
			recog.base.match_token(DEFAULT,&mut recog.err_handler)?;

			/*InvokeRule elementValue*/
			recog.base.set_state(1597);
			recog.elementValue()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotation ----------------
pub type AnnotationContextAll<'input> = AnnotationContext<'input>;


pub type AnnotationContext<'input> = BaseParserRuleContext<'input,AnnotationContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for AnnotationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for AnnotationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_annotation(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_annotation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for AnnotationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_annotation(self);
	}
}

impl<'input> CustomRuleContext<'input> for AnnotationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotation }
}
antlr_rust::tid!{AnnotationContextExt<'a>}

impl<'input> AnnotationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<AnnotationContextExt<'input>>{

fn normalAnnotation(&self) -> Option<Rc<NormalAnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn markerAnnotation(&self) -> Option<Rc<MarkerAnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn singleElementAnnotation(&self) -> Option<Rc<SingleElementAnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AnnotationContextAttrs<'input> for AnnotationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotation(&mut self,)
	-> Result<Rc<AnnotationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 254, RULE_annotation);
        let mut _localctx: Rc<AnnotationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1602);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(170,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule normalAnnotation*/
					recog.base.set_state(1599);
					recog.normalAnnotation()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule markerAnnotation*/
					recog.base.set_state(1600);
					recog.markerAnnotation()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule singleElementAnnotation*/
					recog.base.set_state(1601);
					recog.singleElementAnnotation()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- normalAnnotation ----------------
pub type NormalAnnotationContextAll<'input> = NormalAnnotationContext<'input>;


pub type NormalAnnotationContext<'input> = BaseParserRuleContext<'input,NormalAnnotationContextExt<'input>>;

#[derive(Clone)]
pub struct NormalAnnotationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for NormalAnnotationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for NormalAnnotationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_normalAnnotation(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_normalAnnotation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for NormalAnnotationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_normalAnnotation(self);
	}
}

impl<'input> CustomRuleContext<'input> for NormalAnnotationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_normalAnnotation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_normalAnnotation }
}
antlr_rust::tid!{NormalAnnotationContextExt<'a>}

impl<'input> NormalAnnotationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NormalAnnotationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NormalAnnotationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NormalAnnotationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<NormalAnnotationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token AT
/// Returns `None` if there is no child corresponding to token AT
fn AT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(AT, 0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn elementValuePairList(&self) -> Option<Rc<ElementValuePairListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NormalAnnotationContextAttrs<'input> for NormalAnnotationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn normalAnnotation(&mut self,)
	-> Result<Rc<NormalAnnotationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NormalAnnotationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 256, RULE_normalAnnotation);
        let mut _localctx: Rc<NormalAnnotationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1604);
			recog.base.match_token(AT,&mut recog.err_handler)?;

			/*InvokeRule typeName*/
			recog.base.set_state(1605);
			recog.typeName()?;

			recog.base.set_state(1606);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1608);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Identifier {
				{
				/*InvokeRule elementValuePairList*/
				recog.base.set_state(1607);
				recog.elementValuePairList()?;

				}
			}

			recog.base.set_state(1610);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- elementValuePairList ----------------
pub type ElementValuePairListContextAll<'input> = ElementValuePairListContext<'input>;


pub type ElementValuePairListContext<'input> = BaseParserRuleContext<'input,ElementValuePairListContextExt<'input>>;

#[derive(Clone)]
pub struct ElementValuePairListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ElementValuePairListContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ElementValuePairListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_elementValuePairList(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_elementValuePairList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ElementValuePairListContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_elementValuePairList(self);
	}
}

impl<'input> CustomRuleContext<'input> for ElementValuePairListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_elementValuePairList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_elementValuePairList }
}
antlr_rust::tid!{ElementValuePairListContextExt<'a>}

impl<'input> ElementValuePairListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ElementValuePairListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ElementValuePairListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ElementValuePairListContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ElementValuePairListContextExt<'input>>{

fn elementValuePair_all(&self) ->  Vec<Rc<ElementValuePairContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn elementValuePair(&self, i: usize) -> Option<Rc<ElementValuePairContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> ElementValuePairListContextAttrs<'input> for ElementValuePairListContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn elementValuePairList(&mut self,)
	-> Result<Rc<ElementValuePairListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ElementValuePairListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 258, RULE_elementValuePairList);
        let mut _localctx: Rc<ElementValuePairListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule elementValuePair*/
			recog.base.set_state(1612);
			recog.elementValuePair()?;

			recog.base.set_state(1617);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				recog.base.set_state(1613);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				/*InvokeRule elementValuePair*/
				recog.base.set_state(1614);
				recog.elementValuePair()?;

				}
				}
				recog.base.set_state(1619);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- elementValuePair ----------------
pub type ElementValuePairContextAll<'input> = ElementValuePairContext<'input>;


pub type ElementValuePairContext<'input> = BaseParserRuleContext<'input,ElementValuePairContextExt<'input>>;

#[derive(Clone)]
pub struct ElementValuePairContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ElementValuePairContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ElementValuePairContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_elementValuePair(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_elementValuePair(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ElementValuePairContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_elementValuePair(self);
	}
}

impl<'input> CustomRuleContext<'input> for ElementValuePairContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_elementValuePair }
	//fn type_rule_index() -> usize where Self: Sized { RULE_elementValuePair }
}
antlr_rust::tid!{ElementValuePairContextExt<'a>}

impl<'input> ElementValuePairContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ElementValuePairContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ElementValuePairContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ElementValuePairContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ElementValuePairContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
/// Retrieves first TerminalNode corresponding to token ASSIGN
/// Returns `None` if there is no child corresponding to token ASSIGN
fn ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(ASSIGN, 0)
}
fn elementValue(&self) -> Option<Rc<ElementValueContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ElementValuePairContextAttrs<'input> for ElementValuePairContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn elementValuePair(&mut self,)
	-> Result<Rc<ElementValuePairContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ElementValuePairContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 260, RULE_elementValuePair);
        let mut _localctx: Rc<ElementValuePairContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1620);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			recog.base.set_state(1621);
			recog.base.match_token(ASSIGN,&mut recog.err_handler)?;

			/*InvokeRule elementValue*/
			recog.base.set_state(1622);
			recog.elementValue()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- elementValue ----------------
pub type ElementValueContextAll<'input> = ElementValueContext<'input>;


pub type ElementValueContext<'input> = BaseParserRuleContext<'input,ElementValueContextExt<'input>>;

#[derive(Clone)]
pub struct ElementValueContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ElementValueContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ElementValueContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_elementValue(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_elementValue(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ElementValueContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_elementValue(self);
	}
}

impl<'input> CustomRuleContext<'input> for ElementValueContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_elementValue }
	//fn type_rule_index() -> usize where Self: Sized { RULE_elementValue }
}
antlr_rust::tid!{ElementValueContextExt<'a>}

impl<'input> ElementValueContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ElementValueContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ElementValueContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ElementValueContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ElementValueContextExt<'input>>{

fn conditionalExpression(&self) -> Option<Rc<ConditionalExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn elementValueArrayInitializer(&self) -> Option<Rc<ElementValueArrayInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ElementValueContextAttrs<'input> for ElementValueContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn elementValue(&mut self,)
	-> Result<Rc<ElementValueContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ElementValueContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 262, RULE_elementValue);
        let mut _localctx: Rc<ElementValueContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1627);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(173,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule conditionalExpression*/
					recog.base.set_state(1624);
					recog.conditionalExpression()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule elementValueArrayInitializer*/
					recog.base.set_state(1625);
					recog.elementValueArrayInitializer()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(1626);
					recog.annotation()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- elementValueArrayInitializer ----------------
pub type ElementValueArrayInitializerContextAll<'input> = ElementValueArrayInitializerContext<'input>;


pub type ElementValueArrayInitializerContext<'input> = BaseParserRuleContext<'input,ElementValueArrayInitializerContextExt<'input>>;

#[derive(Clone)]
pub struct ElementValueArrayInitializerContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ElementValueArrayInitializerContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ElementValueArrayInitializerContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_elementValueArrayInitializer(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_elementValueArrayInitializer(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ElementValueArrayInitializerContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_elementValueArrayInitializer(self);
	}
}

impl<'input> CustomRuleContext<'input> for ElementValueArrayInitializerContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_elementValueArrayInitializer }
	//fn type_rule_index() -> usize where Self: Sized { RULE_elementValueArrayInitializer }
}
antlr_rust::tid!{ElementValueArrayInitializerContextExt<'a>}

impl<'input> ElementValueArrayInitializerContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ElementValueArrayInitializerContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ElementValueArrayInitializerContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ElementValueArrayInitializerContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ElementValueArrayInitializerContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}
fn elementValueList(&self) -> Option<Rc<ElementValueListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}

}

impl<'input> ElementValueArrayInitializerContextAttrs<'input> for ElementValueArrayInitializerContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn elementValueArrayInitializer(&mut self,)
	-> Result<Rc<ElementValueArrayInitializerContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ElementValueArrayInitializerContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 264, RULE_elementValueArrayInitializer);
        let mut _localctx: Rc<ElementValueArrayInitializerContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1629);
			recog.base.match_token(LBRACE,&mut recog.err_handler)?;

			recog.base.set_state(1631);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (FLOAT - 37)) | (1usize << (INT - 37)) | (1usize << (LONG - 37)) | (1usize << (NEW - 37)) | (1usize << (SHORT - 37)) | (1usize << (SUPER - 37)) | (1usize << (SWITCH - 37)) | (1usize << (THIS - 37)) | (1usize << (VOID - 37)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (LBRACE - 69)) | (1usize << (AT - 69)) | (1usize << (BANG - 69)) | (1usize << (TILDE - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (ADD - 102)) | (1usize << (SUB - 102)) | (1usize << (Identifier - 102)))) != 0) {
				{
				/*InvokeRule elementValueList*/
				recog.base.set_state(1630);
				recog.elementValueList()?;

				}
			}

			recog.base.set_state(1634);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COMMA {
				{
				recog.base.set_state(1633);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(1636);
			recog.base.match_token(RBRACE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- elementValueList ----------------
pub type ElementValueListContextAll<'input> = ElementValueListContext<'input>;


pub type ElementValueListContext<'input> = BaseParserRuleContext<'input,ElementValueListContextExt<'input>>;

#[derive(Clone)]
pub struct ElementValueListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ElementValueListContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ElementValueListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_elementValueList(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_elementValueList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ElementValueListContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_elementValueList(self);
	}
}

impl<'input> CustomRuleContext<'input> for ElementValueListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_elementValueList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_elementValueList }
}
antlr_rust::tid!{ElementValueListContextExt<'a>}

impl<'input> ElementValueListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ElementValueListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ElementValueListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ElementValueListContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ElementValueListContextExt<'input>>{

fn elementValue_all(&self) ->  Vec<Rc<ElementValueContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn elementValue(&self, i: usize) -> Option<Rc<ElementValueContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> ElementValueListContextAttrs<'input> for ElementValueListContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn elementValueList(&mut self,)
	-> Result<Rc<ElementValueListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ElementValueListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 266, RULE_elementValueList);
        let mut _localctx: Rc<ElementValueListContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule elementValue*/
			recog.base.set_state(1638);
			recog.elementValue()?;

			recog.base.set_state(1643);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(176,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1639);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule elementValue*/
					recog.base.set_state(1640);
					recog.elementValue()?;

					}
					} 
				}
				recog.base.set_state(1645);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(176,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- markerAnnotation ----------------
pub type MarkerAnnotationContextAll<'input> = MarkerAnnotationContext<'input>;


pub type MarkerAnnotationContext<'input> = BaseParserRuleContext<'input,MarkerAnnotationContextExt<'input>>;

#[derive(Clone)]
pub struct MarkerAnnotationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for MarkerAnnotationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for MarkerAnnotationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_markerAnnotation(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_markerAnnotation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for MarkerAnnotationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_markerAnnotation(self);
	}
}

impl<'input> CustomRuleContext<'input> for MarkerAnnotationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_markerAnnotation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_markerAnnotation }
}
antlr_rust::tid!{MarkerAnnotationContextExt<'a>}

impl<'input> MarkerAnnotationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MarkerAnnotationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MarkerAnnotationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MarkerAnnotationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<MarkerAnnotationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token AT
/// Returns `None` if there is no child corresponding to token AT
fn AT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(AT, 0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MarkerAnnotationContextAttrs<'input> for MarkerAnnotationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn markerAnnotation(&mut self,)
	-> Result<Rc<MarkerAnnotationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MarkerAnnotationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 268, RULE_markerAnnotation);
        let mut _localctx: Rc<MarkerAnnotationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1646);
			recog.base.match_token(AT,&mut recog.err_handler)?;

			/*InvokeRule typeName*/
			recog.base.set_state(1647);
			recog.typeName()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- singleElementAnnotation ----------------
pub type SingleElementAnnotationContextAll<'input> = SingleElementAnnotationContext<'input>;


pub type SingleElementAnnotationContext<'input> = BaseParserRuleContext<'input,SingleElementAnnotationContextExt<'input>>;

#[derive(Clone)]
pub struct SingleElementAnnotationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for SingleElementAnnotationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for SingleElementAnnotationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_singleElementAnnotation(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_singleElementAnnotation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for SingleElementAnnotationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_singleElementAnnotation(self);
	}
}

impl<'input> CustomRuleContext<'input> for SingleElementAnnotationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_singleElementAnnotation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_singleElementAnnotation }
}
antlr_rust::tid!{SingleElementAnnotationContextExt<'a>}

impl<'input> SingleElementAnnotationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SingleElementAnnotationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SingleElementAnnotationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SingleElementAnnotationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<SingleElementAnnotationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token AT
/// Returns `None` if there is no child corresponding to token AT
fn AT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(AT, 0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn elementValue(&self) -> Option<Rc<ElementValueContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}

}

impl<'input> SingleElementAnnotationContextAttrs<'input> for SingleElementAnnotationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn singleElementAnnotation(&mut self,)
	-> Result<Rc<SingleElementAnnotationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SingleElementAnnotationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 270, RULE_singleElementAnnotation);
        let mut _localctx: Rc<SingleElementAnnotationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1649);
			recog.base.match_token(AT,&mut recog.err_handler)?;

			/*InvokeRule typeName*/
			recog.base.set_state(1650);
			recog.typeName()?;

			recog.base.set_state(1651);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule elementValue*/
			recog.base.set_state(1652);
			recog.elementValue()?;

			recog.base.set_state(1653);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- arrayInitializer ----------------
pub type ArrayInitializerContextAll<'input> = ArrayInitializerContext<'input>;


pub type ArrayInitializerContext<'input> = BaseParserRuleContext<'input,ArrayInitializerContextExt<'input>>;

#[derive(Clone)]
pub struct ArrayInitializerContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ArrayInitializerContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ArrayInitializerContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_arrayInitializer(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_arrayInitializer(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ArrayInitializerContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_arrayInitializer(self);
	}
}

impl<'input> CustomRuleContext<'input> for ArrayInitializerContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_arrayInitializer }
	//fn type_rule_index() -> usize where Self: Sized { RULE_arrayInitializer }
}
antlr_rust::tid!{ArrayInitializerContextExt<'a>}

impl<'input> ArrayInitializerContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ArrayInitializerContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ArrayInitializerContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ArrayInitializerContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ArrayInitializerContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}
fn variableInitializerList(&self) -> Option<Rc<VariableInitializerListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}

}

impl<'input> ArrayInitializerContextAttrs<'input> for ArrayInitializerContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn arrayInitializer(&mut self,)
	-> Result<Rc<ArrayInitializerContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ArrayInitializerContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 272, RULE_arrayInitializer);
        let mut _localctx: Rc<ArrayInitializerContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1655);
			recog.base.match_token(LBRACE,&mut recog.err_handler)?;

			recog.base.set_state(1657);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (FLOAT - 37)) | (1usize << (INT - 37)) | (1usize << (LONG - 37)) | (1usize << (NEW - 37)) | (1usize << (SHORT - 37)) | (1usize << (SUPER - 37)) | (1usize << (SWITCH - 37)) | (1usize << (THIS - 37)) | (1usize << (VOID - 37)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (LBRACE - 69)) | (1usize << (AT - 69)) | (1usize << (BANG - 69)) | (1usize << (TILDE - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (ADD - 102)) | (1usize << (SUB - 102)) | (1usize << (Identifier - 102)))) != 0) {
				{
				/*InvokeRule variableInitializerList*/
				recog.base.set_state(1656);
				recog.variableInitializerList()?;

				}
			}

			recog.base.set_state(1660);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COMMA {
				{
				recog.base.set_state(1659);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(1662);
			recog.base.match_token(RBRACE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- variableInitializerList ----------------
pub type VariableInitializerListContextAll<'input> = VariableInitializerListContext<'input>;


pub type VariableInitializerListContext<'input> = BaseParserRuleContext<'input,VariableInitializerListContextExt<'input>>;

#[derive(Clone)]
pub struct VariableInitializerListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for VariableInitializerListContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for VariableInitializerListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_variableInitializerList(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_variableInitializerList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for VariableInitializerListContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_variableInitializerList(self);
	}
}

impl<'input> CustomRuleContext<'input> for VariableInitializerListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_variableInitializerList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_variableInitializerList }
}
antlr_rust::tid!{VariableInitializerListContextExt<'a>}

impl<'input> VariableInitializerListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VariableInitializerListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VariableInitializerListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VariableInitializerListContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<VariableInitializerListContextExt<'input>>{

fn variableInitializer_all(&self) ->  Vec<Rc<VariableInitializerContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn variableInitializer(&self, i: usize) -> Option<Rc<VariableInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> VariableInitializerListContextAttrs<'input> for VariableInitializerListContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn variableInitializerList(&mut self,)
	-> Result<Rc<VariableInitializerListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VariableInitializerListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 274, RULE_variableInitializerList);
        let mut _localctx: Rc<VariableInitializerListContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule variableInitializer*/
			recog.base.set_state(1664);
			recog.variableInitializer()?;

			recog.base.set_state(1669);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(179,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1665);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule variableInitializer*/
					recog.base.set_state(1666);
					recog.variableInitializer()?;

					}
					} 
				}
				recog.base.set_state(1671);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(179,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- block ----------------
pub type BlockContextAll<'input> = BlockContext<'input>;


pub type BlockContext<'input> = BaseParserRuleContext<'input,BlockContextExt<'input>>;

#[derive(Clone)]
pub struct BlockContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for BlockContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for BlockContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_block(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_block(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for BlockContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_block(self);
	}
}

impl<'input> CustomRuleContext<'input> for BlockContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_block }
	//fn type_rule_index() -> usize where Self: Sized { RULE_block }
}
antlr_rust::tid!{BlockContextExt<'a>}

impl<'input> BlockContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BlockContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BlockContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BlockContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<BlockContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}
fn blockStatements(&self) -> Option<Rc<BlockStatementsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> BlockContextAttrs<'input> for BlockContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn block(&mut self,)
	-> Result<Rc<BlockContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BlockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 276, RULE_block);
        let mut _localctx: Rc<BlockContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1672);
			recog.base.match_token(LBRACE,&mut recog.err_handler)?;

			recog.base.set_state(1674);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << NONSEALED) | (1usize << RECORD) | (1usize << SEALED) | (1usize << VAR) | (1usize << YIELD) | (1usize << ABSTRACT) | (1usize << ASSERT) | (1usize << BOOLEAN) | (1usize << BREAK) | (1usize << BYTE) | (1usize << CHAR) | (1usize << CLASS) | (1usize << CONTINUE) | (1usize << DO) | (1usize << DOUBLE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (ENUM - 33)) | (1usize << (FINAL - 33)) | (1usize << (FLOAT - 33)) | (1usize << (FOR - 33)) | (1usize << (IF - 33)) | (1usize << (INT - 33)) | (1usize << (INTERFACE - 33)) | (1usize << (LONG - 33)) | (1usize << (NEW - 33)) | (1usize << (PRIVATE - 33)) | (1usize << (PROTECTED - 33)) | (1usize << (PUBLIC - 33)) | (1usize << (RETURN - 33)) | (1usize << (SHORT - 33)) | (1usize << (STATIC - 33)) | (1usize << (STRICTFP - 33)) | (1usize << (SUPER - 33)) | (1usize << (SWITCH - 33)) | (1usize << (SYNCHRONIZED - 33)) | (1usize << (THIS - 33)) | (1usize << (THROW - 33)) | (1usize << (TRY - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (VOID - 65)) | (1usize << (WHILE - 65)) | (1usize << (IntegerLiteral - 65)) | (1usize << (FloatingPointLiteral - 65)) | (1usize << (BooleanLiteral - 65)) | (1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (TextBlock - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (LBRACE - 65)) | (1usize << (SEMI - 65)) | (1usize << (AT - 65)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (Identifier - 102)))) != 0) {
				{
				/*InvokeRule blockStatements*/
				recog.base.set_state(1673);
				recog.blockStatements()?;

				}
			}

			recog.base.set_state(1676);
			recog.base.match_token(RBRACE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- blockStatements ----------------
pub type BlockStatementsContextAll<'input> = BlockStatementsContext<'input>;


pub type BlockStatementsContext<'input> = BaseParserRuleContext<'input,BlockStatementsContextExt<'input>>;

#[derive(Clone)]
pub struct BlockStatementsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for BlockStatementsContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for BlockStatementsContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_blockStatements(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_blockStatements(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for BlockStatementsContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_blockStatements(self);
	}
}

impl<'input> CustomRuleContext<'input> for BlockStatementsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_blockStatements }
	//fn type_rule_index() -> usize where Self: Sized { RULE_blockStatements }
}
antlr_rust::tid!{BlockStatementsContextExt<'a>}

impl<'input> BlockStatementsContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BlockStatementsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BlockStatementsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BlockStatementsContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<BlockStatementsContextExt<'input>>{

fn blockStatement_all(&self) ->  Vec<Rc<BlockStatementContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn blockStatement(&self, i: usize) -> Option<Rc<BlockStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> BlockStatementsContextAttrs<'input> for BlockStatementsContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn blockStatements(&mut self,)
	-> Result<Rc<BlockStatementsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BlockStatementsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 278, RULE_blockStatements);
        let mut _localctx: Rc<BlockStatementsContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule blockStatement*/
			recog.base.set_state(1678);
			recog.blockStatement()?;

			recog.base.set_state(1682);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << NONSEALED) | (1usize << RECORD) | (1usize << SEALED) | (1usize << VAR) | (1usize << YIELD) | (1usize << ABSTRACT) | (1usize << ASSERT) | (1usize << BOOLEAN) | (1usize << BREAK) | (1usize << BYTE) | (1usize << CHAR) | (1usize << CLASS) | (1usize << CONTINUE) | (1usize << DO) | (1usize << DOUBLE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (ENUM - 33)) | (1usize << (FINAL - 33)) | (1usize << (FLOAT - 33)) | (1usize << (FOR - 33)) | (1usize << (IF - 33)) | (1usize << (INT - 33)) | (1usize << (INTERFACE - 33)) | (1usize << (LONG - 33)) | (1usize << (NEW - 33)) | (1usize << (PRIVATE - 33)) | (1usize << (PROTECTED - 33)) | (1usize << (PUBLIC - 33)) | (1usize << (RETURN - 33)) | (1usize << (SHORT - 33)) | (1usize << (STATIC - 33)) | (1usize << (STRICTFP - 33)) | (1usize << (SUPER - 33)) | (1usize << (SWITCH - 33)) | (1usize << (SYNCHRONIZED - 33)) | (1usize << (THIS - 33)) | (1usize << (THROW - 33)) | (1usize << (TRY - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (VOID - 65)) | (1usize << (WHILE - 65)) | (1usize << (IntegerLiteral - 65)) | (1usize << (FloatingPointLiteral - 65)) | (1usize << (BooleanLiteral - 65)) | (1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (TextBlock - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (LBRACE - 65)) | (1usize << (SEMI - 65)) | (1usize << (AT - 65)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (Identifier - 102)))) != 0) {
				{
				{
				/*InvokeRule blockStatement*/
				recog.base.set_state(1679);
				recog.blockStatement()?;

				}
				}
				recog.base.set_state(1684);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- blockStatement ----------------
pub type BlockStatementContextAll<'input> = BlockStatementContext<'input>;


pub type BlockStatementContext<'input> = BaseParserRuleContext<'input,BlockStatementContextExt<'input>>;

#[derive(Clone)]
pub struct BlockStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for BlockStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for BlockStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_blockStatement(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_blockStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for BlockStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_blockStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for BlockStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_blockStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_blockStatement }
}
antlr_rust::tid!{BlockStatementContextExt<'a>}

impl<'input> BlockStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BlockStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BlockStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BlockStatementContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<BlockStatementContextExt<'input>>{

fn localClassOrInterfaceDeclaration(&self) -> Option<Rc<LocalClassOrInterfaceDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn localVariableDeclarationStatement(&self) -> Option<Rc<LocalVariableDeclarationStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn statement(&self) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> BlockStatementContextAttrs<'input> for BlockStatementContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn blockStatement(&mut self,)
	-> Result<Rc<BlockStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BlockStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 280, RULE_blockStatement);
        let mut _localctx: Rc<BlockStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1688);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(182,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule localClassOrInterfaceDeclaration*/
					recog.base.set_state(1685);
					recog.localClassOrInterfaceDeclaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule localVariableDeclarationStatement*/
					recog.base.set_state(1686);
					recog.localVariableDeclarationStatement()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule statement*/
					recog.base.set_state(1687);
					recog.statement()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- localClassOrInterfaceDeclaration ----------------
pub type LocalClassOrInterfaceDeclarationContextAll<'input> = LocalClassOrInterfaceDeclarationContext<'input>;


pub type LocalClassOrInterfaceDeclarationContext<'input> = BaseParserRuleContext<'input,LocalClassOrInterfaceDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct LocalClassOrInterfaceDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for LocalClassOrInterfaceDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for LocalClassOrInterfaceDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_localClassOrInterfaceDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_localClassOrInterfaceDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for LocalClassOrInterfaceDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_localClassOrInterfaceDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for LocalClassOrInterfaceDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_localClassOrInterfaceDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_localClassOrInterfaceDeclaration }
}
antlr_rust::tid!{LocalClassOrInterfaceDeclarationContextExt<'a>}

impl<'input> LocalClassOrInterfaceDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LocalClassOrInterfaceDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LocalClassOrInterfaceDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LocalClassOrInterfaceDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<LocalClassOrInterfaceDeclarationContextExt<'input>>{

fn classDeclaration(&self) -> Option<Rc<ClassDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn normalInterfaceDeclaration(&self) -> Option<Rc<NormalInterfaceDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LocalClassOrInterfaceDeclarationContextAttrs<'input> for LocalClassOrInterfaceDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn localClassOrInterfaceDeclaration(&mut self,)
	-> Result<Rc<LocalClassOrInterfaceDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LocalClassOrInterfaceDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 282, RULE_localClassOrInterfaceDeclaration);
        let mut _localctx: Rc<LocalClassOrInterfaceDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1692);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(183,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule classDeclaration*/
					recog.base.set_state(1690);
					recog.classDeclaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule normalInterfaceDeclaration*/
					recog.base.set_state(1691);
					recog.normalInterfaceDeclaration()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- localVariableDeclaration ----------------
pub type LocalVariableDeclarationContextAll<'input> = LocalVariableDeclarationContext<'input>;


pub type LocalVariableDeclarationContext<'input> = BaseParserRuleContext<'input,LocalVariableDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct LocalVariableDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for LocalVariableDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for LocalVariableDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_localVariableDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_localVariableDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for LocalVariableDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_localVariableDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for LocalVariableDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_localVariableDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_localVariableDeclaration }
}
antlr_rust::tid!{LocalVariableDeclarationContextExt<'a>}

impl<'input> LocalVariableDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LocalVariableDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LocalVariableDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LocalVariableDeclarationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<LocalVariableDeclarationContextExt<'input>>{

fn localVariableType(&self) -> Option<Rc<LocalVariableTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableModifier_all(&self) ->  Vec<Rc<VariableModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn variableModifier(&self, i: usize) -> Option<Rc<VariableModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn variableDeclaratorList(&self) -> Option<Rc<VariableDeclaratorListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LocalVariableDeclarationContextAttrs<'input> for LocalVariableDeclarationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn localVariableDeclaration(&mut self,)
	-> Result<Rc<LocalVariableDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LocalVariableDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 284, RULE_localVariableDeclaration);
        let mut _localctx: Rc<LocalVariableDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1697);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==FINAL || _la==AT {
				{
				{
				/*InvokeRule variableModifier*/
				recog.base.set_state(1694);
				recog.variableModifier()?;

				}
				}
				recog.base.set_state(1699);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule localVariableType*/
			recog.base.set_state(1700);
			recog.localVariableType()?;

			recog.base.set_state(1702);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(185,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule variableDeclaratorList*/
					recog.base.set_state(1701);
					recog.variableDeclaratorList()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- localVariableType ----------------
pub type LocalVariableTypeContextAll<'input> = LocalVariableTypeContext<'input>;


pub type LocalVariableTypeContext<'input> = BaseParserRuleContext<'input,LocalVariableTypeContextExt<'input>>;

#[derive(Clone)]
pub struct LocalVariableTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for LocalVariableTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for LocalVariableTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_localVariableType(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_localVariableType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for LocalVariableTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_localVariableType(self);
	}
}

impl<'input> CustomRuleContext<'input> for LocalVariableTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_localVariableType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_localVariableType }
}
antlr_rust::tid!{LocalVariableTypeContextExt<'a>}

impl<'input> LocalVariableTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LocalVariableTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LocalVariableTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LocalVariableTypeContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<LocalVariableTypeContextExt<'input>>{

fn unannType(&self) -> Option<Rc<UnannTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token VAR
/// Returns `None` if there is no child corresponding to token VAR
fn VAR(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(VAR, 0)
}

}

impl<'input> LocalVariableTypeContextAttrs<'input> for LocalVariableTypeContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn localVariableType(&mut self,)
	-> Result<Rc<LocalVariableTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LocalVariableTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 286, RULE_localVariableType);
        let mut _localctx: Rc<LocalVariableTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1706);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 BOOLEAN | BYTE | CHAR | DOUBLE | FLOAT | INT | LONG | SHORT | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule unannType*/
					recog.base.set_state(1704);
					recog.unannType()?;

					}
				}

			 VAR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1705);
					recog.base.match_token(VAR,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- localVariableDeclarationStatement ----------------
pub type LocalVariableDeclarationStatementContextAll<'input> = LocalVariableDeclarationStatementContext<'input>;


pub type LocalVariableDeclarationStatementContext<'input> = BaseParserRuleContext<'input,LocalVariableDeclarationStatementContextExt<'input>>;

#[derive(Clone)]
pub struct LocalVariableDeclarationStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for LocalVariableDeclarationStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for LocalVariableDeclarationStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_localVariableDeclarationStatement(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_localVariableDeclarationStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for LocalVariableDeclarationStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_localVariableDeclarationStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for LocalVariableDeclarationStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_localVariableDeclarationStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_localVariableDeclarationStatement }
}
antlr_rust::tid!{LocalVariableDeclarationStatementContextExt<'a>}

impl<'input> LocalVariableDeclarationStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LocalVariableDeclarationStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LocalVariableDeclarationStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LocalVariableDeclarationStatementContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<LocalVariableDeclarationStatementContextExt<'input>>{

fn localVariableDeclaration(&self) -> Option<Rc<LocalVariableDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> LocalVariableDeclarationStatementContextAttrs<'input> for LocalVariableDeclarationStatementContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn localVariableDeclarationStatement(&mut self,)
	-> Result<Rc<LocalVariableDeclarationStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LocalVariableDeclarationStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 288, RULE_localVariableDeclarationStatement);
        let mut _localctx: Rc<LocalVariableDeclarationStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule localVariableDeclaration*/
			recog.base.set_state(1708);
			recog.localVariableDeclaration()?;

			recog.base.set_state(1709);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- statement ----------------
pub type StatementContextAll<'input> = StatementContext<'input>;


pub type StatementContext<'input> = BaseParserRuleContext<'input,StatementContextExt<'input>>;

#[derive(Clone)]
pub struct StatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for StatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for StatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_statement(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_statement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for StatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_statement(self);
	}
}

impl<'input> CustomRuleContext<'input> for StatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}
antlr_rust::tid!{StatementContextExt<'a>}

impl<'input> StatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StatementContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<StatementContextExt<'input>>{

fn statementWithoutTrailingSubstatement(&self) -> Option<Rc<StatementWithoutTrailingSubstatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn labeledStatement(&self) -> Option<Rc<LabeledStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifThenStatement(&self) -> Option<Rc<IfThenStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifThenElseStatement(&self) -> Option<Rc<IfThenElseStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn whileStatement(&self) -> Option<Rc<WhileStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn forStatement(&self) -> Option<Rc<ForStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> StatementContextAttrs<'input> for StatementContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn statement(&mut self,)
	-> Result<Rc<StatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 290, RULE_statement);
        let mut _localctx: Rc<StatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1717);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(187,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule statementWithoutTrailingSubstatement*/
					recog.base.set_state(1711);
					recog.statementWithoutTrailingSubstatement()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule labeledStatement*/
					recog.base.set_state(1712);
					recog.labeledStatement()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule ifThenStatement*/
					recog.base.set_state(1713);
					recog.ifThenStatement()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule ifThenElseStatement*/
					recog.base.set_state(1714);
					recog.ifThenElseStatement()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule whileStatement*/
					recog.base.set_state(1715);
					recog.whileStatement()?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule forStatement*/
					recog.base.set_state(1716);
					recog.forStatement()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- statementNoShortIf ----------------
pub type StatementNoShortIfContextAll<'input> = StatementNoShortIfContext<'input>;


pub type StatementNoShortIfContext<'input> = BaseParserRuleContext<'input,StatementNoShortIfContextExt<'input>>;

#[derive(Clone)]
pub struct StatementNoShortIfContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for StatementNoShortIfContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for StatementNoShortIfContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_statementNoShortIf(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_statementNoShortIf(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for StatementNoShortIfContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_statementNoShortIf(self);
	}
}

impl<'input> CustomRuleContext<'input> for StatementNoShortIfContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statementNoShortIf }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statementNoShortIf }
}
antlr_rust::tid!{StatementNoShortIfContextExt<'a>}

impl<'input> StatementNoShortIfContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StatementNoShortIfContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StatementNoShortIfContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StatementNoShortIfContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<StatementNoShortIfContextExt<'input>>{

fn statementWithoutTrailingSubstatement(&self) -> Option<Rc<StatementWithoutTrailingSubstatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn labeledStatementNoShortIf(&self) -> Option<Rc<LabeledStatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifThenElseStatementNoShortIf(&self) -> Option<Rc<IfThenElseStatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn whileStatementNoShortIf(&self) -> Option<Rc<WhileStatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn forStatementNoShortIf(&self) -> Option<Rc<ForStatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> StatementNoShortIfContextAttrs<'input> for StatementNoShortIfContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn statementNoShortIf(&mut self,)
	-> Result<Rc<StatementNoShortIfContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StatementNoShortIfContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 292, RULE_statementNoShortIf);
        let mut _localctx: Rc<StatementNoShortIfContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1724);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(188,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule statementWithoutTrailingSubstatement*/
					recog.base.set_state(1719);
					recog.statementWithoutTrailingSubstatement()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule labeledStatementNoShortIf*/
					recog.base.set_state(1720);
					recog.labeledStatementNoShortIf()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule ifThenElseStatementNoShortIf*/
					recog.base.set_state(1721);
					recog.ifThenElseStatementNoShortIf()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule whileStatementNoShortIf*/
					recog.base.set_state(1722);
					recog.whileStatementNoShortIf()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule forStatementNoShortIf*/
					recog.base.set_state(1723);
					recog.forStatementNoShortIf()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- statementWithoutTrailingSubstatement ----------------
pub type StatementWithoutTrailingSubstatementContextAll<'input> = StatementWithoutTrailingSubstatementContext<'input>;


pub type StatementWithoutTrailingSubstatementContext<'input> = BaseParserRuleContext<'input,StatementWithoutTrailingSubstatementContextExt<'input>>;

#[derive(Clone)]
pub struct StatementWithoutTrailingSubstatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for StatementWithoutTrailingSubstatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for StatementWithoutTrailingSubstatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_statementWithoutTrailingSubstatement(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_statementWithoutTrailingSubstatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for StatementWithoutTrailingSubstatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_statementWithoutTrailingSubstatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for StatementWithoutTrailingSubstatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statementWithoutTrailingSubstatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statementWithoutTrailingSubstatement }
}
antlr_rust::tid!{StatementWithoutTrailingSubstatementContextExt<'a>}

impl<'input> StatementWithoutTrailingSubstatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StatementWithoutTrailingSubstatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StatementWithoutTrailingSubstatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StatementWithoutTrailingSubstatementContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<StatementWithoutTrailingSubstatementContextExt<'input>>{

fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn emptyStatement(&self) -> Option<Rc<EmptyStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expressionStatement(&self) -> Option<Rc<ExpressionStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn assertStatement(&self) -> Option<Rc<AssertStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn switchStatement(&self) -> Option<Rc<SwitchStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn doStatement(&self) -> Option<Rc<DoStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn breakStatement(&self) -> Option<Rc<BreakStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn continueStatement(&self) -> Option<Rc<ContinueStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn returnStatement(&self) -> Option<Rc<ReturnStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn synchronizedStatement(&self) -> Option<Rc<SynchronizedStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn throwStatement(&self) -> Option<Rc<ThrowStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn tryStatement(&self) -> Option<Rc<TryStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn yieldStatement(&self) -> Option<Rc<YieldStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> StatementWithoutTrailingSubstatementContextAttrs<'input> for StatementWithoutTrailingSubstatementContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn statementWithoutTrailingSubstatement(&mut self,)
	-> Result<Rc<StatementWithoutTrailingSubstatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StatementWithoutTrailingSubstatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 294, RULE_statementWithoutTrailingSubstatement);
        let mut _localctx: Rc<StatementWithoutTrailingSubstatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1739);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LBRACE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule block*/
					recog.base.set_state(1726);
					recog.block()?;

					}
				}

			 SEMI 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule emptyStatement*/
					recog.base.set_state(1727);
					recog.emptyStatement()?;

					}
				}

			 BOOLEAN | BYTE | CHAR | DOUBLE | FLOAT | INT | LONG | NEW | SHORT | SUPER |
			 THIS | VOID | IntegerLiteral | FloatingPointLiteral | BooleanLiteral |
			 CharacterLiteral | StringLiteral | TextBlock | NullLiteral | LPAREN |
			 AT | INC | DEC | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule expressionStatement*/
					recog.base.set_state(1728);
					recog.expressionStatement()?;

					}
				}

			 ASSERT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule assertStatement*/
					recog.base.set_state(1729);
					recog.assertStatement()?;

					}
				}

			 SWITCH 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule switchStatement*/
					recog.base.set_state(1730);
					recog.switchStatement()?;

					}
				}

			 DO 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule doStatement*/
					recog.base.set_state(1731);
					recog.doStatement()?;

					}
				}

			 BREAK 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule breakStatement*/
					recog.base.set_state(1732);
					recog.breakStatement()?;

					}
				}

			 CONTINUE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule continueStatement*/
					recog.base.set_state(1733);
					recog.continueStatement()?;

					}
				}

			 RETURN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					/*InvokeRule returnStatement*/
					recog.base.set_state(1734);
					recog.returnStatement()?;

					}
				}

			 SYNCHRONIZED 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					/*InvokeRule synchronizedStatement*/
					recog.base.set_state(1735);
					recog.synchronizedStatement()?;

					}
				}

			 THROW 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 11);
					recog.base.enter_outer_alt(None, 11);
					{
					/*InvokeRule throwStatement*/
					recog.base.set_state(1736);
					recog.throwStatement()?;

					}
				}

			 TRY 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 12);
					recog.base.enter_outer_alt(None, 12);
					{
					/*InvokeRule tryStatement*/
					recog.base.set_state(1737);
					recog.tryStatement()?;

					}
				}

			 YIELD 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 13);
					recog.base.enter_outer_alt(None, 13);
					{
					/*InvokeRule yieldStatement*/
					recog.base.set_state(1738);
					recog.yieldStatement()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- emptyStatement ----------------
pub type EmptyStatementContextAll<'input> = EmptyStatementContext<'input>;


pub type EmptyStatementContext<'input> = BaseParserRuleContext<'input,EmptyStatementContextExt<'input>>;

#[derive(Clone)]
pub struct EmptyStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for EmptyStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for EmptyStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_emptyStatement(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_emptyStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for EmptyStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_emptyStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for EmptyStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_emptyStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_emptyStatement }
}
antlr_rust::tid!{EmptyStatementContextExt<'a>}

impl<'input> EmptyStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EmptyStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EmptyStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EmptyStatementContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<EmptyStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> EmptyStatementContextAttrs<'input> for EmptyStatementContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn emptyStatement(&mut self,)
	-> Result<Rc<EmptyStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EmptyStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 296, RULE_emptyStatement);
        let mut _localctx: Rc<EmptyStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1741);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- labeledStatement ----------------
pub type LabeledStatementContextAll<'input> = LabeledStatementContext<'input>;


pub type LabeledStatementContext<'input> = BaseParserRuleContext<'input,LabeledStatementContextExt<'input>>;

#[derive(Clone)]
pub struct LabeledStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for LabeledStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for LabeledStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_labeledStatement(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_labeledStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for LabeledStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_labeledStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for LabeledStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_labeledStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_labeledStatement }
}
antlr_rust::tid!{LabeledStatementContextExt<'a>}

impl<'input> LabeledStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LabeledStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LabeledStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LabeledStatementContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<LabeledStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn statement(&self) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LabeledStatementContextAttrs<'input> for LabeledStatementContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn labeledStatement(&mut self,)
	-> Result<Rc<LabeledStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LabeledStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 298, RULE_labeledStatement);
        let mut _localctx: Rc<LabeledStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1743);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			recog.base.set_state(1744);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			/*InvokeRule statement*/
			recog.base.set_state(1745);
			recog.statement()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- labeledStatementNoShortIf ----------------
pub type LabeledStatementNoShortIfContextAll<'input> = LabeledStatementNoShortIfContext<'input>;


pub type LabeledStatementNoShortIfContext<'input> = BaseParserRuleContext<'input,LabeledStatementNoShortIfContextExt<'input>>;

#[derive(Clone)]
pub struct LabeledStatementNoShortIfContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for LabeledStatementNoShortIfContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for LabeledStatementNoShortIfContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_labeledStatementNoShortIf(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_labeledStatementNoShortIf(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for LabeledStatementNoShortIfContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_labeledStatementNoShortIf(self);
	}
}

impl<'input> CustomRuleContext<'input> for LabeledStatementNoShortIfContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_labeledStatementNoShortIf }
	//fn type_rule_index() -> usize where Self: Sized { RULE_labeledStatementNoShortIf }
}
antlr_rust::tid!{LabeledStatementNoShortIfContextExt<'a>}

impl<'input> LabeledStatementNoShortIfContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LabeledStatementNoShortIfContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LabeledStatementNoShortIfContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LabeledStatementNoShortIfContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<LabeledStatementNoShortIfContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn statementNoShortIf(&self) -> Option<Rc<StatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LabeledStatementNoShortIfContextAttrs<'input> for LabeledStatementNoShortIfContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn labeledStatementNoShortIf(&mut self,)
	-> Result<Rc<LabeledStatementNoShortIfContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LabeledStatementNoShortIfContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 300, RULE_labeledStatementNoShortIf);
        let mut _localctx: Rc<LabeledStatementNoShortIfContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1747);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			recog.base.set_state(1748);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			/*InvokeRule statementNoShortIf*/
			recog.base.set_state(1749);
			recog.statementNoShortIf()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- expressionStatement ----------------
pub type ExpressionStatementContextAll<'input> = ExpressionStatementContext<'input>;


pub type ExpressionStatementContext<'input> = BaseParserRuleContext<'input,ExpressionStatementContextExt<'input>>;

#[derive(Clone)]
pub struct ExpressionStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ExpressionStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ExpressionStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_expressionStatement(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_expressionStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ExpressionStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_expressionStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExpressionStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_expressionStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_expressionStatement }
}
antlr_rust::tid!{ExpressionStatementContextExt<'a>}

impl<'input> ExpressionStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExpressionStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExpressionStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExpressionStatementContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ExpressionStatementContextExt<'input>>{

fn statementExpression(&self) -> Option<Rc<StatementExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> ExpressionStatementContextAttrs<'input> for ExpressionStatementContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn expressionStatement(&mut self,)
	-> Result<Rc<ExpressionStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExpressionStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 302, RULE_expressionStatement);
        let mut _localctx: Rc<ExpressionStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule statementExpression*/
			recog.base.set_state(1751);
			recog.statementExpression()?;

			recog.base.set_state(1752);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- statementExpression ----------------
pub type StatementExpressionContextAll<'input> = StatementExpressionContext<'input>;


pub type StatementExpressionContext<'input> = BaseParserRuleContext<'input,StatementExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct StatementExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for StatementExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for StatementExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_statementExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_statementExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for StatementExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_statementExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for StatementExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statementExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statementExpression }
}
antlr_rust::tid!{StatementExpressionContextExt<'a>}

impl<'input> StatementExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StatementExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StatementExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StatementExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<StatementExpressionContextExt<'input>>{

fn assignment(&self) -> Option<Rc<AssignmentContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn preIncrementExpression(&self) -> Option<Rc<PreIncrementExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn preDecrementExpression(&self) -> Option<Rc<PreDecrementExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn postIncrementExpression(&self) -> Option<Rc<PostIncrementExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn postDecrementExpression(&self) -> Option<Rc<PostDecrementExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodInvocation(&self) -> Option<Rc<MethodInvocationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classInstanceCreationExpression(&self) -> Option<Rc<ClassInstanceCreationExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> StatementExpressionContextAttrs<'input> for StatementExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn statementExpression(&mut self,)
	-> Result<Rc<StatementExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StatementExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 304, RULE_statementExpression);
        let mut _localctx: Rc<StatementExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1761);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(190,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule assignment*/
					recog.base.set_state(1754);
					recog.assignment()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule preIncrementExpression*/
					recog.base.set_state(1755);
					recog.preIncrementExpression()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule preDecrementExpression*/
					recog.base.set_state(1756);
					recog.preDecrementExpression()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule postIncrementExpression*/
					recog.base.set_state(1757);
					recog.postIncrementExpression()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule postDecrementExpression*/
					recog.base.set_state(1758);
					recog.postDecrementExpression()?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule methodInvocation*/
					recog.base.set_state(1759);
					recog.methodInvocation()?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule classInstanceCreationExpression*/
					recog.base.set_state(1760);
					recog.classInstanceCreationExpression()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifThenStatement ----------------
pub type IfThenStatementContextAll<'input> = IfThenStatementContext<'input>;


pub type IfThenStatementContext<'input> = BaseParserRuleContext<'input,IfThenStatementContextExt<'input>>;

#[derive(Clone)]
pub struct IfThenStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for IfThenStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for IfThenStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ifThenStatement(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_ifThenStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for IfThenStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_ifThenStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for IfThenStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifThenStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifThenStatement }
}
antlr_rust::tid!{IfThenStatementContextExt<'a>}

impl<'input> IfThenStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfThenStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfThenStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfThenStatementContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<IfThenStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IF
/// Returns `None` if there is no child corresponding to token IF
fn IF(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(IF, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn statement(&self) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IfThenStatementContextAttrs<'input> for IfThenStatementContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifThenStatement(&mut self,)
	-> Result<Rc<IfThenStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfThenStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 306, RULE_ifThenStatement);
        let mut _localctx: Rc<IfThenStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1763);
			recog.base.match_token(IF,&mut recog.err_handler)?;

			recog.base.set_state(1764);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1765);
			recog.expression()?;

			recog.base.set_state(1766);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule statement*/
			recog.base.set_state(1767);
			recog.statement()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifThenElseStatement ----------------
pub type IfThenElseStatementContextAll<'input> = IfThenElseStatementContext<'input>;


pub type IfThenElseStatementContext<'input> = BaseParserRuleContext<'input,IfThenElseStatementContextExt<'input>>;

#[derive(Clone)]
pub struct IfThenElseStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for IfThenElseStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for IfThenElseStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ifThenElseStatement(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_ifThenElseStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for IfThenElseStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_ifThenElseStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for IfThenElseStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifThenElseStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifThenElseStatement }
}
antlr_rust::tid!{IfThenElseStatementContextExt<'a>}

impl<'input> IfThenElseStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfThenElseStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfThenElseStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfThenElseStatementContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<IfThenElseStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IF
/// Returns `None` if there is no child corresponding to token IF
fn IF(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(IF, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn statementNoShortIf(&self) -> Option<Rc<StatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ELSE
/// Returns `None` if there is no child corresponding to token ELSE
fn ELSE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(ELSE, 0)
}
fn statement(&self) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IfThenElseStatementContextAttrs<'input> for IfThenElseStatementContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifThenElseStatement(&mut self,)
	-> Result<Rc<IfThenElseStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfThenElseStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 308, RULE_ifThenElseStatement);
        let mut _localctx: Rc<IfThenElseStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1769);
			recog.base.match_token(IF,&mut recog.err_handler)?;

			recog.base.set_state(1770);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1771);
			recog.expression()?;

			recog.base.set_state(1772);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule statementNoShortIf*/
			recog.base.set_state(1773);
			recog.statementNoShortIf()?;

			recog.base.set_state(1774);
			recog.base.match_token(ELSE,&mut recog.err_handler)?;

			/*InvokeRule statement*/
			recog.base.set_state(1775);
			recog.statement()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifThenElseStatementNoShortIf ----------------
pub type IfThenElseStatementNoShortIfContextAll<'input> = IfThenElseStatementNoShortIfContext<'input>;


pub type IfThenElseStatementNoShortIfContext<'input> = BaseParserRuleContext<'input,IfThenElseStatementNoShortIfContextExt<'input>>;

#[derive(Clone)]
pub struct IfThenElseStatementNoShortIfContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for IfThenElseStatementNoShortIfContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for IfThenElseStatementNoShortIfContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ifThenElseStatementNoShortIf(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_ifThenElseStatementNoShortIf(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for IfThenElseStatementNoShortIfContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_ifThenElseStatementNoShortIf(self);
	}
}

impl<'input> CustomRuleContext<'input> for IfThenElseStatementNoShortIfContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifThenElseStatementNoShortIf }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifThenElseStatementNoShortIf }
}
antlr_rust::tid!{IfThenElseStatementNoShortIfContextExt<'a>}

impl<'input> IfThenElseStatementNoShortIfContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfThenElseStatementNoShortIfContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfThenElseStatementNoShortIfContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfThenElseStatementNoShortIfContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<IfThenElseStatementNoShortIfContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IF
/// Returns `None` if there is no child corresponding to token IF
fn IF(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(IF, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn statementNoShortIf_all(&self) ->  Vec<Rc<StatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn statementNoShortIf(&self, i: usize) -> Option<Rc<StatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token ELSE
/// Returns `None` if there is no child corresponding to token ELSE
fn ELSE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(ELSE, 0)
}

}

impl<'input> IfThenElseStatementNoShortIfContextAttrs<'input> for IfThenElseStatementNoShortIfContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifThenElseStatementNoShortIf(&mut self,)
	-> Result<Rc<IfThenElseStatementNoShortIfContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfThenElseStatementNoShortIfContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 310, RULE_ifThenElseStatementNoShortIf);
        let mut _localctx: Rc<IfThenElseStatementNoShortIfContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1777);
			recog.base.match_token(IF,&mut recog.err_handler)?;

			recog.base.set_state(1778);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1779);
			recog.expression()?;

			recog.base.set_state(1780);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule statementNoShortIf*/
			recog.base.set_state(1781);
			recog.statementNoShortIf()?;

			recog.base.set_state(1782);
			recog.base.match_token(ELSE,&mut recog.err_handler)?;

			/*InvokeRule statementNoShortIf*/
			recog.base.set_state(1783);
			recog.statementNoShortIf()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- assertStatement ----------------
pub type AssertStatementContextAll<'input> = AssertStatementContext<'input>;


pub type AssertStatementContext<'input> = BaseParserRuleContext<'input,AssertStatementContextExt<'input>>;

#[derive(Clone)]
pub struct AssertStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for AssertStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for AssertStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_assertStatement(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_assertStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for AssertStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_assertStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for AssertStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_assertStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_assertStatement }
}
antlr_rust::tid!{AssertStatementContextExt<'a>}

impl<'input> AssertStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AssertStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AssertStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AssertStatementContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<AssertStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ASSERT
/// Returns `None` if there is no child corresponding to token ASSERT
fn ASSERT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(ASSERT, 0)
}
fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}

}

impl<'input> AssertStatementContextAttrs<'input> for AssertStatementContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn assertStatement(&mut self,)
	-> Result<Rc<AssertStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AssertStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 312, RULE_assertStatement);
        let mut _localctx: Rc<AssertStatementContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1785);
			recog.base.match_token(ASSERT,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1786);
			recog.expression()?;

			recog.base.set_state(1789);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COLON {
				{
				recog.base.set_state(1787);
				recog.base.match_token(COLON,&mut recog.err_handler)?;

				/*InvokeRule expression*/
				recog.base.set_state(1788);
				recog.expression()?;

				}
			}

			recog.base.set_state(1791);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- switchStatement ----------------
pub type SwitchStatementContextAll<'input> = SwitchStatementContext<'input>;


pub type SwitchStatementContext<'input> = BaseParserRuleContext<'input,SwitchStatementContextExt<'input>>;

#[derive(Clone)]
pub struct SwitchStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for SwitchStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for SwitchStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_switchStatement(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_switchStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for SwitchStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_switchStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for SwitchStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_switchStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_switchStatement }
}
antlr_rust::tid!{SwitchStatementContextExt<'a>}

impl<'input> SwitchStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SwitchStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SwitchStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SwitchStatementContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<SwitchStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token SWITCH
/// Returns `None` if there is no child corresponding to token SWITCH
fn SWITCH(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SWITCH, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn switchBlock(&self) -> Option<Rc<SwitchBlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SwitchStatementContextAttrs<'input> for SwitchStatementContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn switchStatement(&mut self,)
	-> Result<Rc<SwitchStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SwitchStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 314, RULE_switchStatement);
        let mut _localctx: Rc<SwitchStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1793);
			recog.base.match_token(SWITCH,&mut recog.err_handler)?;

			recog.base.set_state(1794);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1795);
			recog.expression()?;

			recog.base.set_state(1796);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule switchBlock*/
			recog.base.set_state(1797);
			recog.switchBlock()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- switchBlock ----------------
pub type SwitchBlockContextAll<'input> = SwitchBlockContext<'input>;


pub type SwitchBlockContext<'input> = BaseParserRuleContext<'input,SwitchBlockContextExt<'input>>;

#[derive(Clone)]
pub struct SwitchBlockContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for SwitchBlockContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for SwitchBlockContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_switchBlock(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_switchBlock(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for SwitchBlockContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_switchBlock(self);
	}
}

impl<'input> CustomRuleContext<'input> for SwitchBlockContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_switchBlock }
	//fn type_rule_index() -> usize where Self: Sized { RULE_switchBlock }
}
antlr_rust::tid!{SwitchBlockContextExt<'a>}

impl<'input> SwitchBlockContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SwitchBlockContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SwitchBlockContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SwitchBlockContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<SwitchBlockContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
fn switchRule_all(&self) ->  Vec<Rc<SwitchRuleContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn switchRule(&self, i: usize) -> Option<Rc<SwitchRuleContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}
fn switchBlockStatementGroup_all(&self) ->  Vec<Rc<SwitchBlockStatementGroupContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn switchBlockStatementGroup(&self, i: usize) -> Option<Rc<SwitchBlockStatementGroupContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn switchLabel_all(&self) ->  Vec<Rc<SwitchLabelContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn switchLabel(&self, i: usize) -> Option<Rc<SwitchLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COLON in current rule
fn COLON_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COLON, starting from 0.
/// Returns `None` if number of children corresponding to token COLON is less or equal than `i`.
fn COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COLON, i)
}

}

impl<'input> SwitchBlockContextAttrs<'input> for SwitchBlockContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn switchBlock(&mut self,)
	-> Result<Rc<SwitchBlockContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SwitchBlockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 316, RULE_switchBlock);
        let mut _localctx: Rc<SwitchBlockContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			recog.base.set_state(1825);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(195,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1799);
					recog.base.match_token(LBRACE,&mut recog.err_handler)?;

					/*InvokeRule switchRule*/
					recog.base.set_state(1800);
					recog.switchRule()?;

					recog.base.set_state(1804);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==CASE || _la==DEFAULT {
						{
						{
						/*InvokeRule switchRule*/
						recog.base.set_state(1801);
						recog.switchRule()?;

						}
						}
						recog.base.set_state(1806);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1807);
					recog.base.match_token(RBRACE,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1809);
					recog.base.match_token(LBRACE,&mut recog.err_handler)?;

					recog.base.set_state(1813);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(193,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							/*InvokeRule switchBlockStatementGroup*/
							recog.base.set_state(1810);
							recog.switchBlockStatementGroup()?;

							}
							} 
						}
						recog.base.set_state(1815);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(193,&mut recog.base)?;
					}
					recog.base.set_state(1821);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==CASE || _la==DEFAULT {
						{
						{
						/*InvokeRule switchLabel*/
						recog.base.set_state(1816);
						recog.switchLabel()?;

						recog.base.set_state(1817);
						recog.base.match_token(COLON,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1823);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1824);
					recog.base.match_token(RBRACE,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- switchRule ----------------
pub type SwitchRuleContextAll<'input> = SwitchRuleContext<'input>;


pub type SwitchRuleContext<'input> = BaseParserRuleContext<'input,SwitchRuleContextExt<'input>>;

#[derive(Clone)]
pub struct SwitchRuleContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for SwitchRuleContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for SwitchRuleContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_switchRule(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_switchRule(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for SwitchRuleContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_switchRule(self);
	}
}

impl<'input> CustomRuleContext<'input> for SwitchRuleContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_switchRule }
	//fn type_rule_index() -> usize where Self: Sized { RULE_switchRule }
}
antlr_rust::tid!{SwitchRuleContextExt<'a>}

impl<'input> SwitchRuleContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SwitchRuleContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SwitchRuleContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SwitchRuleContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<SwitchRuleContextExt<'input>>{

fn switchLabel(&self) -> Option<Rc<SwitchLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ARROW
/// Returns `None` if there is no child corresponding to token ARROW
fn ARROW(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(ARROW, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}
fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn throwStatement(&self) -> Option<Rc<ThrowStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SwitchRuleContextAttrs<'input> for SwitchRuleContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn switchRule(&mut self,)
	-> Result<Rc<SwitchRuleContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SwitchRuleContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 318, RULE_switchRule);
        let mut _localctx: Rc<SwitchRuleContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule switchLabel*/
			recog.base.set_state(1827);
			recog.switchLabel()?;

			recog.base.set_state(1828);
			recog.base.match_token(ARROW,&mut recog.err_handler)?;

			recog.base.set_state(1834);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 BOOLEAN | BYTE | CHAR | DOUBLE | FLOAT | INT | LONG | NEW | SHORT | SUPER |
			 SWITCH | THIS | VOID | IntegerLiteral | FloatingPointLiteral | BooleanLiteral |
			 CharacterLiteral | StringLiteral | TextBlock | NullLiteral | LPAREN |
			 AT | BANG | TILDE | INC | DEC | ADD | SUB | Identifier 
				=> {
					{
					/*InvokeRule expression*/
					recog.base.set_state(1829);
					recog.expression()?;

					recog.base.set_state(1830);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}

			 LBRACE 
				=> {
					{
					/*InvokeRule block*/
					recog.base.set_state(1832);
					recog.block()?;

					}
				}

			 THROW 
				=> {
					{
					/*InvokeRule throwStatement*/
					recog.base.set_state(1833);
					recog.throwStatement()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- switchBlockStatementGroup ----------------
pub type SwitchBlockStatementGroupContextAll<'input> = SwitchBlockStatementGroupContext<'input>;


pub type SwitchBlockStatementGroupContext<'input> = BaseParserRuleContext<'input,SwitchBlockStatementGroupContextExt<'input>>;

#[derive(Clone)]
pub struct SwitchBlockStatementGroupContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for SwitchBlockStatementGroupContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for SwitchBlockStatementGroupContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_switchBlockStatementGroup(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_switchBlockStatementGroup(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for SwitchBlockStatementGroupContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_switchBlockStatementGroup(self);
	}
}

impl<'input> CustomRuleContext<'input> for SwitchBlockStatementGroupContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_switchBlockStatementGroup }
	//fn type_rule_index() -> usize where Self: Sized { RULE_switchBlockStatementGroup }
}
antlr_rust::tid!{SwitchBlockStatementGroupContextExt<'a>}

impl<'input> SwitchBlockStatementGroupContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SwitchBlockStatementGroupContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SwitchBlockStatementGroupContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SwitchBlockStatementGroupContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<SwitchBlockStatementGroupContextExt<'input>>{

fn switchLabel_all(&self) ->  Vec<Rc<SwitchLabelContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn switchLabel(&self, i: usize) -> Option<Rc<SwitchLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COLON in current rule
fn COLON_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COLON, starting from 0.
/// Returns `None` if number of children corresponding to token COLON is less or equal than `i`.
fn COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COLON, i)
}
fn blockStatements(&self) -> Option<Rc<BlockStatementsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SwitchBlockStatementGroupContextAttrs<'input> for SwitchBlockStatementGroupContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn switchBlockStatementGroup(&mut self,)
	-> Result<Rc<SwitchBlockStatementGroupContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SwitchBlockStatementGroupContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 320, RULE_switchBlockStatementGroup);
        let mut _localctx: Rc<SwitchBlockStatementGroupContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule switchLabel*/
			recog.base.set_state(1836);
			recog.switchLabel()?;

			recog.base.set_state(1837);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			recog.base.set_state(1843);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==CASE || _la==DEFAULT {
				{
				{
				/*InvokeRule switchLabel*/
				recog.base.set_state(1838);
				recog.switchLabel()?;

				recog.base.set_state(1839);
				recog.base.match_token(COLON,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1845);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule blockStatements*/
			recog.base.set_state(1846);
			recog.blockStatements()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- switchLabel ----------------
pub type SwitchLabelContextAll<'input> = SwitchLabelContext<'input>;


pub type SwitchLabelContext<'input> = BaseParserRuleContext<'input,SwitchLabelContextExt<'input>>;

#[derive(Clone)]
pub struct SwitchLabelContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for SwitchLabelContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for SwitchLabelContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_switchLabel(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_switchLabel(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for SwitchLabelContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_switchLabel(self);
	}
}

impl<'input> CustomRuleContext<'input> for SwitchLabelContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_switchLabel }
	//fn type_rule_index() -> usize where Self: Sized { RULE_switchLabel }
}
antlr_rust::tid!{SwitchLabelContextExt<'a>}

impl<'input> SwitchLabelContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SwitchLabelContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SwitchLabelContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SwitchLabelContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<SwitchLabelContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token CASE
/// Returns `None` if there is no child corresponding to token CASE
fn CASE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(CASE, 0)
}
fn caseConstant_all(&self) ->  Vec<Rc<CaseConstantContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn caseConstant(&self, i: usize) -> Option<Rc<CaseConstantContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
/// Retrieves first TerminalNode corresponding to token DEFAULT
/// Returns `None` if there is no child corresponding to token DEFAULT
fn DEFAULT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DEFAULT, 0)
}

}

impl<'input> SwitchLabelContextAttrs<'input> for SwitchLabelContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn switchLabel(&mut self,)
	-> Result<Rc<SwitchLabelContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SwitchLabelContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 322, RULE_switchLabel);
        let mut _localctx: Rc<SwitchLabelContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1858);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 CASE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1848);
					recog.base.match_token(CASE,&mut recog.err_handler)?;

					/*InvokeRule caseConstant*/
					recog.base.set_state(1849);
					recog.caseConstant()?;

					recog.base.set_state(1854);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==COMMA {
						{
						{
						recog.base.set_state(1850);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						/*InvokeRule caseConstant*/
						recog.base.set_state(1851);
						recog.caseConstant()?;

						}
						}
						recog.base.set_state(1856);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}

			 DEFAULT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1857);
					recog.base.match_token(DEFAULT,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- caseConstant ----------------
pub type CaseConstantContextAll<'input> = CaseConstantContext<'input>;


pub type CaseConstantContext<'input> = BaseParserRuleContext<'input,CaseConstantContextExt<'input>>;

#[derive(Clone)]
pub struct CaseConstantContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for CaseConstantContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for CaseConstantContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_caseConstant(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_caseConstant(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for CaseConstantContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_caseConstant(self);
	}
}

impl<'input> CustomRuleContext<'input> for CaseConstantContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_caseConstant }
	//fn type_rule_index() -> usize where Self: Sized { RULE_caseConstant }
}
antlr_rust::tid!{CaseConstantContextExt<'a>}

impl<'input> CaseConstantContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CaseConstantContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CaseConstantContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CaseConstantContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<CaseConstantContextExt<'input>>{

fn conditionalExpression(&self) -> Option<Rc<ConditionalExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CaseConstantContextAttrs<'input> for CaseConstantContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn caseConstant(&mut self,)
	-> Result<Rc<CaseConstantContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CaseConstantContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 324, RULE_caseConstant);
        let mut _localctx: Rc<CaseConstantContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule conditionalExpression*/
			recog.base.set_state(1860);
			recog.conditionalExpression()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- whileStatement ----------------
pub type WhileStatementContextAll<'input> = WhileStatementContext<'input>;


pub type WhileStatementContext<'input> = BaseParserRuleContext<'input,WhileStatementContextExt<'input>>;

#[derive(Clone)]
pub struct WhileStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for WhileStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for WhileStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_whileStatement(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_whileStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for WhileStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_whileStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for WhileStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_whileStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_whileStatement }
}
antlr_rust::tid!{WhileStatementContextExt<'a>}

impl<'input> WhileStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WhileStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WhileStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait WhileStatementContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<WhileStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token WHILE
/// Returns `None` if there is no child corresponding to token WHILE
fn WHILE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(WHILE, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn statement(&self) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> WhileStatementContextAttrs<'input> for WhileStatementContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn whileStatement(&mut self,)
	-> Result<Rc<WhileStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WhileStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 326, RULE_whileStatement);
        let mut _localctx: Rc<WhileStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1862);
			recog.base.match_token(WHILE,&mut recog.err_handler)?;

			recog.base.set_state(1863);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1864);
			recog.expression()?;

			recog.base.set_state(1865);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule statement*/
			recog.base.set_state(1866);
			recog.statement()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- whileStatementNoShortIf ----------------
pub type WhileStatementNoShortIfContextAll<'input> = WhileStatementNoShortIfContext<'input>;


pub type WhileStatementNoShortIfContext<'input> = BaseParserRuleContext<'input,WhileStatementNoShortIfContextExt<'input>>;

#[derive(Clone)]
pub struct WhileStatementNoShortIfContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for WhileStatementNoShortIfContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for WhileStatementNoShortIfContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_whileStatementNoShortIf(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_whileStatementNoShortIf(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for WhileStatementNoShortIfContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_whileStatementNoShortIf(self);
	}
}

impl<'input> CustomRuleContext<'input> for WhileStatementNoShortIfContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_whileStatementNoShortIf }
	//fn type_rule_index() -> usize where Self: Sized { RULE_whileStatementNoShortIf }
}
antlr_rust::tid!{WhileStatementNoShortIfContextExt<'a>}

impl<'input> WhileStatementNoShortIfContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WhileStatementNoShortIfContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WhileStatementNoShortIfContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait WhileStatementNoShortIfContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<WhileStatementNoShortIfContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token WHILE
/// Returns `None` if there is no child corresponding to token WHILE
fn WHILE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(WHILE, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn statementNoShortIf(&self) -> Option<Rc<StatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> WhileStatementNoShortIfContextAttrs<'input> for WhileStatementNoShortIfContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn whileStatementNoShortIf(&mut self,)
	-> Result<Rc<WhileStatementNoShortIfContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WhileStatementNoShortIfContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 328, RULE_whileStatementNoShortIf);
        let mut _localctx: Rc<WhileStatementNoShortIfContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1868);
			recog.base.match_token(WHILE,&mut recog.err_handler)?;

			recog.base.set_state(1869);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1870);
			recog.expression()?;

			recog.base.set_state(1871);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule statementNoShortIf*/
			recog.base.set_state(1872);
			recog.statementNoShortIf()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- doStatement ----------------
pub type DoStatementContextAll<'input> = DoStatementContext<'input>;


pub type DoStatementContext<'input> = BaseParserRuleContext<'input,DoStatementContextExt<'input>>;

#[derive(Clone)]
pub struct DoStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for DoStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for DoStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_doStatement(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_doStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for DoStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_doStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for DoStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_doStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_doStatement }
}
antlr_rust::tid!{DoStatementContextExt<'a>}

impl<'input> DoStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DoStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DoStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DoStatementContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<DoStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DO
/// Returns `None` if there is no child corresponding to token DO
fn DO(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DO, 0)
}
fn statement(&self) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token WHILE
/// Returns `None` if there is no child corresponding to token WHILE
fn WHILE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(WHILE, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> DoStatementContextAttrs<'input> for DoStatementContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn doStatement(&mut self,)
	-> Result<Rc<DoStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DoStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 330, RULE_doStatement);
        let mut _localctx: Rc<DoStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1874);
			recog.base.match_token(DO,&mut recog.err_handler)?;

			/*InvokeRule statement*/
			recog.base.set_state(1875);
			recog.statement()?;

			recog.base.set_state(1876);
			recog.base.match_token(WHILE,&mut recog.err_handler)?;

			recog.base.set_state(1877);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1878);
			recog.expression()?;

			recog.base.set_state(1879);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1880);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- forStatement ----------------
pub type ForStatementContextAll<'input> = ForStatementContext<'input>;


pub type ForStatementContext<'input> = BaseParserRuleContext<'input,ForStatementContextExt<'input>>;

#[derive(Clone)]
pub struct ForStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ForStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ForStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_forStatement(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_forStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ForStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_forStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for ForStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_forStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_forStatement }
}
antlr_rust::tid!{ForStatementContextExt<'a>}

impl<'input> ForStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ForStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ForStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ForStatementContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ForStatementContextExt<'input>>{

fn basicForStatement(&self) -> Option<Rc<BasicForStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn enhancedForStatement(&self) -> Option<Rc<EnhancedForStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ForStatementContextAttrs<'input> for ForStatementContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn forStatement(&mut self,)
	-> Result<Rc<ForStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ForStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 332, RULE_forStatement);
        let mut _localctx: Rc<ForStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1884);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(200,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule basicForStatement*/
					recog.base.set_state(1882);
					recog.basicForStatement()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule enhancedForStatement*/
					recog.base.set_state(1883);
					recog.enhancedForStatement()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- forStatementNoShortIf ----------------
pub type ForStatementNoShortIfContextAll<'input> = ForStatementNoShortIfContext<'input>;


pub type ForStatementNoShortIfContext<'input> = BaseParserRuleContext<'input,ForStatementNoShortIfContextExt<'input>>;

#[derive(Clone)]
pub struct ForStatementNoShortIfContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ForStatementNoShortIfContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ForStatementNoShortIfContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_forStatementNoShortIf(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_forStatementNoShortIf(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ForStatementNoShortIfContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_forStatementNoShortIf(self);
	}
}

impl<'input> CustomRuleContext<'input> for ForStatementNoShortIfContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_forStatementNoShortIf }
	//fn type_rule_index() -> usize where Self: Sized { RULE_forStatementNoShortIf }
}
antlr_rust::tid!{ForStatementNoShortIfContextExt<'a>}

impl<'input> ForStatementNoShortIfContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ForStatementNoShortIfContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ForStatementNoShortIfContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ForStatementNoShortIfContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ForStatementNoShortIfContextExt<'input>>{

fn basicForStatementNoShortIf(&self) -> Option<Rc<BasicForStatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn enhancedForStatementNoShortIf(&self) -> Option<Rc<EnhancedForStatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ForStatementNoShortIfContextAttrs<'input> for ForStatementNoShortIfContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn forStatementNoShortIf(&mut self,)
	-> Result<Rc<ForStatementNoShortIfContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ForStatementNoShortIfContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 334, RULE_forStatementNoShortIf);
        let mut _localctx: Rc<ForStatementNoShortIfContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1888);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(201,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule basicForStatementNoShortIf*/
					recog.base.set_state(1886);
					recog.basicForStatementNoShortIf()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule enhancedForStatementNoShortIf*/
					recog.base.set_state(1887);
					recog.enhancedForStatementNoShortIf()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- basicForStatement ----------------
pub type BasicForStatementContextAll<'input> = BasicForStatementContext<'input>;


pub type BasicForStatementContext<'input> = BaseParserRuleContext<'input,BasicForStatementContextExt<'input>>;

#[derive(Clone)]
pub struct BasicForStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for BasicForStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for BasicForStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_basicForStatement(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_basicForStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for BasicForStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_basicForStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for BasicForStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_basicForStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_basicForStatement }
}
antlr_rust::tid!{BasicForStatementContextExt<'a>}

impl<'input> BasicForStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BasicForStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BasicForStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BasicForStatementContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<BasicForStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FOR
/// Returns `None` if there is no child corresponding to token FOR
fn FOR(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(FOR, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token SEMI in current rule
fn SEMI_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token SEMI, starting from 0.
/// Returns `None` if number of children corresponding to token SEMI is less or equal than `i`.
fn SEMI(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, i)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn statement(&self) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn forInit(&self) -> Option<Rc<ForInitContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn forUpdate(&self) -> Option<Rc<ForUpdateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> BasicForStatementContextAttrs<'input> for BasicForStatementContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn basicForStatement(&mut self,)
	-> Result<Rc<BasicForStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BasicForStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 336, RULE_basicForStatement);
        let mut _localctx: Rc<BasicForStatementContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1890);
			recog.base.match_token(FOR,&mut recog.err_handler)?;

			recog.base.set_state(1891);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1893);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << VAR) | (1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 35)) & !0x3f) == 0 && ((1usize << (_la - 35)) & ((1usize << (FINAL - 35)) | (1usize << (FLOAT - 35)) | (1usize << (INT - 35)) | (1usize << (LONG - 35)) | (1usize << (NEW - 35)) | (1usize << (SHORT - 35)) | (1usize << (SUPER - 35)) | (1usize << (THIS - 35)) | (1usize << (VOID - 35)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (AT - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (Identifier - 102)))) != 0) {
				{
				/*InvokeRule forInit*/
				recog.base.set_state(1892);
				recog.forInit()?;

				}
			}

			recog.base.set_state(1895);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			recog.base.set_state(1897);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (FLOAT - 37)) | (1usize << (INT - 37)) | (1usize << (LONG - 37)) | (1usize << (NEW - 37)) | (1usize << (SHORT - 37)) | (1usize << (SUPER - 37)) | (1usize << (SWITCH - 37)) | (1usize << (THIS - 37)) | (1usize << (VOID - 37)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (AT - 69)) | (1usize << (BANG - 69)) | (1usize << (TILDE - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (ADD - 102)) | (1usize << (SUB - 102)) | (1usize << (Identifier - 102)))) != 0) {
				{
				/*InvokeRule expression*/
				recog.base.set_state(1896);
				recog.expression()?;

				}
			}

			recog.base.set_state(1899);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			recog.base.set_state(1901);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (FLOAT - 37)) | (1usize << (INT - 37)) | (1usize << (LONG - 37)) | (1usize << (NEW - 37)) | (1usize << (SHORT - 37)) | (1usize << (SUPER - 37)) | (1usize << (THIS - 37)) | (1usize << (VOID - 37)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (AT - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (Identifier - 102)))) != 0) {
				{
				/*InvokeRule forUpdate*/
				recog.base.set_state(1900);
				recog.forUpdate()?;

				}
			}

			recog.base.set_state(1903);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule statement*/
			recog.base.set_state(1904);
			recog.statement()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- basicForStatementNoShortIf ----------------
pub type BasicForStatementNoShortIfContextAll<'input> = BasicForStatementNoShortIfContext<'input>;


pub type BasicForStatementNoShortIfContext<'input> = BaseParserRuleContext<'input,BasicForStatementNoShortIfContextExt<'input>>;

#[derive(Clone)]
pub struct BasicForStatementNoShortIfContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for BasicForStatementNoShortIfContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for BasicForStatementNoShortIfContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_basicForStatementNoShortIf(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_basicForStatementNoShortIf(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for BasicForStatementNoShortIfContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_basicForStatementNoShortIf(self);
	}
}

impl<'input> CustomRuleContext<'input> for BasicForStatementNoShortIfContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_basicForStatementNoShortIf }
	//fn type_rule_index() -> usize where Self: Sized { RULE_basicForStatementNoShortIf }
}
antlr_rust::tid!{BasicForStatementNoShortIfContextExt<'a>}

impl<'input> BasicForStatementNoShortIfContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BasicForStatementNoShortIfContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BasicForStatementNoShortIfContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BasicForStatementNoShortIfContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<BasicForStatementNoShortIfContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FOR
/// Returns `None` if there is no child corresponding to token FOR
fn FOR(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(FOR, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token SEMI in current rule
fn SEMI_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token SEMI, starting from 0.
/// Returns `None` if number of children corresponding to token SEMI is less or equal than `i`.
fn SEMI(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, i)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn statementNoShortIf(&self) -> Option<Rc<StatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn forInit(&self) -> Option<Rc<ForInitContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn forUpdate(&self) -> Option<Rc<ForUpdateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> BasicForStatementNoShortIfContextAttrs<'input> for BasicForStatementNoShortIfContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn basicForStatementNoShortIf(&mut self,)
	-> Result<Rc<BasicForStatementNoShortIfContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BasicForStatementNoShortIfContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 338, RULE_basicForStatementNoShortIf);
        let mut _localctx: Rc<BasicForStatementNoShortIfContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1906);
			recog.base.match_token(FOR,&mut recog.err_handler)?;

			recog.base.set_state(1907);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1909);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << VAR) | (1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 35)) & !0x3f) == 0 && ((1usize << (_la - 35)) & ((1usize << (FINAL - 35)) | (1usize << (FLOAT - 35)) | (1usize << (INT - 35)) | (1usize << (LONG - 35)) | (1usize << (NEW - 35)) | (1usize << (SHORT - 35)) | (1usize << (SUPER - 35)) | (1usize << (THIS - 35)) | (1usize << (VOID - 35)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (AT - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (Identifier - 102)))) != 0) {
				{
				/*InvokeRule forInit*/
				recog.base.set_state(1908);
				recog.forInit()?;

				}
			}

			recog.base.set_state(1911);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			recog.base.set_state(1913);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (FLOAT - 37)) | (1usize << (INT - 37)) | (1usize << (LONG - 37)) | (1usize << (NEW - 37)) | (1usize << (SHORT - 37)) | (1usize << (SUPER - 37)) | (1usize << (SWITCH - 37)) | (1usize << (THIS - 37)) | (1usize << (VOID - 37)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (AT - 69)) | (1usize << (BANG - 69)) | (1usize << (TILDE - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (ADD - 102)) | (1usize << (SUB - 102)) | (1usize << (Identifier - 102)))) != 0) {
				{
				/*InvokeRule expression*/
				recog.base.set_state(1912);
				recog.expression()?;

				}
			}

			recog.base.set_state(1915);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			recog.base.set_state(1917);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (FLOAT - 37)) | (1usize << (INT - 37)) | (1usize << (LONG - 37)) | (1usize << (NEW - 37)) | (1usize << (SHORT - 37)) | (1usize << (SUPER - 37)) | (1usize << (THIS - 37)) | (1usize << (VOID - 37)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (AT - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (Identifier - 102)))) != 0) {
				{
				/*InvokeRule forUpdate*/
				recog.base.set_state(1916);
				recog.forUpdate()?;

				}
			}

			recog.base.set_state(1919);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule statementNoShortIf*/
			recog.base.set_state(1920);
			recog.statementNoShortIf()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- forInit ----------------
pub type ForInitContextAll<'input> = ForInitContext<'input>;


pub type ForInitContext<'input> = BaseParserRuleContext<'input,ForInitContextExt<'input>>;

#[derive(Clone)]
pub struct ForInitContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ForInitContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ForInitContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_forInit(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_forInit(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ForInitContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_forInit(self);
	}
}

impl<'input> CustomRuleContext<'input> for ForInitContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_forInit }
	//fn type_rule_index() -> usize where Self: Sized { RULE_forInit }
}
antlr_rust::tid!{ForInitContextExt<'a>}

impl<'input> ForInitContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ForInitContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ForInitContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ForInitContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ForInitContextExt<'input>>{

fn statementExpressionList(&self) -> Option<Rc<StatementExpressionListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn localVariableDeclaration(&self) -> Option<Rc<LocalVariableDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ForInitContextAttrs<'input> for ForInitContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn forInit(&mut self,)
	-> Result<Rc<ForInitContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ForInitContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 340, RULE_forInit);
        let mut _localctx: Rc<ForInitContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1924);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(208,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule statementExpressionList*/
					recog.base.set_state(1922);
					recog.statementExpressionList()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule localVariableDeclaration*/
					recog.base.set_state(1923);
					recog.localVariableDeclaration()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- forUpdate ----------------
pub type ForUpdateContextAll<'input> = ForUpdateContext<'input>;


pub type ForUpdateContext<'input> = BaseParserRuleContext<'input,ForUpdateContextExt<'input>>;

#[derive(Clone)]
pub struct ForUpdateContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ForUpdateContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ForUpdateContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_forUpdate(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_forUpdate(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ForUpdateContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_forUpdate(self);
	}
}

impl<'input> CustomRuleContext<'input> for ForUpdateContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_forUpdate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_forUpdate }
}
antlr_rust::tid!{ForUpdateContextExt<'a>}

impl<'input> ForUpdateContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ForUpdateContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ForUpdateContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ForUpdateContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ForUpdateContextExt<'input>>{

fn statementExpressionList(&self) -> Option<Rc<StatementExpressionListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ForUpdateContextAttrs<'input> for ForUpdateContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn forUpdate(&mut self,)
	-> Result<Rc<ForUpdateContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ForUpdateContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 342, RULE_forUpdate);
        let mut _localctx: Rc<ForUpdateContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule statementExpressionList*/
			recog.base.set_state(1926);
			recog.statementExpressionList()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- statementExpressionList ----------------
pub type StatementExpressionListContextAll<'input> = StatementExpressionListContext<'input>;


pub type StatementExpressionListContext<'input> = BaseParserRuleContext<'input,StatementExpressionListContextExt<'input>>;

#[derive(Clone)]
pub struct StatementExpressionListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for StatementExpressionListContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for StatementExpressionListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_statementExpressionList(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_statementExpressionList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for StatementExpressionListContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_statementExpressionList(self);
	}
}

impl<'input> CustomRuleContext<'input> for StatementExpressionListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statementExpressionList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statementExpressionList }
}
antlr_rust::tid!{StatementExpressionListContextExt<'a>}

impl<'input> StatementExpressionListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StatementExpressionListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StatementExpressionListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StatementExpressionListContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<StatementExpressionListContextExt<'input>>{

fn statementExpression_all(&self) ->  Vec<Rc<StatementExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn statementExpression(&self, i: usize) -> Option<Rc<StatementExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> StatementExpressionListContextAttrs<'input> for StatementExpressionListContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn statementExpressionList(&mut self,)
	-> Result<Rc<StatementExpressionListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StatementExpressionListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 344, RULE_statementExpressionList);
        let mut _localctx: Rc<StatementExpressionListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule statementExpression*/
			recog.base.set_state(1928);
			recog.statementExpression()?;

			recog.base.set_state(1933);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				recog.base.set_state(1929);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				/*InvokeRule statementExpression*/
				recog.base.set_state(1930);
				recog.statementExpression()?;

				}
				}
				recog.base.set_state(1935);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enhancedForStatement ----------------
pub type EnhancedForStatementContextAll<'input> = EnhancedForStatementContext<'input>;


pub type EnhancedForStatementContext<'input> = BaseParserRuleContext<'input,EnhancedForStatementContextExt<'input>>;

#[derive(Clone)]
pub struct EnhancedForStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for EnhancedForStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for EnhancedForStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enhancedForStatement(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_enhancedForStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for EnhancedForStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_enhancedForStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for EnhancedForStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enhancedForStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enhancedForStatement }
}
antlr_rust::tid!{EnhancedForStatementContextExt<'a>}

impl<'input> EnhancedForStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnhancedForStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnhancedForStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnhancedForStatementContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<EnhancedForStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FOR
/// Returns `None` if there is no child corresponding to token FOR
fn FOR(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(FOR, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn localVariableDeclaration(&self) -> Option<Rc<LocalVariableDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn statement(&self) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> EnhancedForStatementContextAttrs<'input> for EnhancedForStatementContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enhancedForStatement(&mut self,)
	-> Result<Rc<EnhancedForStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnhancedForStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 346, RULE_enhancedForStatement);
        let mut _localctx: Rc<EnhancedForStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1936);
			recog.base.match_token(FOR,&mut recog.err_handler)?;

			recog.base.set_state(1937);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule localVariableDeclaration*/
			recog.base.set_state(1938);
			recog.localVariableDeclaration()?;

			recog.base.set_state(1939);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1940);
			recog.expression()?;

			recog.base.set_state(1941);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule statement*/
			recog.base.set_state(1942);
			recog.statement()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enhancedForStatementNoShortIf ----------------
pub type EnhancedForStatementNoShortIfContextAll<'input> = EnhancedForStatementNoShortIfContext<'input>;


pub type EnhancedForStatementNoShortIfContext<'input> = BaseParserRuleContext<'input,EnhancedForStatementNoShortIfContextExt<'input>>;

#[derive(Clone)]
pub struct EnhancedForStatementNoShortIfContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for EnhancedForStatementNoShortIfContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for EnhancedForStatementNoShortIfContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enhancedForStatementNoShortIf(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_enhancedForStatementNoShortIf(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for EnhancedForStatementNoShortIfContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_enhancedForStatementNoShortIf(self);
	}
}

impl<'input> CustomRuleContext<'input> for EnhancedForStatementNoShortIfContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enhancedForStatementNoShortIf }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enhancedForStatementNoShortIf }
}
antlr_rust::tid!{EnhancedForStatementNoShortIfContextExt<'a>}

impl<'input> EnhancedForStatementNoShortIfContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnhancedForStatementNoShortIfContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnhancedForStatementNoShortIfContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnhancedForStatementNoShortIfContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<EnhancedForStatementNoShortIfContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FOR
/// Returns `None` if there is no child corresponding to token FOR
fn FOR(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(FOR, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn localVariableDeclaration(&self) -> Option<Rc<LocalVariableDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn statementNoShortIf(&self) -> Option<Rc<StatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> EnhancedForStatementNoShortIfContextAttrs<'input> for EnhancedForStatementNoShortIfContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enhancedForStatementNoShortIf(&mut self,)
	-> Result<Rc<EnhancedForStatementNoShortIfContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnhancedForStatementNoShortIfContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 348, RULE_enhancedForStatementNoShortIf);
        let mut _localctx: Rc<EnhancedForStatementNoShortIfContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1944);
			recog.base.match_token(FOR,&mut recog.err_handler)?;

			recog.base.set_state(1945);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule localVariableDeclaration*/
			recog.base.set_state(1946);
			recog.localVariableDeclaration()?;

			recog.base.set_state(1947);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1948);
			recog.expression()?;

			recog.base.set_state(1949);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule statementNoShortIf*/
			recog.base.set_state(1950);
			recog.statementNoShortIf()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- breakStatement ----------------
pub type BreakStatementContextAll<'input> = BreakStatementContext<'input>;


pub type BreakStatementContext<'input> = BaseParserRuleContext<'input,BreakStatementContextExt<'input>>;

#[derive(Clone)]
pub struct BreakStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for BreakStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for BreakStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_breakStatement(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_breakStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for BreakStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_breakStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for BreakStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_breakStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_breakStatement }
}
antlr_rust::tid!{BreakStatementContextExt<'a>}

impl<'input> BreakStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BreakStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BreakStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BreakStatementContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<BreakStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token BREAK
/// Returns `None` if there is no child corresponding to token BREAK
fn BREAK(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(BREAK, 0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}

}

impl<'input> BreakStatementContextAttrs<'input> for BreakStatementContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn breakStatement(&mut self,)
	-> Result<Rc<BreakStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BreakStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 350, RULE_breakStatement);
        let mut _localctx: Rc<BreakStatementContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1952);
			recog.base.match_token(BREAK,&mut recog.err_handler)?;

			recog.base.set_state(1954);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Identifier {
				{
				recog.base.set_state(1953);
				recog.base.match_token(Identifier,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(1956);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- continueStatement ----------------
pub type ContinueStatementContextAll<'input> = ContinueStatementContext<'input>;


pub type ContinueStatementContext<'input> = BaseParserRuleContext<'input,ContinueStatementContextExt<'input>>;

#[derive(Clone)]
pub struct ContinueStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ContinueStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ContinueStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_continueStatement(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_continueStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ContinueStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_continueStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for ContinueStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_continueStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_continueStatement }
}
antlr_rust::tid!{ContinueStatementContextExt<'a>}

impl<'input> ContinueStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ContinueStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ContinueStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ContinueStatementContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ContinueStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token CONTINUE
/// Returns `None` if there is no child corresponding to token CONTINUE
fn CONTINUE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(CONTINUE, 0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}

}

impl<'input> ContinueStatementContextAttrs<'input> for ContinueStatementContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn continueStatement(&mut self,)
	-> Result<Rc<ContinueStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ContinueStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 352, RULE_continueStatement);
        let mut _localctx: Rc<ContinueStatementContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1958);
			recog.base.match_token(CONTINUE,&mut recog.err_handler)?;

			recog.base.set_state(1960);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Identifier {
				{
				recog.base.set_state(1959);
				recog.base.match_token(Identifier,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(1962);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- returnStatement ----------------
pub type ReturnStatementContextAll<'input> = ReturnStatementContext<'input>;


pub type ReturnStatementContext<'input> = BaseParserRuleContext<'input,ReturnStatementContextExt<'input>>;

#[derive(Clone)]
pub struct ReturnStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ReturnStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ReturnStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_returnStatement(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_returnStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ReturnStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_returnStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for ReturnStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_returnStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_returnStatement }
}
antlr_rust::tid!{ReturnStatementContextExt<'a>}

impl<'input> ReturnStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ReturnStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ReturnStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ReturnStatementContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ReturnStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token RETURN
/// Returns `None` if there is no child corresponding to token RETURN
fn RETURN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RETURN, 0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ReturnStatementContextAttrs<'input> for ReturnStatementContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn returnStatement(&mut self,)
	-> Result<Rc<ReturnStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ReturnStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 354, RULE_returnStatement);
        let mut _localctx: Rc<ReturnStatementContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1964);
			recog.base.match_token(RETURN,&mut recog.err_handler)?;

			recog.base.set_state(1966);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (FLOAT - 37)) | (1usize << (INT - 37)) | (1usize << (LONG - 37)) | (1usize << (NEW - 37)) | (1usize << (SHORT - 37)) | (1usize << (SUPER - 37)) | (1usize << (SWITCH - 37)) | (1usize << (THIS - 37)) | (1usize << (VOID - 37)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (AT - 69)) | (1usize << (BANG - 69)) | (1usize << (TILDE - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (ADD - 102)) | (1usize << (SUB - 102)) | (1usize << (Identifier - 102)))) != 0) {
				{
				/*InvokeRule expression*/
				recog.base.set_state(1965);
				recog.expression()?;

				}
			}

			recog.base.set_state(1968);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- throwStatement ----------------
pub type ThrowStatementContextAll<'input> = ThrowStatementContext<'input>;


pub type ThrowStatementContext<'input> = BaseParserRuleContext<'input,ThrowStatementContextExt<'input>>;

#[derive(Clone)]
pub struct ThrowStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ThrowStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ThrowStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_throwStatement(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_throwStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ThrowStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_throwStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for ThrowStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_throwStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_throwStatement }
}
antlr_rust::tid!{ThrowStatementContextExt<'a>}

impl<'input> ThrowStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ThrowStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ThrowStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ThrowStatementContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ThrowStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token THROW
/// Returns `None` if there is no child corresponding to token THROW
fn THROW(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(THROW, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> ThrowStatementContextAttrs<'input> for ThrowStatementContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn throwStatement(&mut self,)
	-> Result<Rc<ThrowStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ThrowStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 356, RULE_throwStatement);
        let mut _localctx: Rc<ThrowStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1970);
			recog.base.match_token(THROW,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1971);
			recog.expression()?;

			recog.base.set_state(1972);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- synchronizedStatement ----------------
pub type SynchronizedStatementContextAll<'input> = SynchronizedStatementContext<'input>;


pub type SynchronizedStatementContext<'input> = BaseParserRuleContext<'input,SynchronizedStatementContextExt<'input>>;

#[derive(Clone)]
pub struct SynchronizedStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for SynchronizedStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for SynchronizedStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_synchronizedStatement(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_synchronizedStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for SynchronizedStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_synchronizedStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for SynchronizedStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_synchronizedStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_synchronizedStatement }
}
antlr_rust::tid!{SynchronizedStatementContextExt<'a>}

impl<'input> SynchronizedStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SynchronizedStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SynchronizedStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SynchronizedStatementContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<SynchronizedStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token SYNCHRONIZED
/// Returns `None` if there is no child corresponding to token SYNCHRONIZED
fn SYNCHRONIZED(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SYNCHRONIZED, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SynchronizedStatementContextAttrs<'input> for SynchronizedStatementContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn synchronizedStatement(&mut self,)
	-> Result<Rc<SynchronizedStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SynchronizedStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 358, RULE_synchronizedStatement);
        let mut _localctx: Rc<SynchronizedStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1974);
			recog.base.match_token(SYNCHRONIZED,&mut recog.err_handler)?;

			recog.base.set_state(1975);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1976);
			recog.expression()?;

			recog.base.set_state(1977);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule block*/
			recog.base.set_state(1978);
			recog.block()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- tryStatement ----------------
pub type TryStatementContextAll<'input> = TryStatementContext<'input>;


pub type TryStatementContext<'input> = BaseParserRuleContext<'input,TryStatementContextExt<'input>>;

#[derive(Clone)]
pub struct TryStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for TryStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for TryStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_tryStatement(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_tryStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for TryStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_tryStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for TryStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_tryStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_tryStatement }
}
antlr_rust::tid!{TryStatementContextExt<'a>}

impl<'input> TryStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TryStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TryStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TryStatementContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<TryStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token TRY
/// Returns `None` if there is no child corresponding to token TRY
fn TRY(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(TRY, 0)
}
fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn catches(&self) -> Option<Rc<CatchesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn finallyBlock(&self) -> Option<Rc<FinallyBlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn tryWithResourcesStatement(&self) -> Option<Rc<TryWithResourcesStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TryStatementContextAttrs<'input> for TryStatementContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn tryStatement(&mut self,)
	-> Result<Rc<TryStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TryStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 360, RULE_tryStatement);
        let mut _localctx: Rc<TryStatementContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1996);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(214,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1980);
					recog.base.match_token(TRY,&mut recog.err_handler)?;

					/*InvokeRule block*/
					recog.base.set_state(1981);
					recog.block()?;

					/*InvokeRule catches*/
					recog.base.set_state(1982);
					recog.catches()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1984);
					recog.base.match_token(TRY,&mut recog.err_handler)?;

					/*InvokeRule block*/
					recog.base.set_state(1985);
					recog.block()?;

					/*InvokeRule finallyBlock*/
					recog.base.set_state(1986);
					recog.finallyBlock()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(1988);
					recog.base.match_token(TRY,&mut recog.err_handler)?;

					/*InvokeRule block*/
					recog.base.set_state(1989);
					recog.block()?;

					recog.base.set_state(1991);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==CATCH {
						{
						/*InvokeRule catches*/
						recog.base.set_state(1990);
						recog.catches()?;

						}
					}

					/*InvokeRule finallyBlock*/
					recog.base.set_state(1993);
					recog.finallyBlock()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule tryWithResourcesStatement*/
					recog.base.set_state(1995);
					recog.tryWithResourcesStatement()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- catches ----------------
pub type CatchesContextAll<'input> = CatchesContext<'input>;


pub type CatchesContext<'input> = BaseParserRuleContext<'input,CatchesContextExt<'input>>;

#[derive(Clone)]
pub struct CatchesContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for CatchesContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for CatchesContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_catches(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_catches(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for CatchesContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_catches(self);
	}
}

impl<'input> CustomRuleContext<'input> for CatchesContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_catches }
	//fn type_rule_index() -> usize where Self: Sized { RULE_catches }
}
antlr_rust::tid!{CatchesContextExt<'a>}

impl<'input> CatchesContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CatchesContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CatchesContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CatchesContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<CatchesContextExt<'input>>{

fn catchClause_all(&self) ->  Vec<Rc<CatchClauseContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn catchClause(&self, i: usize) -> Option<Rc<CatchClauseContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> CatchesContextAttrs<'input> for CatchesContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn catches(&mut self,)
	-> Result<Rc<CatchesContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CatchesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 362, RULE_catches);
        let mut _localctx: Rc<CatchesContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule catchClause*/
			recog.base.set_state(1998);
			recog.catchClause()?;

			recog.base.set_state(2002);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==CATCH {
				{
				{
				/*InvokeRule catchClause*/
				recog.base.set_state(1999);
				recog.catchClause()?;

				}
				}
				recog.base.set_state(2004);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- catchClause ----------------
pub type CatchClauseContextAll<'input> = CatchClauseContext<'input>;


pub type CatchClauseContext<'input> = BaseParserRuleContext<'input,CatchClauseContextExt<'input>>;

#[derive(Clone)]
pub struct CatchClauseContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for CatchClauseContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for CatchClauseContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_catchClause(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_catchClause(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for CatchClauseContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_catchClause(self);
	}
}

impl<'input> CustomRuleContext<'input> for CatchClauseContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_catchClause }
	//fn type_rule_index() -> usize where Self: Sized { RULE_catchClause }
}
antlr_rust::tid!{CatchClauseContextExt<'a>}

impl<'input> CatchClauseContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CatchClauseContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CatchClauseContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CatchClauseContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<CatchClauseContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token CATCH
/// Returns `None` if there is no child corresponding to token CATCH
fn CATCH(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(CATCH, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn catchFormalParameter(&self) -> Option<Rc<CatchFormalParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CatchClauseContextAttrs<'input> for CatchClauseContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn catchClause(&mut self,)
	-> Result<Rc<CatchClauseContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CatchClauseContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 364, RULE_catchClause);
        let mut _localctx: Rc<CatchClauseContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2005);
			recog.base.match_token(CATCH,&mut recog.err_handler)?;

			recog.base.set_state(2006);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule catchFormalParameter*/
			recog.base.set_state(2007);
			recog.catchFormalParameter()?;

			recog.base.set_state(2008);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule block*/
			recog.base.set_state(2009);
			recog.block()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- catchFormalParameter ----------------
pub type CatchFormalParameterContextAll<'input> = CatchFormalParameterContext<'input>;


pub type CatchFormalParameterContext<'input> = BaseParserRuleContext<'input,CatchFormalParameterContextExt<'input>>;

#[derive(Clone)]
pub struct CatchFormalParameterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for CatchFormalParameterContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for CatchFormalParameterContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_catchFormalParameter(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_catchFormalParameter(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for CatchFormalParameterContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_catchFormalParameter(self);
	}
}

impl<'input> CustomRuleContext<'input> for CatchFormalParameterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_catchFormalParameter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_catchFormalParameter }
}
antlr_rust::tid!{CatchFormalParameterContextExt<'a>}

impl<'input> CatchFormalParameterContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CatchFormalParameterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CatchFormalParameterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CatchFormalParameterContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<CatchFormalParameterContextExt<'input>>{

fn catchType(&self) -> Option<Rc<CatchTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableDeclaratorId(&self) -> Option<Rc<VariableDeclaratorIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableModifier_all(&self) ->  Vec<Rc<VariableModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn variableModifier(&self, i: usize) -> Option<Rc<VariableModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> CatchFormalParameterContextAttrs<'input> for CatchFormalParameterContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn catchFormalParameter(&mut self,)
	-> Result<Rc<CatchFormalParameterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CatchFormalParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 366, RULE_catchFormalParameter);
        let mut _localctx: Rc<CatchFormalParameterContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2014);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==FINAL || _la==AT {
				{
				{
				/*InvokeRule variableModifier*/
				recog.base.set_state(2011);
				recog.variableModifier()?;

				}
				}
				recog.base.set_state(2016);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule catchType*/
			recog.base.set_state(2017);
			recog.catchType()?;

			/*InvokeRule variableDeclaratorId*/
			recog.base.set_state(2018);
			recog.variableDeclaratorId()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- catchType ----------------
pub type CatchTypeContextAll<'input> = CatchTypeContext<'input>;


pub type CatchTypeContext<'input> = BaseParserRuleContext<'input,CatchTypeContextExt<'input>>;

#[derive(Clone)]
pub struct CatchTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for CatchTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for CatchTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_catchType(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_catchType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for CatchTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_catchType(self);
	}
}

impl<'input> CustomRuleContext<'input> for CatchTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_catchType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_catchType }
}
antlr_rust::tid!{CatchTypeContextExt<'a>}

impl<'input> CatchTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CatchTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CatchTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CatchTypeContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<CatchTypeContextExt<'input>>{

fn unannClassType(&self) -> Option<Rc<UnannClassTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token BITOR in current rule
fn BITOR_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token BITOR, starting from 0.
/// Returns `None` if number of children corresponding to token BITOR is less or equal than `i`.
fn BITOR(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(BITOR, i)
}
fn classType_all(&self) ->  Vec<Rc<ClassTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn classType(&self, i: usize) -> Option<Rc<ClassTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> CatchTypeContextAttrs<'input> for CatchTypeContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn catchType(&mut self,)
	-> Result<Rc<CatchTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CatchTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 368, RULE_catchType);
        let mut _localctx: Rc<CatchTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule unannClassType*/
			recog.base.set_state(2020);
			recog.unannClassType()?;

			recog.base.set_state(2025);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==BITOR {
				{
				{
				recog.base.set_state(2021);
				recog.base.match_token(BITOR,&mut recog.err_handler)?;

				/*InvokeRule classType*/
				recog.base.set_state(2022);
				recog.classType()?;

				}
				}
				recog.base.set_state(2027);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- finallyBlock ----------------
pub type FinallyBlockContextAll<'input> = FinallyBlockContext<'input>;


pub type FinallyBlockContext<'input> = BaseParserRuleContext<'input,FinallyBlockContextExt<'input>>;

#[derive(Clone)]
pub struct FinallyBlockContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for FinallyBlockContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for FinallyBlockContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_finallyBlock(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_finallyBlock(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for FinallyBlockContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_finallyBlock(self);
	}
}

impl<'input> CustomRuleContext<'input> for FinallyBlockContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_finallyBlock }
	//fn type_rule_index() -> usize where Self: Sized { RULE_finallyBlock }
}
antlr_rust::tid!{FinallyBlockContextExt<'a>}

impl<'input> FinallyBlockContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FinallyBlockContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FinallyBlockContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FinallyBlockContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<FinallyBlockContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FINALLY
/// Returns `None` if there is no child corresponding to token FINALLY
fn FINALLY(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(FINALLY, 0)
}
fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FinallyBlockContextAttrs<'input> for FinallyBlockContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn finallyBlock(&mut self,)
	-> Result<Rc<FinallyBlockContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FinallyBlockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 370, RULE_finallyBlock);
        let mut _localctx: Rc<FinallyBlockContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2028);
			recog.base.match_token(FINALLY,&mut recog.err_handler)?;

			/*InvokeRule block*/
			recog.base.set_state(2029);
			recog.block()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- tryWithResourcesStatement ----------------
pub type TryWithResourcesStatementContextAll<'input> = TryWithResourcesStatementContext<'input>;


pub type TryWithResourcesStatementContext<'input> = BaseParserRuleContext<'input,TryWithResourcesStatementContextExt<'input>>;

#[derive(Clone)]
pub struct TryWithResourcesStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for TryWithResourcesStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for TryWithResourcesStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_tryWithResourcesStatement(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_tryWithResourcesStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for TryWithResourcesStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_tryWithResourcesStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for TryWithResourcesStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_tryWithResourcesStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_tryWithResourcesStatement }
}
antlr_rust::tid!{TryWithResourcesStatementContextExt<'a>}

impl<'input> TryWithResourcesStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TryWithResourcesStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TryWithResourcesStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TryWithResourcesStatementContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<TryWithResourcesStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token TRY
/// Returns `None` if there is no child corresponding to token TRY
fn TRY(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(TRY, 0)
}
fn resourceSpecification(&self) -> Option<Rc<ResourceSpecificationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn catches(&self) -> Option<Rc<CatchesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn finallyBlock(&self) -> Option<Rc<FinallyBlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TryWithResourcesStatementContextAttrs<'input> for TryWithResourcesStatementContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn tryWithResourcesStatement(&mut self,)
	-> Result<Rc<TryWithResourcesStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TryWithResourcesStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 372, RULE_tryWithResourcesStatement);
        let mut _localctx: Rc<TryWithResourcesStatementContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2031);
			recog.base.match_token(TRY,&mut recog.err_handler)?;

			/*InvokeRule resourceSpecification*/
			recog.base.set_state(2032);
			recog.resourceSpecification()?;

			/*InvokeRule block*/
			recog.base.set_state(2033);
			recog.block()?;

			recog.base.set_state(2035);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==CATCH {
				{
				/*InvokeRule catches*/
				recog.base.set_state(2034);
				recog.catches()?;

				}
			}

			recog.base.set_state(2038);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==FINALLY {
				{
				/*InvokeRule finallyBlock*/
				recog.base.set_state(2037);
				recog.finallyBlock()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- resourceSpecification ----------------
pub type ResourceSpecificationContextAll<'input> = ResourceSpecificationContext<'input>;


pub type ResourceSpecificationContext<'input> = BaseParserRuleContext<'input,ResourceSpecificationContextExt<'input>>;

#[derive(Clone)]
pub struct ResourceSpecificationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ResourceSpecificationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ResourceSpecificationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_resourceSpecification(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_resourceSpecification(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ResourceSpecificationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_resourceSpecification(self);
	}
}

impl<'input> CustomRuleContext<'input> for ResourceSpecificationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_resourceSpecification }
	//fn type_rule_index() -> usize where Self: Sized { RULE_resourceSpecification }
}
antlr_rust::tid!{ResourceSpecificationContextExt<'a>}

impl<'input> ResourceSpecificationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ResourceSpecificationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ResourceSpecificationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ResourceSpecificationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ResourceSpecificationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn resourceList(&self) -> Option<Rc<ResourceListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> ResourceSpecificationContextAttrs<'input> for ResourceSpecificationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn resourceSpecification(&mut self,)
	-> Result<Rc<ResourceSpecificationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ResourceSpecificationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 374, RULE_resourceSpecification);
        let mut _localctx: Rc<ResourceSpecificationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2040);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule resourceList*/
			recog.base.set_state(2041);
			recog.resourceList()?;

			recog.base.set_state(2043);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==SEMI {
				{
				recog.base.set_state(2042);
				recog.base.match_token(SEMI,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(2045);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- resourceList ----------------
pub type ResourceListContextAll<'input> = ResourceListContext<'input>;


pub type ResourceListContext<'input> = BaseParserRuleContext<'input,ResourceListContextExt<'input>>;

#[derive(Clone)]
pub struct ResourceListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ResourceListContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ResourceListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_resourceList(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_resourceList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ResourceListContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_resourceList(self);
	}
}

impl<'input> CustomRuleContext<'input> for ResourceListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_resourceList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_resourceList }
}
antlr_rust::tid!{ResourceListContextExt<'a>}

impl<'input> ResourceListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ResourceListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ResourceListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ResourceListContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ResourceListContextExt<'input>>{

fn resource_all(&self) ->  Vec<Rc<ResourceContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn resource(&self, i: usize) -> Option<Rc<ResourceContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token SEMI in current rule
fn SEMI_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token SEMI, starting from 0.
/// Returns `None` if number of children corresponding to token SEMI is less or equal than `i`.
fn SEMI(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, i)
}

}

impl<'input> ResourceListContextAttrs<'input> for ResourceListContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn resourceList(&mut self,)
	-> Result<Rc<ResourceListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ResourceListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 376, RULE_resourceList);
        let mut _localctx: Rc<ResourceListContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule resource*/
			recog.base.set_state(2047);
			recog.resource()?;

			recog.base.set_state(2052);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(221,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2048);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					/*InvokeRule resource*/
					recog.base.set_state(2049);
					recog.resource()?;

					}
					} 
				}
				recog.base.set_state(2054);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(221,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- resource ----------------
pub type ResourceContextAll<'input> = ResourceContext<'input>;


pub type ResourceContext<'input> = BaseParserRuleContext<'input,ResourceContextExt<'input>>;

#[derive(Clone)]
pub struct ResourceContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ResourceContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ResourceContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_resource(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_resource(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ResourceContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_resource(self);
	}
}

impl<'input> CustomRuleContext<'input> for ResourceContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_resource }
	//fn type_rule_index() -> usize where Self: Sized { RULE_resource }
}
antlr_rust::tid!{ResourceContextExt<'a>}

impl<'input> ResourceContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ResourceContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ResourceContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ResourceContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ResourceContextExt<'input>>{

fn localVariableDeclaration(&self) -> Option<Rc<LocalVariableDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableAccess(&self) -> Option<Rc<VariableAccessContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ResourceContextAttrs<'input> for ResourceContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn resource(&mut self,)
	-> Result<Rc<ResourceContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ResourceContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 378, RULE_resource);
        let mut _localctx: Rc<ResourceContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2057);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(222,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule localVariableDeclaration*/
					recog.base.set_state(2055);
					recog.localVariableDeclaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule variableAccess*/
					recog.base.set_state(2056);
					recog.variableAccess()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- variableAccess ----------------
pub type VariableAccessContextAll<'input> = VariableAccessContext<'input>;


pub type VariableAccessContext<'input> = BaseParserRuleContext<'input,VariableAccessContextExt<'input>>;

#[derive(Clone)]
pub struct VariableAccessContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for VariableAccessContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for VariableAccessContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_variableAccess(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_variableAccess(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for VariableAccessContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_variableAccess(self);
	}
}

impl<'input> CustomRuleContext<'input> for VariableAccessContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_variableAccess }
	//fn type_rule_index() -> usize where Self: Sized { RULE_variableAccess }
}
antlr_rust::tid!{VariableAccessContextExt<'a>}

impl<'input> VariableAccessContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VariableAccessContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VariableAccessContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VariableAccessContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<VariableAccessContextExt<'input>>{

fn expressionName(&self) -> Option<Rc<ExpressionNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn fieldAccess(&self) -> Option<Rc<FieldAccessContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> VariableAccessContextAttrs<'input> for VariableAccessContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn variableAccess(&mut self,)
	-> Result<Rc<VariableAccessContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VariableAccessContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 380, RULE_variableAccess);
        let mut _localctx: Rc<VariableAccessContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2061);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(223,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule expressionName*/
					recog.base.set_state(2059);
					recog.expressionName()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule fieldAccess*/
					recog.base.set_state(2060);
					recog.fieldAccess()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- yieldStatement ----------------
pub type YieldStatementContextAll<'input> = YieldStatementContext<'input>;


pub type YieldStatementContext<'input> = BaseParserRuleContext<'input,YieldStatementContextExt<'input>>;

#[derive(Clone)]
pub struct YieldStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for YieldStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for YieldStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_yieldStatement(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_yieldStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for YieldStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_yieldStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for YieldStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_yieldStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_yieldStatement }
}
antlr_rust::tid!{YieldStatementContextExt<'a>}

impl<'input> YieldStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<YieldStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,YieldStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait YieldStatementContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<YieldStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token YIELD
/// Returns `None` if there is no child corresponding to token YIELD
fn YIELD(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(YIELD, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> YieldStatementContextAttrs<'input> for YieldStatementContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn yieldStatement(&mut self,)
	-> Result<Rc<YieldStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = YieldStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 382, RULE_yieldStatement);
        let mut _localctx: Rc<YieldStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2063);
			recog.base.match_token(YIELD,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(2064);
			recog.expression()?;

			recog.base.set_state(2065);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- pattern ----------------
pub type PatternContextAll<'input> = PatternContext<'input>;


pub type PatternContext<'input> = BaseParserRuleContext<'input,PatternContextExt<'input>>;

#[derive(Clone)]
pub struct PatternContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for PatternContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for PatternContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_pattern(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_pattern(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for PatternContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_pattern(self);
	}
}

impl<'input> CustomRuleContext<'input> for PatternContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pattern }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pattern }
}
antlr_rust::tid!{PatternContextExt<'a>}

impl<'input> PatternContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PatternContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PatternContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PatternContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<PatternContextExt<'input>>{

fn typePattern(&self) -> Option<Rc<TypePatternContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PatternContextAttrs<'input> for PatternContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn pattern(&mut self,)
	-> Result<Rc<PatternContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PatternContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 384, RULE_pattern);
        let mut _localctx: Rc<PatternContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule typePattern*/
			recog.base.set_state(2067);
			recog.typePattern()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typePattern ----------------
pub type TypePatternContextAll<'input> = TypePatternContext<'input>;


pub type TypePatternContext<'input> = BaseParserRuleContext<'input,TypePatternContextExt<'input>>;

#[derive(Clone)]
pub struct TypePatternContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for TypePatternContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for TypePatternContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typePattern(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_typePattern(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for TypePatternContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_typePattern(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypePatternContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typePattern }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typePattern }
}
antlr_rust::tid!{TypePatternContextExt<'a>}

impl<'input> TypePatternContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypePatternContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypePatternContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypePatternContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<TypePatternContextExt<'input>>{

fn localVariableDeclaration(&self) -> Option<Rc<LocalVariableDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypePatternContextAttrs<'input> for TypePatternContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typePattern(&mut self,)
	-> Result<Rc<TypePatternContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypePatternContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 386, RULE_typePattern);
        let mut _localctx: Rc<TypePatternContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule localVariableDeclaration*/
			recog.base.set_state(2069);
			recog.localVariableDeclaration()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- expression ----------------
pub type ExpressionContextAll<'input> = ExpressionContext<'input>;


pub type ExpressionContext<'input> = BaseParserRuleContext<'input,ExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_expression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_expression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_expression(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}
antlr_rust::tid!{ExpressionContextExt<'a>}

impl<'input> ExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ExpressionContextExt<'input>>{

fn lambdaExpression(&self) -> Option<Rc<LambdaExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn assignmentExpression(&self) -> Option<Rc<AssignmentExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ExpressionContextAttrs<'input> for ExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn expression(&mut self,)
	-> Result<Rc<ExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 388, RULE_expression);
        let mut _localctx: Rc<ExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2073);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(224,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule lambdaExpression*/
					recog.base.set_state(2071);
					recog.lambdaExpression()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule assignmentExpression*/
					recog.base.set_state(2072);
					recog.assignmentExpression()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- primary ----------------
pub type PrimaryContextAll<'input> = PrimaryContext<'input>;


pub type PrimaryContext<'input> = BaseParserRuleContext<'input,PrimaryContextExt<'input>>;

#[derive(Clone)]
pub struct PrimaryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for PrimaryContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for PrimaryContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_primary(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_primary(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for PrimaryContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_primary(self);
	}
}

impl<'input> CustomRuleContext<'input> for PrimaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primary }
}
antlr_rust::tid!{PrimaryContextExt<'a>}

impl<'input> PrimaryContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrimaryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrimaryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrimaryContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<PrimaryContextExt<'input>>{

fn primaryNoNewArray(&self) -> Option<Rc<PrimaryNoNewArrayContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn arrayCreationExpression(&self) -> Option<Rc<ArrayCreationExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PrimaryContextAttrs<'input> for PrimaryContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn primary(&mut self,)
	-> Result<Rc<PrimaryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrimaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 390, RULE_primary);
        let mut _localctx: Rc<PrimaryContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2077);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(225,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule primaryNoNewArray*/
					recog.base.set_state(2075);
					recog.primaryNoNewArray()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule arrayCreationExpression*/
					recog.base.set_state(2076);
					recog.arrayCreationExpression()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- primaryNoNewArray ----------------
pub type PrimaryNoNewArrayContextAll<'input> = PrimaryNoNewArrayContext<'input>;


pub type PrimaryNoNewArrayContext<'input> = BaseParserRuleContext<'input,PrimaryNoNewArrayContextExt<'input>>;

#[derive(Clone)]
pub struct PrimaryNoNewArrayContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for PrimaryNoNewArrayContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for PrimaryNoNewArrayContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_primaryNoNewArray(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_primaryNoNewArray(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for PrimaryNoNewArrayContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_primaryNoNewArray(self);
	}
}

impl<'input> CustomRuleContext<'input> for PrimaryNoNewArrayContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryNoNewArray }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryNoNewArray }
}
antlr_rust::tid!{PrimaryNoNewArrayContextExt<'a>}

impl<'input> PrimaryNoNewArrayContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrimaryNoNewArrayContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrimaryNoNewArrayContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrimaryNoNewArrayContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<PrimaryNoNewArrayContextExt<'input>>{

fn literal(&self) -> Option<Rc<LiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn pNNA(&self) -> Option<Rc<PNNAContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classLiteral(&self) -> Option<Rc<ClassLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token THIS
/// Returns `None` if there is no child corresponding to token THIS
fn THIS(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(THIS, 0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
/// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, i)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn unqualifiedClassInstanceCreationExpression(&self) -> Option<Rc<UnqualifiedClassInstanceCreationExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expressionName(&self) -> Option<Rc<ExpressionNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn arrayCreationExpression(&self) -> Option<Rc<ArrayCreationExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
/// Retrieves first TerminalNode corresponding to token SUPER
/// Returns `None` if there is no child corresponding to token SUPER
fn SUPER(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SUPER, 0)
}
/// Retrieves first TerminalNode corresponding to token LBRACK
/// Returns `None` if there is no child corresponding to token LBRACK
fn LBRACK(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LBRACK, 0)
}
/// Retrieves first TerminalNode corresponding to token RBRACK
/// Returns `None` if there is no child corresponding to token RBRACK
fn RBRACK(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RBRACK, 0)
}
fn arrayCreationExpressionWithInitializer(&self) -> Option<Rc<ArrayCreationExpressionWithInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodName(&self) -> Option<Rc<MethodNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn argumentList(&self) -> Option<Rc<ArgumentListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLONCOLON
/// Returns `None` if there is no child corresponding to token COLONCOLON
fn COLONCOLON(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COLONCOLON, 0)
}
fn referenceType(&self) -> Option<Rc<ReferenceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classType(&self) -> Option<Rc<ClassTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token NEW
/// Returns `None` if there is no child corresponding to token NEW
fn NEW(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(NEW, 0)
}
fn arrayType(&self) -> Option<Rc<ArrayTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PrimaryNoNewArrayContextAttrs<'input> for PrimaryNoNewArrayContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn primaryNoNewArray(&mut self,)
	-> Result<Rc<PrimaryNoNewArrayContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrimaryNoNewArrayContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 392, RULE_primaryNoNewArray);
        let mut _localctx: Rc<PrimaryNoNewArrayContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2296);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(269,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule literal*/
					recog.base.set_state(2079);
					recog.literal()?;

					recog.base.set_state(2081);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(226,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2080);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule classLiteral*/
					recog.base.set_state(2083);
					recog.classLiteral()?;

					recog.base.set_state(2085);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(227,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2084);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(2087);
					recog.base.match_token(THIS,&mut recog.err_handler)?;

					recog.base.set_state(2089);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(228,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2088);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule typeName*/
					recog.base.set_state(2091);
					recog.typeName()?;

					recog.base.set_state(2092);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2093);
					recog.base.match_token(THIS,&mut recog.err_handler)?;

					recog.base.set_state(2095);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(229,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2094);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(2097);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(2098);
					recog.expression()?;

					recog.base.set_state(2099);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2101);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(230,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2100);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule unqualifiedClassInstanceCreationExpression*/
					recog.base.set_state(2103);
					recog.unqualifiedClassInstanceCreationExpression()?;

					recog.base.set_state(2105);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(231,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2104);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule expressionName*/
					recog.base.set_state(2107);
					recog.expressionName()?;

					recog.base.set_state(2108);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					/*InvokeRule unqualifiedClassInstanceCreationExpression*/
					recog.base.set_state(2109);
					recog.unqualifiedClassInstanceCreationExpression()?;

					recog.base.set_state(2111);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(232,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2110);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				8 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule arrayCreationExpression*/
					recog.base.set_state(2113);
					recog.arrayCreationExpression()?;

					recog.base.set_state(2114);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					/*InvokeRule unqualifiedClassInstanceCreationExpression*/
					recog.base.set_state(2115);
					recog.unqualifiedClassInstanceCreationExpression()?;

					recog.base.set_state(2117);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(233,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2116);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				9 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					/*InvokeRule arrayCreationExpression*/
					recog.base.set_state(2119);
					recog.arrayCreationExpression()?;

					recog.base.set_state(2120);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2121);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					recog.base.set_state(2123);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(234,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2122);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				10 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					recog.base.set_state(2125);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2126);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2127);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					recog.base.set_state(2129);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(235,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2128);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				11 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 11);
					recog.base.enter_outer_alt(None, 11);
					{
					/*InvokeRule typeName*/
					recog.base.set_state(2131);
					recog.typeName()?;

					recog.base.set_state(2132);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2133);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2134);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2135);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					recog.base.set_state(2137);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(236,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2136);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				12 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 12);
					recog.base.enter_outer_alt(None, 12);
					{
					/*InvokeRule expressionName*/
					recog.base.set_state(2139);
					recog.expressionName()?;

					recog.base.set_state(2140);
					recog.base.match_token(LBRACK,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(2141);
					recog.expression()?;

					recog.base.set_state(2142);
					recog.base.match_token(RBRACK,&mut recog.err_handler)?;

					recog.base.set_state(2144);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(237,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2143);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				13 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 13);
					recog.base.enter_outer_alt(None, 13);
					{
					/*InvokeRule arrayCreationExpressionWithInitializer*/
					recog.base.set_state(2146);
					recog.arrayCreationExpressionWithInitializer()?;

					recog.base.set_state(2147);
					recog.base.match_token(LBRACK,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(2148);
					recog.expression()?;

					recog.base.set_state(2149);
					recog.base.match_token(RBRACK,&mut recog.err_handler)?;

					recog.base.set_state(2151);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(238,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2150);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				14 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 14);
					recog.base.enter_outer_alt(None, 14);
					{
					/*InvokeRule methodName*/
					recog.base.set_state(2153);
					recog.methodName()?;

					recog.base.set_state(2154);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2156);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (FLOAT - 37)) | (1usize << (INT - 37)) | (1usize << (LONG - 37)) | (1usize << (NEW - 37)) | (1usize << (SHORT - 37)) | (1usize << (SUPER - 37)) | (1usize << (SWITCH - 37)) | (1usize << (THIS - 37)) | (1usize << (VOID - 37)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (AT - 69)) | (1usize << (BANG - 69)) | (1usize << (TILDE - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (ADD - 102)) | (1usize << (SUB - 102)) | (1usize << (Identifier - 102)))) != 0) {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2155);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2158);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2160);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(240,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2159);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				15 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 15);
					recog.base.enter_outer_alt(None, 15);
					{
					/*InvokeRule typeName*/
					recog.base.set_state(2162);
					recog.typeName()?;

					recog.base.set_state(2163);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2165);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2164);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2167);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					recog.base.set_state(2168);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2170);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (FLOAT - 37)) | (1usize << (INT - 37)) | (1usize << (LONG - 37)) | (1usize << (NEW - 37)) | (1usize << (SHORT - 37)) | (1usize << (SUPER - 37)) | (1usize << (SWITCH - 37)) | (1usize << (THIS - 37)) | (1usize << (VOID - 37)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (AT - 69)) | (1usize << (BANG - 69)) | (1usize << (TILDE - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (ADD - 102)) | (1usize << (SUB - 102)) | (1usize << (Identifier - 102)))) != 0) {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2169);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2172);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2174);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(243,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2173);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				16 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 16);
					recog.base.enter_outer_alt(None, 16);
					{
					/*InvokeRule expressionName*/
					recog.base.set_state(2176);
					recog.expressionName()?;

					recog.base.set_state(2177);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2179);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2178);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2181);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					recog.base.set_state(2182);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2184);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (FLOAT - 37)) | (1usize << (INT - 37)) | (1usize << (LONG - 37)) | (1usize << (NEW - 37)) | (1usize << (SHORT - 37)) | (1usize << (SUPER - 37)) | (1usize << (SWITCH - 37)) | (1usize << (THIS - 37)) | (1usize << (VOID - 37)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (AT - 69)) | (1usize << (BANG - 69)) | (1usize << (TILDE - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (ADD - 102)) | (1usize << (SUB - 102)) | (1usize << (Identifier - 102)))) != 0) {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2183);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2186);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2188);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(246,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2187);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				17 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 17);
					recog.base.enter_outer_alt(None, 17);
					{
					/*InvokeRule arrayCreationExpression*/
					recog.base.set_state(2190);
					recog.arrayCreationExpression()?;

					recog.base.set_state(2191);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2193);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2192);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2195);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					recog.base.set_state(2196);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2198);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (FLOAT - 37)) | (1usize << (INT - 37)) | (1usize << (LONG - 37)) | (1usize << (NEW - 37)) | (1usize << (SHORT - 37)) | (1usize << (SUPER - 37)) | (1usize << (SWITCH - 37)) | (1usize << (THIS - 37)) | (1usize << (VOID - 37)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (AT - 69)) | (1usize << (BANG - 69)) | (1usize << (TILDE - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (ADD - 102)) | (1usize << (SUB - 102)) | (1usize << (Identifier - 102)))) != 0) {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2197);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2200);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2202);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(249,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2201);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				18 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 18);
					recog.base.enter_outer_alt(None, 18);
					{
					recog.base.set_state(2204);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2205);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2207);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2206);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2209);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					recog.base.set_state(2210);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2212);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (FLOAT - 37)) | (1usize << (INT - 37)) | (1usize << (LONG - 37)) | (1usize << (NEW - 37)) | (1usize << (SHORT - 37)) | (1usize << (SUPER - 37)) | (1usize << (SWITCH - 37)) | (1usize << (THIS - 37)) | (1usize << (VOID - 37)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (AT - 69)) | (1usize << (BANG - 69)) | (1usize << (TILDE - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (ADD - 102)) | (1usize << (SUB - 102)) | (1usize << (Identifier - 102)))) != 0) {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2211);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2214);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2216);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(252,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2215);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				19 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 19);
					recog.base.enter_outer_alt(None, 19);
					{
					/*InvokeRule typeName*/
					recog.base.set_state(2218);
					recog.typeName()?;

					recog.base.set_state(2219);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2220);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2221);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2223);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2222);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2225);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					recog.base.set_state(2226);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2228);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (FLOAT - 37)) | (1usize << (INT - 37)) | (1usize << (LONG - 37)) | (1usize << (NEW - 37)) | (1usize << (SHORT - 37)) | (1usize << (SUPER - 37)) | (1usize << (SWITCH - 37)) | (1usize << (THIS - 37)) | (1usize << (VOID - 37)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (AT - 69)) | (1usize << (BANG - 69)) | (1usize << (TILDE - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (ADD - 102)) | (1usize << (SUB - 102)) | (1usize << (Identifier - 102)))) != 0) {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2227);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2230);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2232);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(255,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2231);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				20 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 20);
					recog.base.enter_outer_alt(None, 20);
					{
					/*InvokeRule expressionName*/
					recog.base.set_state(2234);
					recog.expressionName()?;

					recog.base.set_state(2235);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2237);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2236);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2239);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					recog.base.set_state(2241);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(257,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2240);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				21 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 21);
					recog.base.enter_outer_alt(None, 21);
					{
					/*InvokeRule arrayCreationExpression*/
					recog.base.set_state(2243);
					recog.arrayCreationExpression()?;

					recog.base.set_state(2244);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2246);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2245);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2248);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					recog.base.set_state(2250);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(259,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2249);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				22 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 22);
					recog.base.enter_outer_alt(None, 22);
					{
					/*InvokeRule referenceType*/
					recog.base.set_state(2252);
					recog.referenceType()?;

					recog.base.set_state(2253);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2255);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2254);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2257);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					recog.base.set_state(2259);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(261,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2258);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				23 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 23);
					recog.base.enter_outer_alt(None, 23);
					{
					recog.base.set_state(2261);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2262);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2264);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2263);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2266);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					recog.base.set_state(2268);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(263,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2267);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				24 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 24);
					recog.base.enter_outer_alt(None, 24);
					{
					/*InvokeRule typeName*/
					recog.base.set_state(2270);
					recog.typeName()?;

					recog.base.set_state(2271);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2272);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2273);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2275);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2274);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2277);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					recog.base.set_state(2279);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(265,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2278);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				25 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 25);
					recog.base.enter_outer_alt(None, 25);
					{
					/*InvokeRule classType*/
					recog.base.set_state(2281);
					recog.classType()?;

					recog.base.set_state(2282);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2284);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2283);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2286);
					recog.base.match_token(NEW,&mut recog.err_handler)?;

					recog.base.set_state(2288);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(267,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2287);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				26 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 26);
					recog.base.enter_outer_alt(None, 26);
					{
					/*InvokeRule arrayType*/
					recog.base.set_state(2290);
					recog.arrayType()?;

					recog.base.set_state(2291);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2292);
					recog.base.match_token(NEW,&mut recog.err_handler)?;

					recog.base.set_state(2294);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(268,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2293);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- pNNA ----------------
pub type PNNAContextAll<'input> = PNNAContext<'input>;


pub type PNNAContext<'input> = BaseParserRuleContext<'input,PNNAContextExt<'input>>;

#[derive(Clone)]
pub struct PNNAContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for PNNAContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for PNNAContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_pNNA(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_pNNA(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for PNNAContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_pNNA(self);
	}
}

impl<'input> CustomRuleContext<'input> for PNNAContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pNNA }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pNNA }
}
antlr_rust::tid!{PNNAContextExt<'a>}

impl<'input> PNNAContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PNNAContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PNNAContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PNNAContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<PNNAContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn unqualifiedClassInstanceCreationExpression(&self) -> Option<Rc<UnqualifiedClassInstanceCreationExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn pNNA(&self) -> Option<Rc<PNNAContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
/// Retrieves first TerminalNode corresponding to token LBRACK
/// Returns `None` if there is no child corresponding to token LBRACK
fn LBRACK(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LBRACK, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RBRACK
/// Returns `None` if there is no child corresponding to token RBRACK
fn RBRACK(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RBRACK, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn argumentList(&self) -> Option<Rc<ArgumentListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLONCOLON
/// Returns `None` if there is no child corresponding to token COLONCOLON
fn COLONCOLON(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COLONCOLON, 0)
}

}

impl<'input> PNNAContextAttrs<'input> for PNNAContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn pNNA(&mut self,)
	-> Result<Rc<PNNAContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PNNAContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 394, RULE_pNNA);
        let mut _localctx: Rc<PNNAContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2335);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(278,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2298);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					/*InvokeRule unqualifiedClassInstanceCreationExpression*/
					recog.base.set_state(2299);
					recog.unqualifiedClassInstanceCreationExpression()?;

					recog.base.set_state(2301);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(270,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2300);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2303);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2304);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					recog.base.set_state(2306);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(271,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2305);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(2308);
					recog.base.match_token(LBRACK,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(2309);
					recog.expression()?;

					recog.base.set_state(2310);
					recog.base.match_token(RBRACK,&mut recog.err_handler)?;

					recog.base.set_state(2312);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(272,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2311);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(2314);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2316);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2315);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2318);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					recog.base.set_state(2319);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2321);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (FLOAT - 37)) | (1usize << (INT - 37)) | (1usize << (LONG - 37)) | (1usize << (NEW - 37)) | (1usize << (SHORT - 37)) | (1usize << (SUPER - 37)) | (1usize << (SWITCH - 37)) | (1usize << (THIS - 37)) | (1usize << (VOID - 37)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (AT - 69)) | (1usize << (BANG - 69)) | (1usize << (TILDE - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (ADD - 102)) | (1usize << (SUB - 102)) | (1usize << (Identifier - 102)))) != 0) {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2320);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2323);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2325);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(275,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2324);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(2327);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2329);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2328);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2331);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					recog.base.set_state(2333);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(277,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pNNA*/
							recog.base.set_state(2332);
							recog.pNNA()?;

							}
						}

						_ => {}
					}
					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classLiteral ----------------
pub type ClassLiteralContextAll<'input> = ClassLiteralContext<'input>;


pub type ClassLiteralContext<'input> = BaseParserRuleContext<'input,ClassLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct ClassLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ClassLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ClassLiteralContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classLiteral(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_classLiteral(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ClassLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_classLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classLiteral }
}
antlr_rust::tid!{ClassLiteralContextExt<'a>}

impl<'input> ClassLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassLiteralContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ClassLiteralContextExt<'input>>{

fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
/// Retrieves first TerminalNode corresponding to token CLASS
/// Returns `None` if there is no child corresponding to token CLASS
fn CLASS(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(CLASS, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token LBRACK in current rule
fn LBRACK_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token LBRACK, starting from 0.
/// Returns `None` if number of children corresponding to token LBRACK is less or equal than `i`.
fn LBRACK(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LBRACK, i)
}
/// Retrieves all `TerminalNode`s corresponding to token RBRACK in current rule
fn RBRACK_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token RBRACK, starting from 0.
/// Returns `None` if number of children corresponding to token RBRACK is less or equal than `i`.
fn RBRACK(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RBRACK, i)
}
fn numericType(&self) -> Option<Rc<NumericTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token BOOLEAN
/// Returns `None` if there is no child corresponding to token BOOLEAN
fn BOOLEAN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(BOOLEAN, 0)
}
/// Retrieves first TerminalNode corresponding to token VOID
/// Returns `None` if there is no child corresponding to token VOID
fn VOID(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(VOID, 0)
}

}

impl<'input> ClassLiteralContextAttrs<'input> for ClassLiteralContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classLiteral(&mut self,)
	-> Result<Rc<ClassLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 396, RULE_classLiteral);
        let mut _localctx: Rc<ClassLiteralContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2372);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule typeName*/
					recog.base.set_state(2337);
					recog.typeName()?;

					recog.base.set_state(2342);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==LBRACK {
						{
						{
						recog.base.set_state(2338);
						recog.base.match_token(LBRACK,&mut recog.err_handler)?;

						recog.base.set_state(2339);
						recog.base.match_token(RBRACK,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2344);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2345);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2346);
					recog.base.match_token(CLASS,&mut recog.err_handler)?;

					}
				}

			 BYTE | CHAR | DOUBLE | FLOAT | INT | LONG | SHORT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule numericType*/
					recog.base.set_state(2348);
					recog.numericType()?;

					recog.base.set_state(2353);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==LBRACK {
						{
						{
						recog.base.set_state(2349);
						recog.base.match_token(LBRACK,&mut recog.err_handler)?;

						recog.base.set_state(2350);
						recog.base.match_token(RBRACK,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2355);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2356);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2357);
					recog.base.match_token(CLASS,&mut recog.err_handler)?;

					}
				}

			 BOOLEAN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(2359);
					recog.base.match_token(BOOLEAN,&mut recog.err_handler)?;

					recog.base.set_state(2364);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==LBRACK {
						{
						{
						recog.base.set_state(2360);
						recog.base.match_token(LBRACK,&mut recog.err_handler)?;

						recog.base.set_state(2361);
						recog.base.match_token(RBRACK,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2366);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2367);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2368);
					recog.base.match_token(CLASS,&mut recog.err_handler)?;

					}
				}

			 VOID 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(2369);
					recog.base.match_token(VOID,&mut recog.err_handler)?;

					recog.base.set_state(2370);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2371);
					recog.base.match_token(CLASS,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classInstanceCreationExpression ----------------
pub type ClassInstanceCreationExpressionContextAll<'input> = ClassInstanceCreationExpressionContext<'input>;


pub type ClassInstanceCreationExpressionContext<'input> = BaseParserRuleContext<'input,ClassInstanceCreationExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ClassInstanceCreationExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ClassInstanceCreationExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ClassInstanceCreationExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classInstanceCreationExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_classInstanceCreationExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ClassInstanceCreationExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_classInstanceCreationExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassInstanceCreationExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classInstanceCreationExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classInstanceCreationExpression }
}
antlr_rust::tid!{ClassInstanceCreationExpressionContextExt<'a>}

impl<'input> ClassInstanceCreationExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassInstanceCreationExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassInstanceCreationExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassInstanceCreationExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ClassInstanceCreationExpressionContextExt<'input>>{

fn unqualifiedClassInstanceCreationExpression(&self) -> Option<Rc<UnqualifiedClassInstanceCreationExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expressionName(&self) -> Option<Rc<ExpressionNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn primary(&self) -> Option<Rc<PrimaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ClassInstanceCreationExpressionContextAttrs<'input> for ClassInstanceCreationExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classInstanceCreationExpression(&mut self,)
	-> Result<Rc<ClassInstanceCreationExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassInstanceCreationExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 398, RULE_classInstanceCreationExpression);
        let mut _localctx: Rc<ClassInstanceCreationExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2383);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(283,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule unqualifiedClassInstanceCreationExpression*/
					recog.base.set_state(2374);
					recog.unqualifiedClassInstanceCreationExpression()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule expressionName*/
					recog.base.set_state(2375);
					recog.expressionName()?;

					recog.base.set_state(2376);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					/*InvokeRule unqualifiedClassInstanceCreationExpression*/
					recog.base.set_state(2377);
					recog.unqualifiedClassInstanceCreationExpression()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule primary*/
					recog.base.set_state(2379);
					recog.primary()?;

					recog.base.set_state(2380);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					/*InvokeRule unqualifiedClassInstanceCreationExpression*/
					recog.base.set_state(2381);
					recog.unqualifiedClassInstanceCreationExpression()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unqualifiedClassInstanceCreationExpression ----------------
pub type UnqualifiedClassInstanceCreationExpressionContextAll<'input> = UnqualifiedClassInstanceCreationExpressionContext<'input>;


pub type UnqualifiedClassInstanceCreationExpressionContext<'input> = BaseParserRuleContext<'input,UnqualifiedClassInstanceCreationExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct UnqualifiedClassInstanceCreationExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for UnqualifiedClassInstanceCreationExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for UnqualifiedClassInstanceCreationExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unqualifiedClassInstanceCreationExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_unqualifiedClassInstanceCreationExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for UnqualifiedClassInstanceCreationExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_unqualifiedClassInstanceCreationExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnqualifiedClassInstanceCreationExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unqualifiedClassInstanceCreationExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unqualifiedClassInstanceCreationExpression }
}
antlr_rust::tid!{UnqualifiedClassInstanceCreationExpressionContextExt<'a>}

impl<'input> UnqualifiedClassInstanceCreationExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnqualifiedClassInstanceCreationExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnqualifiedClassInstanceCreationExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnqualifiedClassInstanceCreationExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<UnqualifiedClassInstanceCreationExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token NEW
/// Returns `None` if there is no child corresponding to token NEW
fn NEW(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(NEW, 0)
}
fn classOrInterfaceTypeToInstantiate(&self) -> Option<Rc<ClassOrInterfaceTypeToInstantiateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn argumentList(&self) -> Option<Rc<ArgumentListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classBody(&self) -> Option<Rc<ClassBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UnqualifiedClassInstanceCreationExpressionContextAttrs<'input> for UnqualifiedClassInstanceCreationExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unqualifiedClassInstanceCreationExpression(&mut self,)
	-> Result<Rc<UnqualifiedClassInstanceCreationExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnqualifiedClassInstanceCreationExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 400, RULE_unqualifiedClassInstanceCreationExpression);
        let mut _localctx: Rc<UnqualifiedClassInstanceCreationExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2385);
			recog.base.match_token(NEW,&mut recog.err_handler)?;

			recog.base.set_state(2387);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LT {
				{
				/*InvokeRule typeArguments*/
				recog.base.set_state(2386);
				recog.typeArguments()?;

				}
			}

			/*InvokeRule classOrInterfaceTypeToInstantiate*/
			recog.base.set_state(2389);
			recog.classOrInterfaceTypeToInstantiate()?;

			recog.base.set_state(2390);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(2392);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (FLOAT - 37)) | (1usize << (INT - 37)) | (1usize << (LONG - 37)) | (1usize << (NEW - 37)) | (1usize << (SHORT - 37)) | (1usize << (SUPER - 37)) | (1usize << (SWITCH - 37)) | (1usize << (THIS - 37)) | (1usize << (VOID - 37)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (AT - 69)) | (1usize << (BANG - 69)) | (1usize << (TILDE - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (ADD - 102)) | (1usize << (SUB - 102)) | (1usize << (Identifier - 102)))) != 0) {
				{
				/*InvokeRule argumentList*/
				recog.base.set_state(2391);
				recog.argumentList()?;

				}
			}

			recog.base.set_state(2394);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			recog.base.set_state(2396);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(286,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule classBody*/
					recog.base.set_state(2395);
					recog.classBody()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classOrInterfaceTypeToInstantiate ----------------
pub type ClassOrInterfaceTypeToInstantiateContextAll<'input> = ClassOrInterfaceTypeToInstantiateContext<'input>;


pub type ClassOrInterfaceTypeToInstantiateContext<'input> = BaseParserRuleContext<'input,ClassOrInterfaceTypeToInstantiateContextExt<'input>>;

#[derive(Clone)]
pub struct ClassOrInterfaceTypeToInstantiateContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ClassOrInterfaceTypeToInstantiateContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ClassOrInterfaceTypeToInstantiateContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classOrInterfaceTypeToInstantiate(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_classOrInterfaceTypeToInstantiate(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ClassOrInterfaceTypeToInstantiateContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_classOrInterfaceTypeToInstantiate(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassOrInterfaceTypeToInstantiateContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classOrInterfaceTypeToInstantiate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classOrInterfaceTypeToInstantiate }
}
antlr_rust::tid!{ClassOrInterfaceTypeToInstantiateContextExt<'a>}

impl<'input> ClassOrInterfaceTypeToInstantiateContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassOrInterfaceTypeToInstantiateContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassOrInterfaceTypeToInstantiateContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassOrInterfaceTypeToInstantiateContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ClassOrInterfaceTypeToInstantiateContextExt<'input>>{

/// Retrieves all `TerminalNode`s corresponding to token Identifier in current rule
fn Identifier_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Identifier, starting from 0.
/// Returns `None` if number of children corresponding to token Identifier is less or equal than `i`.
fn Identifier(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, i)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
/// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, i)
}
fn typeArgumentsOrDiamond(&self) -> Option<Rc<TypeArgumentsOrDiamondContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ClassOrInterfaceTypeToInstantiateContextAttrs<'input> for ClassOrInterfaceTypeToInstantiateContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classOrInterfaceTypeToInstantiate(&mut self,)
	-> Result<Rc<ClassOrInterfaceTypeToInstantiateContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassOrInterfaceTypeToInstantiateContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 402, RULE_classOrInterfaceTypeToInstantiate);
        let mut _localctx: Rc<ClassOrInterfaceTypeToInstantiateContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2401);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(2398);
				recog.annotation()?;

				}
				}
				recog.base.set_state(2403);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2404);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			recog.base.set_state(2415);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==DOT {
				{
				{
				recog.base.set_state(2405);
				recog.base.match_token(DOT,&mut recog.err_handler)?;

				recog.base.set_state(2409);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				while _la==AT {
					{
					{
					/*InvokeRule annotation*/
					recog.base.set_state(2406);
					recog.annotation()?;

					}
					}
					recog.base.set_state(2411);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
				}
				recog.base.set_state(2412);
				recog.base.match_token(Identifier,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2417);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2419);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==OACA || _la==LT {
				{
				/*InvokeRule typeArgumentsOrDiamond*/
				recog.base.set_state(2418);
				recog.typeArgumentsOrDiamond()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeArgumentsOrDiamond ----------------
pub type TypeArgumentsOrDiamondContextAll<'input> = TypeArgumentsOrDiamondContext<'input>;


pub type TypeArgumentsOrDiamondContext<'input> = BaseParserRuleContext<'input,TypeArgumentsOrDiamondContextExt<'input>>;

#[derive(Clone)]
pub struct TypeArgumentsOrDiamondContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for TypeArgumentsOrDiamondContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for TypeArgumentsOrDiamondContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeArgumentsOrDiamond(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_typeArgumentsOrDiamond(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for TypeArgumentsOrDiamondContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_typeArgumentsOrDiamond(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeArgumentsOrDiamondContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeArgumentsOrDiamond }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeArgumentsOrDiamond }
}
antlr_rust::tid!{TypeArgumentsOrDiamondContextExt<'a>}

impl<'input> TypeArgumentsOrDiamondContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeArgumentsOrDiamondContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeArgumentsOrDiamondContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeArgumentsOrDiamondContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<TypeArgumentsOrDiamondContextExt<'input>>{

fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token OACA
/// Returns `None` if there is no child corresponding to token OACA
fn OACA(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(OACA, 0)
}

}

impl<'input> TypeArgumentsOrDiamondContextAttrs<'input> for TypeArgumentsOrDiamondContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeArgumentsOrDiamond(&mut self,)
	-> Result<Rc<TypeArgumentsOrDiamondContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeArgumentsOrDiamondContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 404, RULE_typeArgumentsOrDiamond);
        let mut _localctx: Rc<TypeArgumentsOrDiamondContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2423);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule typeArguments*/
					recog.base.set_state(2421);
					recog.typeArguments()?;

					}
				}

			 OACA 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2422);
					recog.base.match_token(OACA,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- arrayCreationExpression ----------------
pub type ArrayCreationExpressionContextAll<'input> = ArrayCreationExpressionContext<'input>;


pub type ArrayCreationExpressionContext<'input> = BaseParserRuleContext<'input,ArrayCreationExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ArrayCreationExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ArrayCreationExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ArrayCreationExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_arrayCreationExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_arrayCreationExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ArrayCreationExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_arrayCreationExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for ArrayCreationExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_arrayCreationExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_arrayCreationExpression }
}
antlr_rust::tid!{ArrayCreationExpressionContextExt<'a>}

impl<'input> ArrayCreationExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ArrayCreationExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ArrayCreationExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ArrayCreationExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ArrayCreationExpressionContextExt<'input>>{

fn arrayCreationExpressionWithoutInitializer(&self) -> Option<Rc<ArrayCreationExpressionWithoutInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn arrayCreationExpressionWithInitializer(&self) -> Option<Rc<ArrayCreationExpressionWithInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ArrayCreationExpressionContextAttrs<'input> for ArrayCreationExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn arrayCreationExpression(&mut self,)
	-> Result<Rc<ArrayCreationExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ArrayCreationExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 406, RULE_arrayCreationExpression);
        let mut _localctx: Rc<ArrayCreationExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2427);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(292,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule arrayCreationExpressionWithoutInitializer*/
					recog.base.set_state(2425);
					recog.arrayCreationExpressionWithoutInitializer()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule arrayCreationExpressionWithInitializer*/
					recog.base.set_state(2426);
					recog.arrayCreationExpressionWithInitializer()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- arrayCreationExpressionWithoutInitializer ----------------
pub type ArrayCreationExpressionWithoutInitializerContextAll<'input> = ArrayCreationExpressionWithoutInitializerContext<'input>;


pub type ArrayCreationExpressionWithoutInitializerContext<'input> = BaseParserRuleContext<'input,ArrayCreationExpressionWithoutInitializerContextExt<'input>>;

#[derive(Clone)]
pub struct ArrayCreationExpressionWithoutInitializerContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ArrayCreationExpressionWithoutInitializerContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ArrayCreationExpressionWithoutInitializerContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_arrayCreationExpressionWithoutInitializer(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_arrayCreationExpressionWithoutInitializer(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ArrayCreationExpressionWithoutInitializerContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_arrayCreationExpressionWithoutInitializer(self);
	}
}

impl<'input> CustomRuleContext<'input> for ArrayCreationExpressionWithoutInitializerContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_arrayCreationExpressionWithoutInitializer }
	//fn type_rule_index() -> usize where Self: Sized { RULE_arrayCreationExpressionWithoutInitializer }
}
antlr_rust::tid!{ArrayCreationExpressionWithoutInitializerContextExt<'a>}

impl<'input> ArrayCreationExpressionWithoutInitializerContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ArrayCreationExpressionWithoutInitializerContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ArrayCreationExpressionWithoutInitializerContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ArrayCreationExpressionWithoutInitializerContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ArrayCreationExpressionWithoutInitializerContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token NEW
/// Returns `None` if there is no child corresponding to token NEW
fn NEW(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(NEW, 0)
}
fn primitiveType(&self) -> Option<Rc<PrimitiveTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dimExprs(&self) -> Option<Rc<DimExprsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dims(&self) -> Option<Rc<DimsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classType(&self) -> Option<Rc<ClassTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ArrayCreationExpressionWithoutInitializerContextAttrs<'input> for ArrayCreationExpressionWithoutInitializerContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn arrayCreationExpressionWithoutInitializer(&mut self,)
	-> Result<Rc<ArrayCreationExpressionWithoutInitializerContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ArrayCreationExpressionWithoutInitializerContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 408, RULE_arrayCreationExpressionWithoutInitializer);
        let mut _localctx: Rc<ArrayCreationExpressionWithoutInitializerContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2441);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(295,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2429);
					recog.base.match_token(NEW,&mut recog.err_handler)?;

					/*InvokeRule primitiveType*/
					recog.base.set_state(2430);
					recog.primitiveType()?;

					/*InvokeRule dimExprs*/
					recog.base.set_state(2431);
					recog.dimExprs()?;

					recog.base.set_state(2433);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(293,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule dims*/
							recog.base.set_state(2432);
							recog.dims()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2435);
					recog.base.match_token(NEW,&mut recog.err_handler)?;

					/*InvokeRule classType*/
					recog.base.set_state(2436);
					recog.classType()?;

					/*InvokeRule dimExprs*/
					recog.base.set_state(2437);
					recog.dimExprs()?;

					recog.base.set_state(2439);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(294,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule dims*/
							recog.base.set_state(2438);
							recog.dims()?;

							}
						}

						_ => {}
					}
					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- arrayCreationExpressionWithInitializer ----------------
pub type ArrayCreationExpressionWithInitializerContextAll<'input> = ArrayCreationExpressionWithInitializerContext<'input>;


pub type ArrayCreationExpressionWithInitializerContext<'input> = BaseParserRuleContext<'input,ArrayCreationExpressionWithInitializerContextExt<'input>>;

#[derive(Clone)]
pub struct ArrayCreationExpressionWithInitializerContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ArrayCreationExpressionWithInitializerContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ArrayCreationExpressionWithInitializerContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_arrayCreationExpressionWithInitializer(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_arrayCreationExpressionWithInitializer(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ArrayCreationExpressionWithInitializerContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_arrayCreationExpressionWithInitializer(self);
	}
}

impl<'input> CustomRuleContext<'input> for ArrayCreationExpressionWithInitializerContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_arrayCreationExpressionWithInitializer }
	//fn type_rule_index() -> usize where Self: Sized { RULE_arrayCreationExpressionWithInitializer }
}
antlr_rust::tid!{ArrayCreationExpressionWithInitializerContextExt<'a>}

impl<'input> ArrayCreationExpressionWithInitializerContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ArrayCreationExpressionWithInitializerContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ArrayCreationExpressionWithInitializerContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ArrayCreationExpressionWithInitializerContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ArrayCreationExpressionWithInitializerContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token NEW
/// Returns `None` if there is no child corresponding to token NEW
fn NEW(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(NEW, 0)
}
fn primitiveType(&self) -> Option<Rc<PrimitiveTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dims(&self) -> Option<Rc<DimsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn arrayInitializer(&self) -> Option<Rc<ArrayInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classOrInterfaceType(&self) -> Option<Rc<ClassOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ArrayCreationExpressionWithInitializerContextAttrs<'input> for ArrayCreationExpressionWithInitializerContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn arrayCreationExpressionWithInitializer(&mut self,)
	-> Result<Rc<ArrayCreationExpressionWithInitializerContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ArrayCreationExpressionWithInitializerContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 410, RULE_arrayCreationExpressionWithInitializer);
        let mut _localctx: Rc<ArrayCreationExpressionWithInitializerContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2453);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(296,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2443);
					recog.base.match_token(NEW,&mut recog.err_handler)?;

					/*InvokeRule primitiveType*/
					recog.base.set_state(2444);
					recog.primitiveType()?;

					/*InvokeRule dims*/
					recog.base.set_state(2445);
					recog.dims()?;

					/*InvokeRule arrayInitializer*/
					recog.base.set_state(2446);
					recog.arrayInitializer()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2448);
					recog.base.match_token(NEW,&mut recog.err_handler)?;

					/*InvokeRule classOrInterfaceType*/
					recog.base.set_state(2449);
					recog.classOrInterfaceType()?;

					/*InvokeRule dims*/
					recog.base.set_state(2450);
					recog.dims()?;

					/*InvokeRule arrayInitializer*/
					recog.base.set_state(2451);
					recog.arrayInitializer()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- dimExprs ----------------
pub type DimExprsContextAll<'input> = DimExprsContext<'input>;


pub type DimExprsContext<'input> = BaseParserRuleContext<'input,DimExprsContextExt<'input>>;

#[derive(Clone)]
pub struct DimExprsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for DimExprsContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for DimExprsContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_dimExprs(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_dimExprs(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for DimExprsContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_dimExprs(self);
	}
}

impl<'input> CustomRuleContext<'input> for DimExprsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_dimExprs }
	//fn type_rule_index() -> usize where Self: Sized { RULE_dimExprs }
}
antlr_rust::tid!{DimExprsContextExt<'a>}

impl<'input> DimExprsContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DimExprsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DimExprsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DimExprsContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<DimExprsContextExt<'input>>{

fn dimExpr_all(&self) ->  Vec<Rc<DimExprContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn dimExpr(&self, i: usize) -> Option<Rc<DimExprContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> DimExprsContextAttrs<'input> for DimExprsContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn dimExprs(&mut self,)
	-> Result<Rc<DimExprsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DimExprsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 412, RULE_dimExprs);
        let mut _localctx: Rc<DimExprsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule dimExpr*/
			recog.base.set_state(2455);
			recog.dimExpr()?;

			recog.base.set_state(2459);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(297,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule dimExpr*/
					recog.base.set_state(2456);
					recog.dimExpr()?;

					}
					} 
				}
				recog.base.set_state(2461);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(297,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- dimExpr ----------------
pub type DimExprContextAll<'input> = DimExprContext<'input>;


pub type DimExprContext<'input> = BaseParserRuleContext<'input,DimExprContextExt<'input>>;

#[derive(Clone)]
pub struct DimExprContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for DimExprContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for DimExprContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_dimExpr(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_dimExpr(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for DimExprContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_dimExpr(self);
	}
}

impl<'input> CustomRuleContext<'input> for DimExprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_dimExpr }
	//fn type_rule_index() -> usize where Self: Sized { RULE_dimExpr }
}
antlr_rust::tid!{DimExprContextExt<'a>}

impl<'input> DimExprContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DimExprContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DimExprContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DimExprContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<DimExprContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LBRACK
/// Returns `None` if there is no child corresponding to token LBRACK
fn LBRACK(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LBRACK, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RBRACK
/// Returns `None` if there is no child corresponding to token RBRACK
fn RBRACK(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RBRACK, 0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> DimExprContextAttrs<'input> for DimExprContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn dimExpr(&mut self,)
	-> Result<Rc<DimExprContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DimExprContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 414, RULE_dimExpr);
        let mut _localctx: Rc<DimExprContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2465);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(2462);
				recog.annotation()?;

				}
				}
				recog.base.set_state(2467);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2468);
			recog.base.match_token(LBRACK,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(2469);
			recog.expression()?;

			recog.base.set_state(2470);
			recog.base.match_token(RBRACK,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- arrayAccess ----------------
pub type ArrayAccessContextAll<'input> = ArrayAccessContext<'input>;


pub type ArrayAccessContext<'input> = BaseParserRuleContext<'input,ArrayAccessContextExt<'input>>;

#[derive(Clone)]
pub struct ArrayAccessContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ArrayAccessContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ArrayAccessContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_arrayAccess(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_arrayAccess(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ArrayAccessContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_arrayAccess(self);
	}
}

impl<'input> CustomRuleContext<'input> for ArrayAccessContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_arrayAccess }
	//fn type_rule_index() -> usize where Self: Sized { RULE_arrayAccess }
}
antlr_rust::tid!{ArrayAccessContextExt<'a>}

impl<'input> ArrayAccessContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ArrayAccessContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ArrayAccessContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ArrayAccessContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ArrayAccessContextExt<'input>>{

fn expressionName(&self) -> Option<Rc<ExpressionNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LBRACK
/// Returns `None` if there is no child corresponding to token LBRACK
fn LBRACK(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LBRACK, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RBRACK
/// Returns `None` if there is no child corresponding to token RBRACK
fn RBRACK(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RBRACK, 0)
}
fn primaryNoNewArray(&self) -> Option<Rc<PrimaryNoNewArrayContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn arrayCreationExpressionWithInitializer(&self) -> Option<Rc<ArrayCreationExpressionWithInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ArrayAccessContextAttrs<'input> for ArrayAccessContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn arrayAccess(&mut self,)
	-> Result<Rc<ArrayAccessContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ArrayAccessContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 416, RULE_arrayAccess);
        let mut _localctx: Rc<ArrayAccessContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2487);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(299,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule expressionName*/
					recog.base.set_state(2472);
					recog.expressionName()?;

					recog.base.set_state(2473);
					recog.base.match_token(LBRACK,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(2474);
					recog.expression()?;

					recog.base.set_state(2475);
					recog.base.match_token(RBRACK,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule primaryNoNewArray*/
					recog.base.set_state(2477);
					recog.primaryNoNewArray()?;

					recog.base.set_state(2478);
					recog.base.match_token(LBRACK,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(2479);
					recog.expression()?;

					recog.base.set_state(2480);
					recog.base.match_token(RBRACK,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule arrayCreationExpressionWithInitializer*/
					recog.base.set_state(2482);
					recog.arrayCreationExpressionWithInitializer()?;

					recog.base.set_state(2483);
					recog.base.match_token(LBRACK,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(2484);
					recog.expression()?;

					recog.base.set_state(2485);
					recog.base.match_token(RBRACK,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- fieldAccess ----------------
pub type FieldAccessContextAll<'input> = FieldAccessContext<'input>;


pub type FieldAccessContext<'input> = BaseParserRuleContext<'input,FieldAccessContextExt<'input>>;

#[derive(Clone)]
pub struct FieldAccessContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for FieldAccessContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for FieldAccessContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_fieldAccess(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_fieldAccess(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for FieldAccessContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_fieldAccess(self);
	}
}

impl<'input> CustomRuleContext<'input> for FieldAccessContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_fieldAccess }
	//fn type_rule_index() -> usize where Self: Sized { RULE_fieldAccess }
}
antlr_rust::tid!{FieldAccessContextExt<'a>}

impl<'input> FieldAccessContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FieldAccessContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FieldAccessContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FieldAccessContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<FieldAccessContextExt<'input>>{

fn primary(&self) -> Option<Rc<PrimaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
/// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, i)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
/// Retrieves first TerminalNode corresponding to token SUPER
/// Returns `None` if there is no child corresponding to token SUPER
fn SUPER(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SUPER, 0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FieldAccessContextAttrs<'input> for FieldAccessContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn fieldAccess(&mut self,)
	-> Result<Rc<FieldAccessContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FieldAccessContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 418, RULE_fieldAccess);
        let mut _localctx: Rc<FieldAccessContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2502);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(300,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule primary*/
					recog.base.set_state(2489);
					recog.primary()?;

					recog.base.set_state(2490);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2491);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2493);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2494);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2495);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule typeName*/
					recog.base.set_state(2496);
					recog.typeName()?;

					recog.base.set_state(2497);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2498);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2499);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2500);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodInvocation ----------------
pub type MethodInvocationContextAll<'input> = MethodInvocationContext<'input>;


pub type MethodInvocationContext<'input> = BaseParserRuleContext<'input,MethodInvocationContextExt<'input>>;

#[derive(Clone)]
pub struct MethodInvocationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for MethodInvocationContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for MethodInvocationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodInvocation(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_methodInvocation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for MethodInvocationContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_methodInvocation(self);
	}
}

impl<'input> CustomRuleContext<'input> for MethodInvocationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodInvocation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodInvocation }
}
antlr_rust::tid!{MethodInvocationContextExt<'a>}

impl<'input> MethodInvocationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodInvocationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodInvocationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodInvocationContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<MethodInvocationContextExt<'input>>{

fn methodName(&self) -> Option<Rc<MethodNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn argumentList(&self) -> Option<Rc<ArgumentListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
/// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, i)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expressionName(&self) -> Option<Rc<ExpressionNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn primary(&self) -> Option<Rc<PrimaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SUPER
/// Returns `None` if there is no child corresponding to token SUPER
fn SUPER(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SUPER, 0)
}

}

impl<'input> MethodInvocationContextAttrs<'input> for MethodInvocationContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodInvocation(&mut self,)
	-> Result<Rc<MethodInvocationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodInvocationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 420, RULE_methodInvocation);
        let mut _localctx: Rc<MethodInvocationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2572);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(312,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule methodName*/
					recog.base.set_state(2504);
					recog.methodName()?;

					recog.base.set_state(2505);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2507);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (FLOAT - 37)) | (1usize << (INT - 37)) | (1usize << (LONG - 37)) | (1usize << (NEW - 37)) | (1usize << (SHORT - 37)) | (1usize << (SUPER - 37)) | (1usize << (SWITCH - 37)) | (1usize << (THIS - 37)) | (1usize << (VOID - 37)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (AT - 69)) | (1usize << (BANG - 69)) | (1usize << (TILDE - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (ADD - 102)) | (1usize << (SUB - 102)) | (1usize << (Identifier - 102)))) != 0) {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2506);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2509);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule typeName*/
					recog.base.set_state(2511);
					recog.typeName()?;

					recog.base.set_state(2512);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2514);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2513);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2516);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					recog.base.set_state(2517);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2519);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (FLOAT - 37)) | (1usize << (INT - 37)) | (1usize << (LONG - 37)) | (1usize << (NEW - 37)) | (1usize << (SHORT - 37)) | (1usize << (SUPER - 37)) | (1usize << (SWITCH - 37)) | (1usize << (THIS - 37)) | (1usize << (VOID - 37)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (AT - 69)) | (1usize << (BANG - 69)) | (1usize << (TILDE - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (ADD - 102)) | (1usize << (SUB - 102)) | (1usize << (Identifier - 102)))) != 0) {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2518);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2521);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule expressionName*/
					recog.base.set_state(2523);
					recog.expressionName()?;

					recog.base.set_state(2524);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2526);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2525);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2528);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					recog.base.set_state(2529);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2531);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (FLOAT - 37)) | (1usize << (INT - 37)) | (1usize << (LONG - 37)) | (1usize << (NEW - 37)) | (1usize << (SHORT - 37)) | (1usize << (SUPER - 37)) | (1usize << (SWITCH - 37)) | (1usize << (THIS - 37)) | (1usize << (VOID - 37)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (AT - 69)) | (1usize << (BANG - 69)) | (1usize << (TILDE - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (ADD - 102)) | (1usize << (SUB - 102)) | (1usize << (Identifier - 102)))) != 0) {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2530);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2533);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule primary*/
					recog.base.set_state(2535);
					recog.primary()?;

					recog.base.set_state(2536);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2538);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2537);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2540);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					recog.base.set_state(2541);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2543);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (FLOAT - 37)) | (1usize << (INT - 37)) | (1usize << (LONG - 37)) | (1usize << (NEW - 37)) | (1usize << (SHORT - 37)) | (1usize << (SUPER - 37)) | (1usize << (SWITCH - 37)) | (1usize << (THIS - 37)) | (1usize << (VOID - 37)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (AT - 69)) | (1usize << (BANG - 69)) | (1usize << (TILDE - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (ADD - 102)) | (1usize << (SUB - 102)) | (1usize << (Identifier - 102)))) != 0) {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2542);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2545);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(2547);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2548);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2550);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2549);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2552);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					recog.base.set_state(2553);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2555);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (FLOAT - 37)) | (1usize << (INT - 37)) | (1usize << (LONG - 37)) | (1usize << (NEW - 37)) | (1usize << (SHORT - 37)) | (1usize << (SUPER - 37)) | (1usize << (SWITCH - 37)) | (1usize << (THIS - 37)) | (1usize << (VOID - 37)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (AT - 69)) | (1usize << (BANG - 69)) | (1usize << (TILDE - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (ADD - 102)) | (1usize << (SUB - 102)) | (1usize << (Identifier - 102)))) != 0) {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2554);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2557);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule typeName*/
					recog.base.set_state(2558);
					recog.typeName()?;

					recog.base.set_state(2559);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2560);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2561);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2563);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2562);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2565);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					recog.base.set_state(2566);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2568);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (FLOAT - 37)) | (1usize << (INT - 37)) | (1usize << (LONG - 37)) | (1usize << (NEW - 37)) | (1usize << (SHORT - 37)) | (1usize << (SUPER - 37)) | (1usize << (SWITCH - 37)) | (1usize << (THIS - 37)) | (1usize << (VOID - 37)))) != 0) || ((((_la - 69)) & !0x3f) == 0 && ((1usize << (_la - 69)) & ((1usize << (IntegerLiteral - 69)) | (1usize << (FloatingPointLiteral - 69)) | (1usize << (BooleanLiteral - 69)) | (1usize << (CharacterLiteral - 69)) | (1usize << (StringLiteral - 69)) | (1usize << (TextBlock - 69)) | (1usize << (NullLiteral - 69)) | (1usize << (LPAREN - 69)) | (1usize << (AT - 69)) | (1usize << (BANG - 69)) | (1usize << (TILDE - 69)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (INC - 102)) | (1usize << (DEC - 102)) | (1usize << (ADD - 102)) | (1usize << (SUB - 102)) | (1usize << (Identifier - 102)))) != 0) {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2567);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2570);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- argumentList ----------------
pub type ArgumentListContextAll<'input> = ArgumentListContext<'input>;


pub type ArgumentListContext<'input> = BaseParserRuleContext<'input,ArgumentListContextExt<'input>>;

#[derive(Clone)]
pub struct ArgumentListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ArgumentListContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ArgumentListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_argumentList(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_argumentList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ArgumentListContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_argumentList(self);
	}
}

impl<'input> CustomRuleContext<'input> for ArgumentListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_argumentList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_argumentList }
}
antlr_rust::tid!{ArgumentListContextExt<'a>}

impl<'input> ArgumentListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ArgumentListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ArgumentListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ArgumentListContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ArgumentListContextExt<'input>>{

fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> ArgumentListContextAttrs<'input> for ArgumentListContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn argumentList(&mut self,)
	-> Result<Rc<ArgumentListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ArgumentListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 422, RULE_argumentList);
        let mut _localctx: Rc<ArgumentListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule expression*/
			recog.base.set_state(2574);
			recog.expression()?;

			recog.base.set_state(2579);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				recog.base.set_state(2575);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				/*InvokeRule expression*/
				recog.base.set_state(2576);
				recog.expression()?;

				}
				}
				recog.base.set_state(2581);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodReference ----------------
pub type MethodReferenceContextAll<'input> = MethodReferenceContext<'input>;


pub type MethodReferenceContext<'input> = BaseParserRuleContext<'input,MethodReferenceContextExt<'input>>;

#[derive(Clone)]
pub struct MethodReferenceContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for MethodReferenceContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for MethodReferenceContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodReference(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_methodReference(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for MethodReferenceContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_methodReference(self);
	}
}

impl<'input> CustomRuleContext<'input> for MethodReferenceContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodReference }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodReference }
}
antlr_rust::tid!{MethodReferenceContextExt<'a>}

impl<'input> MethodReferenceContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodReferenceContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodReferenceContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodReferenceContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<MethodReferenceContextExt<'input>>{

fn expressionName(&self) -> Option<Rc<ExpressionNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLONCOLON
/// Returns `None` if there is no child corresponding to token COLONCOLON
fn COLONCOLON(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COLONCOLON, 0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn primary(&self) -> Option<Rc<PrimaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn referenceType(&self) -> Option<Rc<ReferenceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SUPER
/// Returns `None` if there is no child corresponding to token SUPER
fn SUPER(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SUPER, 0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn classType(&self) -> Option<Rc<ClassTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token NEW
/// Returns `None` if there is no child corresponding to token NEW
fn NEW(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(NEW, 0)
}
fn arrayType(&self) -> Option<Rc<ArrayTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MethodReferenceContextAttrs<'input> for MethodReferenceContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodReference(&mut self,)
	-> Result<Rc<MethodReferenceContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodReferenceContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 424, RULE_methodReference);
        let mut _localctx: Rc<MethodReferenceContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2629);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(320,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule expressionName*/
					recog.base.set_state(2582);
					recog.expressionName()?;

					recog.base.set_state(2583);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2585);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2584);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2587);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule primary*/
					recog.base.set_state(2589);
					recog.primary()?;

					recog.base.set_state(2590);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2592);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2591);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2594);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule referenceType*/
					recog.base.set_state(2596);
					recog.referenceType()?;

					recog.base.set_state(2597);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2599);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2598);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2601);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(2603);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2604);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2606);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2605);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2608);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule typeName*/
					recog.base.set_state(2609);
					recog.typeName()?;

					recog.base.set_state(2610);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2611);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2612);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2614);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2613);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2616);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule classType*/
					recog.base.set_state(2618);
					recog.classType()?;

					recog.base.set_state(2619);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2621);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2620);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2623);
					recog.base.match_token(NEW,&mut recog.err_handler)?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule arrayType*/
					recog.base.set_state(2625);
					recog.arrayType()?;

					recog.base.set_state(2626);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2627);
					recog.base.match_token(NEW,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- postfixExpression ----------------
pub type PostfixExpressionContextAll<'input> = PostfixExpressionContext<'input>;


pub type PostfixExpressionContext<'input> = BaseParserRuleContext<'input,PostfixExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct PostfixExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for PostfixExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for PostfixExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_postfixExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_postfixExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for PostfixExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_postfixExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for PostfixExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_postfixExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_postfixExpression }
}
antlr_rust::tid!{PostfixExpressionContextExt<'a>}

impl<'input> PostfixExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PostfixExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PostfixExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PostfixExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<PostfixExpressionContextExt<'input>>{

fn primary(&self) -> Option<Rc<PrimaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn pfE(&self) -> Option<Rc<PfEContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expressionName(&self) -> Option<Rc<ExpressionNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PostfixExpressionContextAttrs<'input> for PostfixExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn postfixExpression(&mut self,)
	-> Result<Rc<PostfixExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PostfixExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 426, RULE_postfixExpression);
        let mut _localctx: Rc<PostfixExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2639);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(323,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule primary*/
					recog.base.set_state(2631);
					recog.primary()?;

					recog.base.set_state(2633);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(321,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pfE*/
							recog.base.set_state(2632);
							recog.pfE()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule expressionName*/
					recog.base.set_state(2635);
					recog.expressionName()?;

					recog.base.set_state(2637);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(322,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pfE*/
							recog.base.set_state(2636);
							recog.pfE()?;

							}
						}

						_ => {}
					}
					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- pfE ----------------
pub type PfEContextAll<'input> = PfEContext<'input>;


pub type PfEContext<'input> = BaseParserRuleContext<'input,PfEContextExt<'input>>;

#[derive(Clone)]
pub struct PfEContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for PfEContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for PfEContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_pfE(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_pfE(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for PfEContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_pfE(self);
	}
}

impl<'input> CustomRuleContext<'input> for PfEContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pfE }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pfE }
}
antlr_rust::tid!{PfEContextExt<'a>}

impl<'input> PfEContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PfEContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PfEContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PfEContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<PfEContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token INC
/// Returns `None` if there is no child corresponding to token INC
fn INC(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(INC, 0)
}
fn pfE(&self) -> Option<Rc<PfEContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DEC
/// Returns `None` if there is no child corresponding to token DEC
fn DEC(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DEC, 0)
}

}

impl<'input> PfEContextAttrs<'input> for PfEContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn pfE(&mut self,)
	-> Result<Rc<PfEContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PfEContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 428, RULE_pfE);
        let mut _localctx: Rc<PfEContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2649);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 INC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2641);
					recog.base.match_token(INC,&mut recog.err_handler)?;

					recog.base.set_state(2643);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(324,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pfE*/
							recog.base.set_state(2642);
							recog.pfE()?;

							}
						}

						_ => {}
					}
					}
				}

			 DEC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2645);
					recog.base.match_token(DEC,&mut recog.err_handler)?;

					recog.base.set_state(2647);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(325,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule pfE*/
							recog.base.set_state(2646);
							recog.pfE()?;

							}
						}

						_ => {}
					}
					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- postIncrementExpression ----------------
pub type PostIncrementExpressionContextAll<'input> = PostIncrementExpressionContext<'input>;


pub type PostIncrementExpressionContext<'input> = BaseParserRuleContext<'input,PostIncrementExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct PostIncrementExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for PostIncrementExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for PostIncrementExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_postIncrementExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_postIncrementExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for PostIncrementExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_postIncrementExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for PostIncrementExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_postIncrementExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_postIncrementExpression }
}
antlr_rust::tid!{PostIncrementExpressionContextExt<'a>}

impl<'input> PostIncrementExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PostIncrementExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PostIncrementExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PostIncrementExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<PostIncrementExpressionContextExt<'input>>{

fn postfixExpression(&self) -> Option<Rc<PostfixExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token INC
/// Returns `None` if there is no child corresponding to token INC
fn INC(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(INC, 0)
}

}

impl<'input> PostIncrementExpressionContextAttrs<'input> for PostIncrementExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn postIncrementExpression(&mut self,)
	-> Result<Rc<PostIncrementExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PostIncrementExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 430, RULE_postIncrementExpression);
        let mut _localctx: Rc<PostIncrementExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule postfixExpression*/
			recog.base.set_state(2651);
			recog.postfixExpression()?;

			recog.base.set_state(2652);
			recog.base.match_token(INC,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- postDecrementExpression ----------------
pub type PostDecrementExpressionContextAll<'input> = PostDecrementExpressionContext<'input>;


pub type PostDecrementExpressionContext<'input> = BaseParserRuleContext<'input,PostDecrementExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct PostDecrementExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for PostDecrementExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for PostDecrementExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_postDecrementExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_postDecrementExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for PostDecrementExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_postDecrementExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for PostDecrementExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_postDecrementExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_postDecrementExpression }
}
antlr_rust::tid!{PostDecrementExpressionContextExt<'a>}

impl<'input> PostDecrementExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PostDecrementExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PostDecrementExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PostDecrementExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<PostDecrementExpressionContextExt<'input>>{

fn postfixExpression(&self) -> Option<Rc<PostfixExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DEC
/// Returns `None` if there is no child corresponding to token DEC
fn DEC(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DEC, 0)
}

}

impl<'input> PostDecrementExpressionContextAttrs<'input> for PostDecrementExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn postDecrementExpression(&mut self,)
	-> Result<Rc<PostDecrementExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PostDecrementExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 432, RULE_postDecrementExpression);
        let mut _localctx: Rc<PostDecrementExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule postfixExpression*/
			recog.base.set_state(2654);
			recog.postfixExpression()?;

			recog.base.set_state(2655);
			recog.base.match_token(DEC,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unaryExpression ----------------
pub type UnaryExpressionContextAll<'input> = UnaryExpressionContext<'input>;


pub type UnaryExpressionContext<'input> = BaseParserRuleContext<'input,UnaryExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct UnaryExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for UnaryExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for UnaryExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unaryExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_unaryExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for UnaryExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_unaryExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnaryExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unaryExpression }
}
antlr_rust::tid!{UnaryExpressionContextExt<'a>}

impl<'input> UnaryExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnaryExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnaryExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnaryExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<UnaryExpressionContextExt<'input>>{

fn preIncrementExpression(&self) -> Option<Rc<PreIncrementExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn preDecrementExpression(&self) -> Option<Rc<PreDecrementExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ADD
/// Returns `None` if there is no child corresponding to token ADD
fn ADD(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(ADD, 0)
}
fn unaryExpression(&self) -> Option<Rc<UnaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SUB
/// Returns `None` if there is no child corresponding to token SUB
fn SUB(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SUB, 0)
}
fn unaryExpressionNotPlusMinus(&self) -> Option<Rc<UnaryExpressionNotPlusMinusContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UnaryExpressionContextAttrs<'input> for UnaryExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unaryExpression(&mut self,)
	-> Result<Rc<UnaryExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnaryExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 434, RULE_unaryExpression);
        let mut _localctx: Rc<UnaryExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2664);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 INC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule preIncrementExpression*/
					recog.base.set_state(2657);
					recog.preIncrementExpression()?;

					}
				}

			 DEC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule preDecrementExpression*/
					recog.base.set_state(2658);
					recog.preDecrementExpression()?;

					}
				}

			 ADD 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(2659);
					recog.base.match_token(ADD,&mut recog.err_handler)?;

					/*InvokeRule unaryExpression*/
					recog.base.set_state(2660);
					recog.unaryExpression()?;

					}
				}

			 SUB 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(2661);
					recog.base.match_token(SUB,&mut recog.err_handler)?;

					/*InvokeRule unaryExpression*/
					recog.base.set_state(2662);
					recog.unaryExpression()?;

					}
				}

			 BOOLEAN | BYTE | CHAR | DOUBLE | FLOAT | INT | LONG | NEW | SHORT | SUPER |
			 SWITCH | THIS | VOID | IntegerLiteral | FloatingPointLiteral | BooleanLiteral |
			 CharacterLiteral | StringLiteral | TextBlock | NullLiteral | LPAREN |
			 AT | BANG | TILDE | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule unaryExpressionNotPlusMinus*/
					recog.base.set_state(2663);
					recog.unaryExpressionNotPlusMinus()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- preIncrementExpression ----------------
pub type PreIncrementExpressionContextAll<'input> = PreIncrementExpressionContext<'input>;


pub type PreIncrementExpressionContext<'input> = BaseParserRuleContext<'input,PreIncrementExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct PreIncrementExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for PreIncrementExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for PreIncrementExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_preIncrementExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_preIncrementExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for PreIncrementExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_preIncrementExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for PreIncrementExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_preIncrementExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_preIncrementExpression }
}
antlr_rust::tid!{PreIncrementExpressionContextExt<'a>}

impl<'input> PreIncrementExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PreIncrementExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PreIncrementExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PreIncrementExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<PreIncrementExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token INC
/// Returns `None` if there is no child corresponding to token INC
fn INC(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(INC, 0)
}
fn unaryExpression(&self) -> Option<Rc<UnaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PreIncrementExpressionContextAttrs<'input> for PreIncrementExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn preIncrementExpression(&mut self,)
	-> Result<Rc<PreIncrementExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PreIncrementExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 436, RULE_preIncrementExpression);
        let mut _localctx: Rc<PreIncrementExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2666);
			recog.base.match_token(INC,&mut recog.err_handler)?;

			/*InvokeRule unaryExpression*/
			recog.base.set_state(2667);
			recog.unaryExpression()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- preDecrementExpression ----------------
pub type PreDecrementExpressionContextAll<'input> = PreDecrementExpressionContext<'input>;


pub type PreDecrementExpressionContext<'input> = BaseParserRuleContext<'input,PreDecrementExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct PreDecrementExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for PreDecrementExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for PreDecrementExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_preDecrementExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_preDecrementExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for PreDecrementExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_preDecrementExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for PreDecrementExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_preDecrementExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_preDecrementExpression }
}
antlr_rust::tid!{PreDecrementExpressionContextExt<'a>}

impl<'input> PreDecrementExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PreDecrementExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PreDecrementExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PreDecrementExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<PreDecrementExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DEC
/// Returns `None` if there is no child corresponding to token DEC
fn DEC(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DEC, 0)
}
fn unaryExpression(&self) -> Option<Rc<UnaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PreDecrementExpressionContextAttrs<'input> for PreDecrementExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn preDecrementExpression(&mut self,)
	-> Result<Rc<PreDecrementExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PreDecrementExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 438, RULE_preDecrementExpression);
        let mut _localctx: Rc<PreDecrementExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2669);
			recog.base.match_token(DEC,&mut recog.err_handler)?;

			/*InvokeRule unaryExpression*/
			recog.base.set_state(2670);
			recog.unaryExpression()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unaryExpressionNotPlusMinus ----------------
pub type UnaryExpressionNotPlusMinusContextAll<'input> = UnaryExpressionNotPlusMinusContext<'input>;


pub type UnaryExpressionNotPlusMinusContext<'input> = BaseParserRuleContext<'input,UnaryExpressionNotPlusMinusContextExt<'input>>;

#[derive(Clone)]
pub struct UnaryExpressionNotPlusMinusContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for UnaryExpressionNotPlusMinusContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for UnaryExpressionNotPlusMinusContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unaryExpressionNotPlusMinus(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_unaryExpressionNotPlusMinus(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for UnaryExpressionNotPlusMinusContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_unaryExpressionNotPlusMinus(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnaryExpressionNotPlusMinusContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unaryExpressionNotPlusMinus }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unaryExpressionNotPlusMinus }
}
antlr_rust::tid!{UnaryExpressionNotPlusMinusContextExt<'a>}

impl<'input> UnaryExpressionNotPlusMinusContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnaryExpressionNotPlusMinusContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnaryExpressionNotPlusMinusContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnaryExpressionNotPlusMinusContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<UnaryExpressionNotPlusMinusContextExt<'input>>{

fn postfixExpression(&self) -> Option<Rc<PostfixExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token TILDE
/// Returns `None` if there is no child corresponding to token TILDE
fn TILDE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(TILDE, 0)
}
fn unaryExpression(&self) -> Option<Rc<UnaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token BANG
/// Returns `None` if there is no child corresponding to token BANG
fn BANG(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(BANG, 0)
}
fn castExpression(&self) -> Option<Rc<CastExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn switchExpression(&self) -> Option<Rc<SwitchExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UnaryExpressionNotPlusMinusContextAttrs<'input> for UnaryExpressionNotPlusMinusContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unaryExpressionNotPlusMinus(&mut self,)
	-> Result<Rc<UnaryExpressionNotPlusMinusContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnaryExpressionNotPlusMinusContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 440, RULE_unaryExpressionNotPlusMinus);
        let mut _localctx: Rc<UnaryExpressionNotPlusMinusContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2679);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(328,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule postfixExpression*/
					recog.base.set_state(2672);
					recog.postfixExpression()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2673);
					recog.base.match_token(TILDE,&mut recog.err_handler)?;

					/*InvokeRule unaryExpression*/
					recog.base.set_state(2674);
					recog.unaryExpression()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(2675);
					recog.base.match_token(BANG,&mut recog.err_handler)?;

					/*InvokeRule unaryExpression*/
					recog.base.set_state(2676);
					recog.unaryExpression()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule castExpression*/
					recog.base.set_state(2677);
					recog.castExpression()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule switchExpression*/
					recog.base.set_state(2678);
					recog.switchExpression()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- castExpression ----------------
pub type CastExpressionContextAll<'input> = CastExpressionContext<'input>;


pub type CastExpressionContext<'input> = BaseParserRuleContext<'input,CastExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct CastExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for CastExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for CastExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_castExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_castExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for CastExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_castExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for CastExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_castExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_castExpression }
}
antlr_rust::tid!{CastExpressionContextExt<'a>}

impl<'input> CastExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CastExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CastExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CastExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<CastExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn primitiveType(&self) -> Option<Rc<PrimitiveTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn unaryExpression(&self) -> Option<Rc<UnaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn referenceType(&self) -> Option<Rc<ReferenceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn unaryExpressionNotPlusMinus(&self) -> Option<Rc<UnaryExpressionNotPlusMinusContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn additionalBound_all(&self) ->  Vec<Rc<AdditionalBoundContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn additionalBound(&self, i: usize) -> Option<Rc<AdditionalBoundContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn lambdaExpression(&self) -> Option<Rc<LambdaExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CastExpressionContextAttrs<'input> for CastExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn castExpression(&mut self,)
	-> Result<Rc<CastExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CastExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 442, RULE_castExpression);
        let mut _localctx: Rc<CastExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2708);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(331,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2681);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule primitiveType*/
					recog.base.set_state(2682);
					recog.primitiveType()?;

					recog.base.set_state(2683);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					/*InvokeRule unaryExpression*/
					recog.base.set_state(2684);
					recog.unaryExpression()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2686);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule referenceType*/
					recog.base.set_state(2687);
					recog.referenceType()?;

					recog.base.set_state(2691);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==BITAND {
						{
						{
						/*InvokeRule additionalBound*/
						recog.base.set_state(2688);
						recog.additionalBound()?;

						}
						}
						recog.base.set_state(2693);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2694);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					/*InvokeRule unaryExpressionNotPlusMinus*/
					recog.base.set_state(2695);
					recog.unaryExpressionNotPlusMinus()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(2697);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule referenceType*/
					recog.base.set_state(2698);
					recog.referenceType()?;

					recog.base.set_state(2702);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==BITAND {
						{
						{
						/*InvokeRule additionalBound*/
						recog.base.set_state(2699);
						recog.additionalBound()?;

						}
						}
						recog.base.set_state(2704);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2705);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					/*InvokeRule lambdaExpression*/
					recog.base.set_state(2706);
					recog.lambdaExpression()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- multiplicativeExpression ----------------
pub type MultiplicativeExpressionContextAll<'input> = MultiplicativeExpressionContext<'input>;


pub type MultiplicativeExpressionContext<'input> = BaseParserRuleContext<'input,MultiplicativeExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct MultiplicativeExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for MultiplicativeExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for MultiplicativeExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_multiplicativeExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_multiplicativeExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for MultiplicativeExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_multiplicativeExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for MultiplicativeExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_multiplicativeExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_multiplicativeExpression }
}
antlr_rust::tid!{MultiplicativeExpressionContextExt<'a>}

impl<'input> MultiplicativeExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MultiplicativeExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MultiplicativeExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MultiplicativeExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<MultiplicativeExpressionContextExt<'input>>{

fn unaryExpression(&self) -> Option<Rc<UnaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn multiplicativeExpression(&self) -> Option<Rc<MultiplicativeExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token MUL
/// Returns `None` if there is no child corresponding to token MUL
fn MUL(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(MUL, 0)
}
/// Retrieves first TerminalNode corresponding to token DIV
/// Returns `None` if there is no child corresponding to token DIV
fn DIV(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DIV, 0)
}
/// Retrieves first TerminalNode corresponding to token MOD
/// Returns `None` if there is no child corresponding to token MOD
fn MOD(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(MOD, 0)
}

}

impl<'input> MultiplicativeExpressionContextAttrs<'input> for MultiplicativeExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  multiplicativeExpression(&mut self,)
	-> Result<Rc<MultiplicativeExpressionContextAll<'input>>,ANTLRError> {
		self.multiplicativeExpression_rec(0)
	}

	fn multiplicativeExpression_rec(&mut self, _p: isize)
	-> Result<Rc<MultiplicativeExpressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = MultiplicativeExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 444, RULE_multiplicativeExpression, _p);
	    let mut _localctx: Rc<MultiplicativeExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 444;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule unaryExpression*/
			recog.base.set_state(2711);
			recog.unaryExpression()?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(2724);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(333,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					recog.base.set_state(2722);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(332,&mut recog.base)? {
						1 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = MultiplicativeExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_multiplicativeExpression);
							_localctx = tmp;
							recog.base.set_state(2713);
							if !({recog.precpred(None, 3)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 3)".to_owned()), None))?;
							}
							recog.base.set_state(2714);
							recog.base.match_token(MUL,&mut recog.err_handler)?;

							/*InvokeRule unaryExpression*/
							recog.base.set_state(2715);
							recog.unaryExpression()?;

							}
						}
					,
						2 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = MultiplicativeExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_multiplicativeExpression);
							_localctx = tmp;
							recog.base.set_state(2716);
							if !({recog.precpred(None, 2)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 2)".to_owned()), None))?;
							}
							recog.base.set_state(2717);
							recog.base.match_token(DIV,&mut recog.err_handler)?;

							/*InvokeRule unaryExpression*/
							recog.base.set_state(2718);
							recog.unaryExpression()?;

							}
						}
					,
						3 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = MultiplicativeExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_multiplicativeExpression);
							_localctx = tmp;
							recog.base.set_state(2719);
							if !({recog.precpred(None, 1)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
							}
							recog.base.set_state(2720);
							recog.base.match_token(MOD,&mut recog.err_handler)?;

							/*InvokeRule unaryExpression*/
							recog.base.set_state(2721);
							recog.unaryExpression()?;

							}
						}

						_ => {}
					}
					} 
				}
				recog.base.set_state(2726);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(333,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- additiveExpression ----------------
pub type AdditiveExpressionContextAll<'input> = AdditiveExpressionContext<'input>;


pub type AdditiveExpressionContext<'input> = BaseParserRuleContext<'input,AdditiveExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct AdditiveExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for AdditiveExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for AdditiveExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_additiveExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_additiveExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for AdditiveExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_additiveExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for AdditiveExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_additiveExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_additiveExpression }
}
antlr_rust::tid!{AdditiveExpressionContextExt<'a>}

impl<'input> AdditiveExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AdditiveExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AdditiveExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AdditiveExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<AdditiveExpressionContextExt<'input>>{

fn multiplicativeExpression(&self) -> Option<Rc<MultiplicativeExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn additiveExpression(&self) -> Option<Rc<AdditiveExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ADD
/// Returns `None` if there is no child corresponding to token ADD
fn ADD(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(ADD, 0)
}
/// Retrieves first TerminalNode corresponding to token SUB
/// Returns `None` if there is no child corresponding to token SUB
fn SUB(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SUB, 0)
}

}

impl<'input> AdditiveExpressionContextAttrs<'input> for AdditiveExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  additiveExpression(&mut self,)
	-> Result<Rc<AdditiveExpressionContextAll<'input>>,ANTLRError> {
		self.additiveExpression_rec(0)
	}

	fn additiveExpression_rec(&mut self, _p: isize)
	-> Result<Rc<AdditiveExpressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = AdditiveExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 446, RULE_additiveExpression, _p);
	    let mut _localctx: Rc<AdditiveExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 446;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule multiplicativeExpression*/
			recog.base.set_state(2728);
			recog.multiplicativeExpression_rec(0)?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(2738);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(335,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					recog.base.set_state(2736);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(334,&mut recog.base)? {
						1 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = AdditiveExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_additiveExpression);
							_localctx = tmp;
							recog.base.set_state(2730);
							if !({recog.precpred(None, 2)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 2)".to_owned()), None))?;
							}
							recog.base.set_state(2731);
							recog.base.match_token(ADD,&mut recog.err_handler)?;

							/*InvokeRule multiplicativeExpression*/
							recog.base.set_state(2732);
							recog.multiplicativeExpression_rec(0)?;

							}
						}
					,
						2 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = AdditiveExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_additiveExpression);
							_localctx = tmp;
							recog.base.set_state(2733);
							if !({recog.precpred(None, 1)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
							}
							recog.base.set_state(2734);
							recog.base.match_token(SUB,&mut recog.err_handler)?;

							/*InvokeRule multiplicativeExpression*/
							recog.base.set_state(2735);
							recog.multiplicativeExpression_rec(0)?;

							}
						}

						_ => {}
					}
					} 
				}
				recog.base.set_state(2740);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(335,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- shiftExpression ----------------
pub type ShiftExpressionContextAll<'input> = ShiftExpressionContext<'input>;


pub type ShiftExpressionContext<'input> = BaseParserRuleContext<'input,ShiftExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ShiftExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ShiftExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ShiftExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_shiftExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_shiftExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ShiftExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_shiftExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for ShiftExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_shiftExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_shiftExpression }
}
antlr_rust::tid!{ShiftExpressionContextExt<'a>}

impl<'input> ShiftExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ShiftExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ShiftExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ShiftExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ShiftExpressionContextExt<'input>>{

fn additiveExpression(&self) -> Option<Rc<AdditiveExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn shiftExpression(&self) -> Option<Rc<ShiftExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token LT in current rule
fn LT_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token LT, starting from 0.
/// Returns `None` if number of children corresponding to token LT is less or equal than `i`.
fn LT(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LT, i)
}
/// Retrieves all `TerminalNode`s corresponding to token GT in current rule
fn GT_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token GT, starting from 0.
/// Returns `None` if number of children corresponding to token GT is less or equal than `i`.
fn GT(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(GT, i)
}

}

impl<'input> ShiftExpressionContextAttrs<'input> for ShiftExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  shiftExpression(&mut self,)
	-> Result<Rc<ShiftExpressionContextAll<'input>>,ANTLRError> {
		self.shiftExpression_rec(0)
	}

	fn shiftExpression_rec(&mut self, _p: isize)
	-> Result<Rc<ShiftExpressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = ShiftExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 448, RULE_shiftExpression, _p);
	    let mut _localctx: Rc<ShiftExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 448;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule additiveExpression*/
			recog.base.set_state(2742);
			recog.additiveExpression_rec(0)?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(2759);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(337,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					recog.base.set_state(2757);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(336,&mut recog.base)? {
						1 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = ShiftExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_shiftExpression);
							_localctx = tmp;
							recog.base.set_state(2744);
							if !({recog.precpred(None, 3)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 3)".to_owned()), None))?;
							}
							recog.base.set_state(2745);
							recog.base.match_token(LT,&mut recog.err_handler)?;

							recog.base.set_state(2746);
							recog.base.match_token(LT,&mut recog.err_handler)?;

							/*InvokeRule additiveExpression*/
							recog.base.set_state(2747);
							recog.additiveExpression_rec(0)?;

							}
						}
					,
						2 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = ShiftExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_shiftExpression);
							_localctx = tmp;
							recog.base.set_state(2748);
							if !({recog.precpred(None, 2)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 2)".to_owned()), None))?;
							}
							recog.base.set_state(2749);
							recog.base.match_token(GT,&mut recog.err_handler)?;

							recog.base.set_state(2750);
							recog.base.match_token(GT,&mut recog.err_handler)?;

							/*InvokeRule additiveExpression*/
							recog.base.set_state(2751);
							recog.additiveExpression_rec(0)?;

							}
						}
					,
						3 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = ShiftExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_shiftExpression);
							_localctx = tmp;
							recog.base.set_state(2752);
							if !({recog.precpred(None, 1)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
							}
							recog.base.set_state(2753);
							recog.base.match_token(GT,&mut recog.err_handler)?;

							recog.base.set_state(2754);
							recog.base.match_token(GT,&mut recog.err_handler)?;

							recog.base.set_state(2755);
							recog.base.match_token(GT,&mut recog.err_handler)?;

							/*InvokeRule additiveExpression*/
							recog.base.set_state(2756);
							recog.additiveExpression_rec(0)?;

							}
						}

						_ => {}
					}
					} 
				}
				recog.base.set_state(2761);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(337,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- relationalExpression ----------------
pub type RelationalExpressionContextAll<'input> = RelationalExpressionContext<'input>;


pub type RelationalExpressionContext<'input> = BaseParserRuleContext<'input,RelationalExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct RelationalExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for RelationalExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for RelationalExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_relationalExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_relationalExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for RelationalExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_relationalExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for RelationalExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_relationalExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_relationalExpression }
}
antlr_rust::tid!{RelationalExpressionContextExt<'a>}

impl<'input> RelationalExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RelationalExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RelationalExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RelationalExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<RelationalExpressionContextExt<'input>>{

fn shiftExpression(&self) -> Option<Rc<ShiftExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn relationalExpression(&self) -> Option<Rc<RelationalExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LT
/// Returns `None` if there is no child corresponding to token LT
fn LT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LT, 0)
}
/// Retrieves first TerminalNode corresponding to token GT
/// Returns `None` if there is no child corresponding to token GT
fn GT(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(GT, 0)
}
/// Retrieves first TerminalNode corresponding to token LE
/// Returns `None` if there is no child corresponding to token LE
fn LE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LE, 0)
}
/// Retrieves first TerminalNode corresponding to token GE
/// Returns `None` if there is no child corresponding to token GE
fn GE(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(GE, 0)
}
/// Retrieves first TerminalNode corresponding to token INSTANCEOF
/// Returns `None` if there is no child corresponding to token INSTANCEOF
fn INSTANCEOF(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(INSTANCEOF, 0)
}
fn referenceType(&self) -> Option<Rc<ReferenceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn pattern(&self) -> Option<Rc<PatternContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RelationalExpressionContextAttrs<'input> for RelationalExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  relationalExpression(&mut self,)
	-> Result<Rc<RelationalExpressionContextAll<'input>>,ANTLRError> {
		self.relationalExpression_rec(0)
	}

	fn relationalExpression_rec(&mut self, _p: isize)
	-> Result<Rc<RelationalExpressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = RelationalExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 450, RULE_relationalExpression, _p);
	    let mut _localctx: Rc<RelationalExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 450;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule shiftExpression*/
			recog.base.set_state(2763);
			recog.shiftExpression_rec(0)?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(2785);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(340,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					recog.base.set_state(2783);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(339,&mut recog.base)? {
						1 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = RelationalExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_relationalExpression);
							_localctx = tmp;
							recog.base.set_state(2765);
							if !({recog.precpred(None, 5)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 5)".to_owned()), None))?;
							}
							recog.base.set_state(2766);
							recog.base.match_token(LT,&mut recog.err_handler)?;

							/*InvokeRule shiftExpression*/
							recog.base.set_state(2767);
							recog.shiftExpression_rec(0)?;

							}
						}
					,
						2 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = RelationalExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_relationalExpression);
							_localctx = tmp;
							recog.base.set_state(2768);
							if !({recog.precpred(None, 4)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 4)".to_owned()), None))?;
							}
							recog.base.set_state(2769);
							recog.base.match_token(GT,&mut recog.err_handler)?;

							/*InvokeRule shiftExpression*/
							recog.base.set_state(2770);
							recog.shiftExpression_rec(0)?;

							}
						}
					,
						3 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = RelationalExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_relationalExpression);
							_localctx = tmp;
							recog.base.set_state(2771);
							if !({recog.precpred(None, 3)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 3)".to_owned()), None))?;
							}
							recog.base.set_state(2772);
							recog.base.match_token(LE,&mut recog.err_handler)?;

							/*InvokeRule shiftExpression*/
							recog.base.set_state(2773);
							recog.shiftExpression_rec(0)?;

							}
						}
					,
						4 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = RelationalExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_relationalExpression);
							_localctx = tmp;
							recog.base.set_state(2774);
							if !({recog.precpred(None, 2)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 2)".to_owned()), None))?;
							}
							recog.base.set_state(2775);
							recog.base.match_token(GE,&mut recog.err_handler)?;

							/*InvokeRule shiftExpression*/
							recog.base.set_state(2776);
							recog.shiftExpression_rec(0)?;

							}
						}
					,
						5 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = RelationalExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_relationalExpression);
							_localctx = tmp;
							recog.base.set_state(2777);
							if !({recog.precpred(None, 1)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
							}
							recog.base.set_state(2778);
							recog.base.match_token(INSTANCEOF,&mut recog.err_handler)?;

							recog.base.set_state(2781);
							recog.err_handler.sync(&mut recog.base)?;
							match  recog.interpreter.adaptive_predict(338,&mut recog.base)? {
								1 =>{
									{
									/*InvokeRule referenceType*/
									recog.base.set_state(2779);
									recog.referenceType()?;

									}
								}
							,
								2 =>{
									{
									/*InvokeRule pattern*/
									recog.base.set_state(2780);
									recog.pattern()?;

									}
								}

								_ => {}
							}
							}
						}

						_ => {}
					}
					} 
				}
				recog.base.set_state(2787);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(340,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- equalityExpression ----------------
pub type EqualityExpressionContextAll<'input> = EqualityExpressionContext<'input>;


pub type EqualityExpressionContext<'input> = BaseParserRuleContext<'input,EqualityExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct EqualityExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for EqualityExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for EqualityExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_equalityExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_equalityExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for EqualityExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_equalityExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for EqualityExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_equalityExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_equalityExpression }
}
antlr_rust::tid!{EqualityExpressionContextExt<'a>}

impl<'input> EqualityExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EqualityExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EqualityExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EqualityExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<EqualityExpressionContextExt<'input>>{

fn relationalExpression(&self) -> Option<Rc<RelationalExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn equalityExpression(&self) -> Option<Rc<EqualityExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token EQUAL
/// Returns `None` if there is no child corresponding to token EQUAL
fn EQUAL(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(EQUAL, 0)
}
/// Retrieves first TerminalNode corresponding to token NOTEQUAL
/// Returns `None` if there is no child corresponding to token NOTEQUAL
fn NOTEQUAL(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(NOTEQUAL, 0)
}

}

impl<'input> EqualityExpressionContextAttrs<'input> for EqualityExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  equalityExpression(&mut self,)
	-> Result<Rc<EqualityExpressionContextAll<'input>>,ANTLRError> {
		self.equalityExpression_rec(0)
	}

	fn equalityExpression_rec(&mut self, _p: isize)
	-> Result<Rc<EqualityExpressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = EqualityExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 452, RULE_equalityExpression, _p);
	    let mut _localctx: Rc<EqualityExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 452;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule relationalExpression*/
			recog.base.set_state(2789);
			recog.relationalExpression_rec(0)?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(2799);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(342,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					recog.base.set_state(2797);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(341,&mut recog.base)? {
						1 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = EqualityExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_equalityExpression);
							_localctx = tmp;
							recog.base.set_state(2791);
							if !({recog.precpred(None, 2)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 2)".to_owned()), None))?;
							}
							recog.base.set_state(2792);
							recog.base.match_token(EQUAL,&mut recog.err_handler)?;

							/*InvokeRule relationalExpression*/
							recog.base.set_state(2793);
							recog.relationalExpression_rec(0)?;

							}
						}
					,
						2 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = EqualityExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_equalityExpression);
							_localctx = tmp;
							recog.base.set_state(2794);
							if !({recog.precpred(None, 1)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
							}
							recog.base.set_state(2795);
							recog.base.match_token(NOTEQUAL,&mut recog.err_handler)?;

							/*InvokeRule relationalExpression*/
							recog.base.set_state(2796);
							recog.relationalExpression_rec(0)?;

							}
						}

						_ => {}
					}
					} 
				}
				recog.base.set_state(2801);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(342,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- andExpression ----------------
pub type AndExpressionContextAll<'input> = AndExpressionContext<'input>;


pub type AndExpressionContext<'input> = BaseParserRuleContext<'input,AndExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct AndExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for AndExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for AndExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_andExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_andExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for AndExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_andExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for AndExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_andExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_andExpression }
}
antlr_rust::tid!{AndExpressionContextExt<'a>}

impl<'input> AndExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AndExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AndExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AndExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<AndExpressionContextExt<'input>>{

fn equalityExpression(&self) -> Option<Rc<EqualityExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn andExpression(&self) -> Option<Rc<AndExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token BITAND
/// Returns `None` if there is no child corresponding to token BITAND
fn BITAND(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(BITAND, 0)
}

}

impl<'input> AndExpressionContextAttrs<'input> for AndExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  andExpression(&mut self,)
	-> Result<Rc<AndExpressionContextAll<'input>>,ANTLRError> {
		self.andExpression_rec(0)
	}

	fn andExpression_rec(&mut self, _p: isize)
	-> Result<Rc<AndExpressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = AndExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 454, RULE_andExpression, _p);
	    let mut _localctx: Rc<AndExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 454;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule equalityExpression*/
			recog.base.set_state(2803);
			recog.equalityExpression_rec(0)?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(2810);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(343,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					{
					/*recRuleAltStartAction*/
					let mut tmp = AndExpressionContextExt::new(_parentctx.clone(), _parentState);
					recog.push_new_recursion_context(tmp.clone(), _startState, RULE_andExpression);
					_localctx = tmp;
					recog.base.set_state(2805);
					if !({recog.precpred(None, 1)}) {
						Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
					}
					recog.base.set_state(2806);
					recog.base.match_token(BITAND,&mut recog.err_handler)?;

					/*InvokeRule equalityExpression*/
					recog.base.set_state(2807);
					recog.equalityExpression_rec(0)?;

					}
					} 
				}
				recog.base.set_state(2812);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(343,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- exclusiveOrExpression ----------------
pub type ExclusiveOrExpressionContextAll<'input> = ExclusiveOrExpressionContext<'input>;


pub type ExclusiveOrExpressionContext<'input> = BaseParserRuleContext<'input,ExclusiveOrExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ExclusiveOrExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ExclusiveOrExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ExclusiveOrExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_exclusiveOrExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_exclusiveOrExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ExclusiveOrExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_exclusiveOrExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExclusiveOrExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_exclusiveOrExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_exclusiveOrExpression }
}
antlr_rust::tid!{ExclusiveOrExpressionContextExt<'a>}

impl<'input> ExclusiveOrExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExclusiveOrExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExclusiveOrExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExclusiveOrExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ExclusiveOrExpressionContextExt<'input>>{

fn andExpression(&self) -> Option<Rc<AndExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn exclusiveOrExpression(&self) -> Option<Rc<ExclusiveOrExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token CARET
/// Returns `None` if there is no child corresponding to token CARET
fn CARET(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(CARET, 0)
}

}

impl<'input> ExclusiveOrExpressionContextAttrs<'input> for ExclusiveOrExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  exclusiveOrExpression(&mut self,)
	-> Result<Rc<ExclusiveOrExpressionContextAll<'input>>,ANTLRError> {
		self.exclusiveOrExpression_rec(0)
	}

	fn exclusiveOrExpression_rec(&mut self, _p: isize)
	-> Result<Rc<ExclusiveOrExpressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = ExclusiveOrExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 456, RULE_exclusiveOrExpression, _p);
	    let mut _localctx: Rc<ExclusiveOrExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 456;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule andExpression*/
			recog.base.set_state(2814);
			recog.andExpression_rec(0)?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(2821);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(344,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					{
					/*recRuleAltStartAction*/
					let mut tmp = ExclusiveOrExpressionContextExt::new(_parentctx.clone(), _parentState);
					recog.push_new_recursion_context(tmp.clone(), _startState, RULE_exclusiveOrExpression);
					_localctx = tmp;
					recog.base.set_state(2816);
					if !({recog.precpred(None, 1)}) {
						Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
					}
					recog.base.set_state(2817);
					recog.base.match_token(CARET,&mut recog.err_handler)?;

					/*InvokeRule andExpression*/
					recog.base.set_state(2818);
					recog.andExpression_rec(0)?;

					}
					} 
				}
				recog.base.set_state(2823);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(344,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- inclusiveOrExpression ----------------
pub type InclusiveOrExpressionContextAll<'input> = InclusiveOrExpressionContext<'input>;


pub type InclusiveOrExpressionContext<'input> = BaseParserRuleContext<'input,InclusiveOrExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct InclusiveOrExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for InclusiveOrExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for InclusiveOrExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_inclusiveOrExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_inclusiveOrExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for InclusiveOrExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_inclusiveOrExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for InclusiveOrExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_inclusiveOrExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_inclusiveOrExpression }
}
antlr_rust::tid!{InclusiveOrExpressionContextExt<'a>}

impl<'input> InclusiveOrExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InclusiveOrExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InclusiveOrExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InclusiveOrExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<InclusiveOrExpressionContextExt<'input>>{

fn exclusiveOrExpression(&self) -> Option<Rc<ExclusiveOrExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn inclusiveOrExpression(&self) -> Option<Rc<InclusiveOrExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token BITOR
/// Returns `None` if there is no child corresponding to token BITOR
fn BITOR(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(BITOR, 0)
}

}

impl<'input> InclusiveOrExpressionContextAttrs<'input> for InclusiveOrExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  inclusiveOrExpression(&mut self,)
	-> Result<Rc<InclusiveOrExpressionContextAll<'input>>,ANTLRError> {
		self.inclusiveOrExpression_rec(0)
	}

	fn inclusiveOrExpression_rec(&mut self, _p: isize)
	-> Result<Rc<InclusiveOrExpressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = InclusiveOrExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 458, RULE_inclusiveOrExpression, _p);
	    let mut _localctx: Rc<InclusiveOrExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 458;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule exclusiveOrExpression*/
			recog.base.set_state(2825);
			recog.exclusiveOrExpression_rec(0)?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(2832);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(345,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					{
					/*recRuleAltStartAction*/
					let mut tmp = InclusiveOrExpressionContextExt::new(_parentctx.clone(), _parentState);
					recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inclusiveOrExpression);
					_localctx = tmp;
					recog.base.set_state(2827);
					if !({recog.precpred(None, 1)}) {
						Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
					}
					recog.base.set_state(2828);
					recog.base.match_token(BITOR,&mut recog.err_handler)?;

					/*InvokeRule exclusiveOrExpression*/
					recog.base.set_state(2829);
					recog.exclusiveOrExpression_rec(0)?;

					}
					} 
				}
				recog.base.set_state(2834);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(345,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- conditionalAndExpression ----------------
pub type ConditionalAndExpressionContextAll<'input> = ConditionalAndExpressionContext<'input>;


pub type ConditionalAndExpressionContext<'input> = BaseParserRuleContext<'input,ConditionalAndExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ConditionalAndExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ConditionalAndExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ConditionalAndExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_conditionalAndExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_conditionalAndExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ConditionalAndExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_conditionalAndExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for ConditionalAndExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_conditionalAndExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_conditionalAndExpression }
}
antlr_rust::tid!{ConditionalAndExpressionContextExt<'a>}

impl<'input> ConditionalAndExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConditionalAndExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConditionalAndExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConditionalAndExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ConditionalAndExpressionContextExt<'input>>{

fn inclusiveOrExpression(&self) -> Option<Rc<InclusiveOrExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn conditionalAndExpression(&self) -> Option<Rc<ConditionalAndExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token AND
/// Returns `None` if there is no child corresponding to token AND
fn AND(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(AND, 0)
}

}

impl<'input> ConditionalAndExpressionContextAttrs<'input> for ConditionalAndExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  conditionalAndExpression(&mut self,)
	-> Result<Rc<ConditionalAndExpressionContextAll<'input>>,ANTLRError> {
		self.conditionalAndExpression_rec(0)
	}

	fn conditionalAndExpression_rec(&mut self, _p: isize)
	-> Result<Rc<ConditionalAndExpressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = ConditionalAndExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 460, RULE_conditionalAndExpression, _p);
	    let mut _localctx: Rc<ConditionalAndExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 460;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule inclusiveOrExpression*/
			recog.base.set_state(2836);
			recog.inclusiveOrExpression_rec(0)?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(2843);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(346,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					{
					/*recRuleAltStartAction*/
					let mut tmp = ConditionalAndExpressionContextExt::new(_parentctx.clone(), _parentState);
					recog.push_new_recursion_context(tmp.clone(), _startState, RULE_conditionalAndExpression);
					_localctx = tmp;
					recog.base.set_state(2838);
					if !({recog.precpred(None, 1)}) {
						Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
					}
					recog.base.set_state(2839);
					recog.base.match_token(AND,&mut recog.err_handler)?;

					/*InvokeRule inclusiveOrExpression*/
					recog.base.set_state(2840);
					recog.inclusiveOrExpression_rec(0)?;

					}
					} 
				}
				recog.base.set_state(2845);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(346,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- conditionalOrExpression ----------------
pub type ConditionalOrExpressionContextAll<'input> = ConditionalOrExpressionContext<'input>;


pub type ConditionalOrExpressionContext<'input> = BaseParserRuleContext<'input,ConditionalOrExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ConditionalOrExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ConditionalOrExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ConditionalOrExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_conditionalOrExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_conditionalOrExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ConditionalOrExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_conditionalOrExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for ConditionalOrExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_conditionalOrExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_conditionalOrExpression }
}
antlr_rust::tid!{ConditionalOrExpressionContextExt<'a>}

impl<'input> ConditionalOrExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConditionalOrExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConditionalOrExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConditionalOrExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ConditionalOrExpressionContextExt<'input>>{

fn conditionalAndExpression(&self) -> Option<Rc<ConditionalAndExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn conditionalOrExpression(&self) -> Option<Rc<ConditionalOrExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token OR
/// Returns `None` if there is no child corresponding to token OR
fn OR(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(OR, 0)
}

}

impl<'input> ConditionalOrExpressionContextAttrs<'input> for ConditionalOrExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  conditionalOrExpression(&mut self,)
	-> Result<Rc<ConditionalOrExpressionContextAll<'input>>,ANTLRError> {
		self.conditionalOrExpression_rec(0)
	}

	fn conditionalOrExpression_rec(&mut self, _p: isize)
	-> Result<Rc<ConditionalOrExpressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = ConditionalOrExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 462, RULE_conditionalOrExpression, _p);
	    let mut _localctx: Rc<ConditionalOrExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 462;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule conditionalAndExpression*/
			recog.base.set_state(2847);
			recog.conditionalAndExpression_rec(0)?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(2854);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(347,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					{
					/*recRuleAltStartAction*/
					let mut tmp = ConditionalOrExpressionContextExt::new(_parentctx.clone(), _parentState);
					recog.push_new_recursion_context(tmp.clone(), _startState, RULE_conditionalOrExpression);
					_localctx = tmp;
					recog.base.set_state(2849);
					if !({recog.precpred(None, 1)}) {
						Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
					}
					recog.base.set_state(2850);
					recog.base.match_token(OR,&mut recog.err_handler)?;

					/*InvokeRule conditionalAndExpression*/
					recog.base.set_state(2851);
					recog.conditionalAndExpression_rec(0)?;

					}
					} 
				}
				recog.base.set_state(2856);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(347,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- conditionalExpression ----------------
pub type ConditionalExpressionContextAll<'input> = ConditionalExpressionContext<'input>;


pub type ConditionalExpressionContext<'input> = BaseParserRuleContext<'input,ConditionalExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ConditionalExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ConditionalExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ConditionalExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_conditionalExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_conditionalExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ConditionalExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_conditionalExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for ConditionalExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_conditionalExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_conditionalExpression }
}
antlr_rust::tid!{ConditionalExpressionContextExt<'a>}

impl<'input> ConditionalExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConditionalExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConditionalExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConditionalExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ConditionalExpressionContextExt<'input>>{

fn conditionalOrExpression(&self) -> Option<Rc<ConditionalOrExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token QUESTION
/// Returns `None` if there is no child corresponding to token QUESTION
fn QUESTION(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(QUESTION, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn conditionalExpression(&self) -> Option<Rc<ConditionalExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn lambdaExpression(&self) -> Option<Rc<LambdaExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConditionalExpressionContextAttrs<'input> for ConditionalExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn conditionalExpression(&mut self,)
	-> Result<Rc<ConditionalExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConditionalExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 464, RULE_conditionalExpression);
        let mut _localctx: Rc<ConditionalExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2870);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(348,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule conditionalOrExpression*/
					recog.base.set_state(2857);
					recog.conditionalOrExpression_rec(0)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule conditionalOrExpression*/
					recog.base.set_state(2858);
					recog.conditionalOrExpression_rec(0)?;

					recog.base.set_state(2859);
					recog.base.match_token(QUESTION,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(2860);
					recog.expression()?;

					recog.base.set_state(2861);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					/*InvokeRule conditionalExpression*/
					recog.base.set_state(2862);
					recog.conditionalExpression()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule conditionalOrExpression*/
					recog.base.set_state(2864);
					recog.conditionalOrExpression_rec(0)?;

					recog.base.set_state(2865);
					recog.base.match_token(QUESTION,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(2866);
					recog.expression()?;

					recog.base.set_state(2867);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					/*InvokeRule lambdaExpression*/
					recog.base.set_state(2868);
					recog.lambdaExpression()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- assignmentExpression ----------------
pub type AssignmentExpressionContextAll<'input> = AssignmentExpressionContext<'input>;


pub type AssignmentExpressionContext<'input> = BaseParserRuleContext<'input,AssignmentExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct AssignmentExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for AssignmentExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for AssignmentExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_assignmentExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_assignmentExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for AssignmentExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_assignmentExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for AssignmentExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_assignmentExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_assignmentExpression }
}
antlr_rust::tid!{AssignmentExpressionContextExt<'a>}

impl<'input> AssignmentExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AssignmentExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AssignmentExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AssignmentExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<AssignmentExpressionContextExt<'input>>{

fn conditionalExpression(&self) -> Option<Rc<ConditionalExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn assignment(&self) -> Option<Rc<AssignmentContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AssignmentExpressionContextAttrs<'input> for AssignmentExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn assignmentExpression(&mut self,)
	-> Result<Rc<AssignmentExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AssignmentExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 466, RULE_assignmentExpression);
        let mut _localctx: Rc<AssignmentExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2874);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(349,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule conditionalExpression*/
					recog.base.set_state(2872);
					recog.conditionalExpression()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule assignment*/
					recog.base.set_state(2873);
					recog.assignment()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- assignment ----------------
pub type AssignmentContextAll<'input> = AssignmentContext<'input>;


pub type AssignmentContext<'input> = BaseParserRuleContext<'input,AssignmentContextExt<'input>>;

#[derive(Clone)]
pub struct AssignmentContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for AssignmentContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for AssignmentContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_assignment(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_assignment(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for AssignmentContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_assignment(self);
	}
}

impl<'input> CustomRuleContext<'input> for AssignmentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_assignment }
	//fn type_rule_index() -> usize where Self: Sized { RULE_assignment }
}
antlr_rust::tid!{AssignmentContextExt<'a>}

impl<'input> AssignmentContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AssignmentContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AssignmentContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AssignmentContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<AssignmentContextExt<'input>>{

fn leftHandSide(&self) -> Option<Rc<LeftHandSideContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn assignmentOperator(&self) -> Option<Rc<AssignmentOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AssignmentContextAttrs<'input> for AssignmentContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn assignment(&mut self,)
	-> Result<Rc<AssignmentContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AssignmentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 468, RULE_assignment);
        let mut _localctx: Rc<AssignmentContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule leftHandSide*/
			recog.base.set_state(2876);
			recog.leftHandSide()?;

			/*InvokeRule assignmentOperator*/
			recog.base.set_state(2877);
			recog.assignmentOperator()?;

			/*InvokeRule expression*/
			recog.base.set_state(2878);
			recog.expression()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- leftHandSide ----------------
pub type LeftHandSideContextAll<'input> = LeftHandSideContext<'input>;


pub type LeftHandSideContext<'input> = BaseParserRuleContext<'input,LeftHandSideContextExt<'input>>;

#[derive(Clone)]
pub struct LeftHandSideContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for LeftHandSideContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for LeftHandSideContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_leftHandSide(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_leftHandSide(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for LeftHandSideContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_leftHandSide(self);
	}
}

impl<'input> CustomRuleContext<'input> for LeftHandSideContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_leftHandSide }
	//fn type_rule_index() -> usize where Self: Sized { RULE_leftHandSide }
}
antlr_rust::tid!{LeftHandSideContextExt<'a>}

impl<'input> LeftHandSideContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LeftHandSideContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LeftHandSideContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LeftHandSideContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<LeftHandSideContextExt<'input>>{

fn expressionName(&self) -> Option<Rc<ExpressionNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn fieldAccess(&self) -> Option<Rc<FieldAccessContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn arrayAccess(&self) -> Option<Rc<ArrayAccessContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LeftHandSideContextAttrs<'input> for LeftHandSideContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn leftHandSide(&mut self,)
	-> Result<Rc<LeftHandSideContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LeftHandSideContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 470, RULE_leftHandSide);
        let mut _localctx: Rc<LeftHandSideContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2883);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(350,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule expressionName*/
					recog.base.set_state(2880);
					recog.expressionName()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule fieldAccess*/
					recog.base.set_state(2881);
					recog.fieldAccess()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule arrayAccess*/
					recog.base.set_state(2882);
					recog.arrayAccess()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- assignmentOperator ----------------
pub type AssignmentOperatorContextAll<'input> = AssignmentOperatorContext<'input>;


pub type AssignmentOperatorContext<'input> = BaseParserRuleContext<'input,AssignmentOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct AssignmentOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for AssignmentOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for AssignmentOperatorContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_assignmentOperator(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_assignmentOperator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for AssignmentOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_assignmentOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for AssignmentOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_assignmentOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_assignmentOperator }
}
antlr_rust::tid!{AssignmentOperatorContextExt<'a>}

impl<'input> AssignmentOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AssignmentOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AssignmentOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AssignmentOperatorContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<AssignmentOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ASSIGN
/// Returns `None` if there is no child corresponding to token ASSIGN
fn ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(ASSIGN, 0)
}
/// Retrieves first TerminalNode corresponding to token MUL_ASSIGN
/// Returns `None` if there is no child corresponding to token MUL_ASSIGN
fn MUL_ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(MUL_ASSIGN, 0)
}
/// Retrieves first TerminalNode corresponding to token DIV_ASSIGN
/// Returns `None` if there is no child corresponding to token DIV_ASSIGN
fn DIV_ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(DIV_ASSIGN, 0)
}
/// Retrieves first TerminalNode corresponding to token MOD_ASSIGN
/// Returns `None` if there is no child corresponding to token MOD_ASSIGN
fn MOD_ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(MOD_ASSIGN, 0)
}
/// Retrieves first TerminalNode corresponding to token ADD_ASSIGN
/// Returns `None` if there is no child corresponding to token ADD_ASSIGN
fn ADD_ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(ADD_ASSIGN, 0)
}
/// Retrieves first TerminalNode corresponding to token SUB_ASSIGN
/// Returns `None` if there is no child corresponding to token SUB_ASSIGN
fn SUB_ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SUB_ASSIGN, 0)
}
/// Retrieves first TerminalNode corresponding to token LSHIFT_ASSIGN
/// Returns `None` if there is no child corresponding to token LSHIFT_ASSIGN
fn LSHIFT_ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LSHIFT_ASSIGN, 0)
}
/// Retrieves first TerminalNode corresponding to token RSHIFT_ASSIGN
/// Returns `None` if there is no child corresponding to token RSHIFT_ASSIGN
fn RSHIFT_ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RSHIFT_ASSIGN, 0)
}
/// Retrieves first TerminalNode corresponding to token URSHIFT_ASSIGN
/// Returns `None` if there is no child corresponding to token URSHIFT_ASSIGN
fn URSHIFT_ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(URSHIFT_ASSIGN, 0)
}
/// Retrieves first TerminalNode corresponding to token AND_ASSIGN
/// Returns `None` if there is no child corresponding to token AND_ASSIGN
fn AND_ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(AND_ASSIGN, 0)
}
/// Retrieves first TerminalNode corresponding to token XOR_ASSIGN
/// Returns `None` if there is no child corresponding to token XOR_ASSIGN
fn XOR_ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(XOR_ASSIGN, 0)
}
/// Retrieves first TerminalNode corresponding to token OR_ASSIGN
/// Returns `None` if there is no child corresponding to token OR_ASSIGN
fn OR_ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(OR_ASSIGN, 0)
}

}

impl<'input> AssignmentOperatorContextAttrs<'input> for AssignmentOperatorContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn assignmentOperator(&mut self,)
	-> Result<Rc<AssignmentOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AssignmentOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 472, RULE_assignmentOperator);
        let mut _localctx: Rc<AssignmentOperatorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2885);
			_la = recog.base.input.la(1);
			if { !(((((_la - 88)) & !0x3f) == 0 && ((1usize << (_la - 88)) & ((1usize << (ASSIGN - 88)) | (1usize << (ADD_ASSIGN - 88)) | (1usize << (SUB_ASSIGN - 88)) | (1usize << (MUL_ASSIGN - 88)) | (1usize << (DIV_ASSIGN - 88)) | (1usize << (AND_ASSIGN - 88)) | (1usize << (OR_ASSIGN - 88)) | (1usize << (XOR_ASSIGN - 88)) | (1usize << (MOD_ASSIGN - 88)))) != 0) || ((((_la - 120)) & !0x3f) == 0 && ((1usize << (_la - 120)) & ((1usize << (LSHIFT_ASSIGN - 120)) | (1usize << (RSHIFT_ASSIGN - 120)) | (1usize << (URSHIFT_ASSIGN - 120)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lambdaExpression ----------------
pub type LambdaExpressionContextAll<'input> = LambdaExpressionContext<'input>;


pub type LambdaExpressionContext<'input> = BaseParserRuleContext<'input,LambdaExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct LambdaExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for LambdaExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for LambdaExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_lambdaExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_lambdaExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for LambdaExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_lambdaExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for LambdaExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lambdaExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lambdaExpression }
}
antlr_rust::tid!{LambdaExpressionContextExt<'a>}

impl<'input> LambdaExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LambdaExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LambdaExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LambdaExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<LambdaExpressionContextExt<'input>>{

fn lambdaParameters(&self) -> Option<Rc<LambdaParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ARROW
/// Returns `None` if there is no child corresponding to token ARROW
fn ARROW(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(ARROW, 0)
}
fn lambdaBody(&self) -> Option<Rc<LambdaBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LambdaExpressionContextAttrs<'input> for LambdaExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lambdaExpression(&mut self,)
	-> Result<Rc<LambdaExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LambdaExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 474, RULE_lambdaExpression);
        let mut _localctx: Rc<LambdaExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule lambdaParameters*/
			recog.base.set_state(2887);
			recog.lambdaParameters()?;

			recog.base.set_state(2888);
			recog.base.match_token(ARROW,&mut recog.err_handler)?;

			/*InvokeRule lambdaBody*/
			recog.base.set_state(2889);
			recog.lambdaBody()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lambdaParameters ----------------
pub type LambdaParametersContextAll<'input> = LambdaParametersContext<'input>;


pub type LambdaParametersContext<'input> = BaseParserRuleContext<'input,LambdaParametersContextExt<'input>>;

#[derive(Clone)]
pub struct LambdaParametersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for LambdaParametersContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for LambdaParametersContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_lambdaParameters(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_lambdaParameters(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for LambdaParametersContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_lambdaParameters(self);
	}
}

impl<'input> CustomRuleContext<'input> for LambdaParametersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lambdaParameters }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lambdaParameters }
}
antlr_rust::tid!{LambdaParametersContextExt<'a>}

impl<'input> LambdaParametersContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LambdaParametersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LambdaParametersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LambdaParametersContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<LambdaParametersContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn lambdaParameterList(&self) -> Option<Rc<LambdaParameterListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}

}

impl<'input> LambdaParametersContextAttrs<'input> for LambdaParametersContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lambdaParameters(&mut self,)
	-> Result<Rc<LambdaParametersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LambdaParametersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 476, RULE_lambdaParameters);
        let mut _localctx: Rc<LambdaParametersContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2897);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LPAREN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2891);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2893);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << VAR) | (1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE))) != 0) || ((((_la - 35)) & !0x3f) == 0 && ((1usize << (_la - 35)) & ((1usize << (FINAL - 35)) | (1usize << (FLOAT - 35)) | (1usize << (INT - 35)) | (1usize << (LONG - 35)) | (1usize << (SHORT - 35)))) != 0) || _la==AT || _la==Identifier {
						{
						/*InvokeRule lambdaParameterList*/
						recog.base.set_state(2892);
						recog.lambdaParameterList()?;

						}
					}

					recog.base.set_state(2895);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}

			 Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2896);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lambdaParameterList ----------------
pub type LambdaParameterListContextAll<'input> = LambdaParameterListContext<'input>;


pub type LambdaParameterListContext<'input> = BaseParserRuleContext<'input,LambdaParameterListContextExt<'input>>;

#[derive(Clone)]
pub struct LambdaParameterListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for LambdaParameterListContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for LambdaParameterListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_lambdaParameterList(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_lambdaParameterList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for LambdaParameterListContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_lambdaParameterList(self);
	}
}

impl<'input> CustomRuleContext<'input> for LambdaParameterListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lambdaParameterList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lambdaParameterList }
}
antlr_rust::tid!{LambdaParameterListContextExt<'a>}

impl<'input> LambdaParameterListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LambdaParameterListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LambdaParameterListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LambdaParameterListContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<LambdaParameterListContextExt<'input>>{

fn lambdaParameter_all(&self) ->  Vec<Rc<LambdaParameterContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn lambdaParameter(&self, i: usize) -> Option<Rc<LambdaParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
/// Retrieves all `TerminalNode`s corresponding to token Identifier in current rule
fn Identifier_all(&self) -> Vec<Rc<TerminalNode<'input,Java20ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Identifier, starting from 0.
/// Returns `None` if number of children corresponding to token Identifier is less or equal than `i`.
fn Identifier(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, i)
}

}

impl<'input> LambdaParameterListContextAttrs<'input> for LambdaParameterListContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lambdaParameterList(&mut self,)
	-> Result<Rc<LambdaParameterListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LambdaParameterListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 478, RULE_lambdaParameterList);
        let mut _localctx: Rc<LambdaParameterListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2915);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(355,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule lambdaParameter*/
					recog.base.set_state(2899);
					recog.lambdaParameter()?;

					recog.base.set_state(2904);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==COMMA {
						{
						{
						recog.base.set_state(2900);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						/*InvokeRule lambdaParameter*/
						recog.base.set_state(2901);
						recog.lambdaParameter()?;

						}
						}
						recog.base.set_state(2906);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2907);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					recog.base.set_state(2912);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==COMMA {
						{
						{
						recog.base.set_state(2908);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						recog.base.set_state(2909);
						recog.base.match_token(Identifier,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2914);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lambdaParameter ----------------
pub type LambdaParameterContextAll<'input> = LambdaParameterContext<'input>;


pub type LambdaParameterContext<'input> = BaseParserRuleContext<'input,LambdaParameterContextExt<'input>>;

#[derive(Clone)]
pub struct LambdaParameterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for LambdaParameterContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for LambdaParameterContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_lambdaParameter(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_lambdaParameter(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for LambdaParameterContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_lambdaParameter(self);
	}
}

impl<'input> CustomRuleContext<'input> for LambdaParameterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lambdaParameter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lambdaParameter }
}
antlr_rust::tid!{LambdaParameterContextExt<'a>}

impl<'input> LambdaParameterContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LambdaParameterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LambdaParameterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LambdaParameterContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<LambdaParameterContextExt<'input>>{

fn lambdaParameterType(&self) -> Option<Rc<LambdaParameterTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableDeclaratorId(&self) -> Option<Rc<VariableDeclaratorIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableModifier_all(&self) ->  Vec<Rc<VariableModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn variableModifier(&self, i: usize) -> Option<Rc<VariableModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn variableArityParameter(&self) -> Option<Rc<VariableArityParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LambdaParameterContextAttrs<'input> for LambdaParameterContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lambdaParameter(&mut self,)
	-> Result<Rc<LambdaParameterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LambdaParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 480, RULE_lambdaParameter);
        let mut _localctx: Rc<LambdaParameterContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2927);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(357,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2920);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==FINAL || _la==AT {
						{
						{
						/*InvokeRule variableModifier*/
						recog.base.set_state(2917);
						recog.variableModifier()?;

						}
						}
						recog.base.set_state(2922);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule lambdaParameterType*/
					recog.base.set_state(2923);
					recog.lambdaParameterType()?;

					/*InvokeRule variableDeclaratorId*/
					recog.base.set_state(2924);
					recog.variableDeclaratorId()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule variableArityParameter*/
					recog.base.set_state(2926);
					recog.variableArityParameter()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lambdaParameterType ----------------
pub type LambdaParameterTypeContextAll<'input> = LambdaParameterTypeContext<'input>;


pub type LambdaParameterTypeContext<'input> = BaseParserRuleContext<'input,LambdaParameterTypeContextExt<'input>>;

#[derive(Clone)]
pub struct LambdaParameterTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for LambdaParameterTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for LambdaParameterTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_lambdaParameterType(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_lambdaParameterType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for LambdaParameterTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_lambdaParameterType(self);
	}
}

impl<'input> CustomRuleContext<'input> for LambdaParameterTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lambdaParameterType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lambdaParameterType }
}
antlr_rust::tid!{LambdaParameterTypeContextExt<'a>}

impl<'input> LambdaParameterTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LambdaParameterTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LambdaParameterTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LambdaParameterTypeContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<LambdaParameterTypeContextExt<'input>>{

fn unannType(&self) -> Option<Rc<UnannTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token VAR
/// Returns `None` if there is no child corresponding to token VAR
fn VAR(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(VAR, 0)
}

}

impl<'input> LambdaParameterTypeContextAttrs<'input> for LambdaParameterTypeContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lambdaParameterType(&mut self,)
	-> Result<Rc<LambdaParameterTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LambdaParameterTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 482, RULE_lambdaParameterType);
        let mut _localctx: Rc<LambdaParameterTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2931);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 BOOLEAN | BYTE | CHAR | DOUBLE | FLOAT | INT | LONG | SHORT | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule unannType*/
					recog.base.set_state(2929);
					recog.unannType()?;

					}
				}

			 VAR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2930);
					recog.base.match_token(VAR,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lambdaBody ----------------
pub type LambdaBodyContextAll<'input> = LambdaBodyContext<'input>;


pub type LambdaBodyContext<'input> = BaseParserRuleContext<'input,LambdaBodyContextExt<'input>>;

#[derive(Clone)]
pub struct LambdaBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for LambdaBodyContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for LambdaBodyContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_lambdaBody(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_lambdaBody(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for LambdaBodyContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_lambdaBody(self);
	}
}

impl<'input> CustomRuleContext<'input> for LambdaBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lambdaBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lambdaBody }
}
antlr_rust::tid!{LambdaBodyContextExt<'a>}

impl<'input> LambdaBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LambdaBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LambdaBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LambdaBodyContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<LambdaBodyContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LambdaBodyContextAttrs<'input> for LambdaBodyContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lambdaBody(&mut self,)
	-> Result<Rc<LambdaBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LambdaBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 484, RULE_lambdaBody);
        let mut _localctx: Rc<LambdaBodyContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2935);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 BOOLEAN | BYTE | CHAR | DOUBLE | FLOAT | INT | LONG | NEW | SHORT | SUPER |
			 SWITCH | THIS | VOID | IntegerLiteral | FloatingPointLiteral | BooleanLiteral |
			 CharacterLiteral | StringLiteral | TextBlock | NullLiteral | LPAREN |
			 AT | BANG | TILDE | INC | DEC | ADD | SUB | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule expression*/
					recog.base.set_state(2933);
					recog.expression()?;

					}
				}

			 LBRACE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule block*/
					recog.base.set_state(2934);
					recog.block()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- switchExpression ----------------
pub type SwitchExpressionContextAll<'input> = SwitchExpressionContext<'input>;


pub type SwitchExpressionContext<'input> = BaseParserRuleContext<'input,SwitchExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct SwitchExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for SwitchExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for SwitchExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_switchExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_switchExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for SwitchExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_switchExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for SwitchExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_switchExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_switchExpression }
}
antlr_rust::tid!{SwitchExpressionContextExt<'a>}

impl<'input> SwitchExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SwitchExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SwitchExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SwitchExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<SwitchExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token SWITCH
/// Returns `None` if there is no child corresponding to token SWITCH
fn SWITCH(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(SWITCH, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java20ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn switchBlock(&self) -> Option<Rc<SwitchBlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SwitchExpressionContextAttrs<'input> for SwitchExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn switchExpression(&mut self,)
	-> Result<Rc<SwitchExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SwitchExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 486, RULE_switchExpression);
        let mut _localctx: Rc<SwitchExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2937);
			recog.base.match_token(SWITCH,&mut recog.err_handler)?;

			recog.base.set_state(2938);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(2939);
			recog.expression()?;

			recog.base.set_state(2940);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule switchBlock*/
			recog.base.set_state(2941);
			recog.switchBlock()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constantExpression ----------------
pub type ConstantExpressionContextAll<'input> = ConstantExpressionContext<'input>;


pub type ConstantExpressionContext<'input> = BaseParserRuleContext<'input,ConstantExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ConstantExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java20ParserContext<'input> for ConstantExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java20ParserListener<'input> + 'a> for ConstantExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constantExpression(self);
		}
		fn exit(&self,listener: &mut (dyn Java20ParserListener<'input> + 'a)) {
			listener.exit_constantExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn Java20ParserVisitor<'input> + 'a> for ConstantExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn Java20ParserVisitor<'input> + 'a)) {
		visitor.visit_constantExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for ConstantExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java20ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constantExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constantExpression }
}
antlr_rust::tid!{ConstantExpressionContextExt<'a>}

impl<'input> ConstantExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java20ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstantExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstantExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstantExpressionContextAttrs<'input>: Java20ParserContext<'input> + BorrowMut<ConstantExpressionContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConstantExpressionContextAttrs<'input> for ConstantExpressionContext<'input>{}

impl<'input, I, H> Java20Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constantExpression(&mut self,)
	-> Result<Rc<ConstantExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstantExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 488, RULE_constantExpression);
        let mut _localctx: Rc<ConstantExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule expression*/
			recog.base.set_state(2943);
			recog.expression()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}

lazy_static! {
    static ref _ATN: Arc<ATN> =
        Arc::new(ATNDeserializer::new(None).deserialize(_serializedATN.chars()));
    static ref _decision_to_DFA: Arc<Vec<antlr_rust::RwLock<DFA>>> = {
        let mut dfa = Vec::new();
        let size = _ATN.decision_to_state.len();
        for i in 0..size {
            dfa.push(DFA::new(
                _ATN.clone(),
                _ATN.get_decision_state(i),
                i as isize,
            ).into())
        }
        Arc::new(dfa)
    };
}



const _serializedATN:&'static str =
	"\x03\u{608b}\u{a72a}\u{8133}\u{b9ed}\u{417c}\u{3be7}\u{7786}\u{5964}\x03\
	\u{80}\u{b84}\x04\x02\x09\x02\x04\x03\x09\x03\x04\x04\x09\x04\x04\x05\x09\
	\x05\x04\x06\x09\x06\x04\x07\x09\x07\x04\x08\x09\x08\x04\x09\x09\x09\x04\
	\x0a\x09\x0a\x04\x0b\x09\x0b\x04\x0c\x09\x0c\x04\x0d\x09\x0d\x04\x0e\x09\
	\x0e\x04\x0f\x09\x0f\x04\x10\x09\x10\x04\x11\x09\x11\x04\x12\x09\x12\x04\
	\x13\x09\x13\x04\x14\x09\x14\x04\x15\x09\x15\x04\x16\x09\x16\x04\x17\x09\
	\x17\x04\x18\x09\x18\x04\x19\x09\x19\x04\x1a\x09\x1a\x04\x1b\x09\x1b\x04\
	\x1c\x09\x1c\x04\x1d\x09\x1d\x04\x1e\x09\x1e\x04\x1f\x09\x1f\x04\x20\x09\
	\x20\x04\x21\x09\x21\x04\x22\x09\x22\x04\x23\x09\x23\x04\x24\x09\x24\x04\
	\x25\x09\x25\x04\x26\x09\x26\x04\x27\x09\x27\x04\x28\x09\x28\x04\x29\x09\
	\x29\x04\x2a\x09\x2a\x04\x2b\x09\x2b\x04\x2c\x09\x2c\x04\x2d\x09\x2d\x04\
	\x2e\x09\x2e\x04\x2f\x09\x2f\x04\x30\x09\x30\x04\x31\x09\x31\x04\x32\x09\
	\x32\x04\x33\x09\x33\x04\x34\x09\x34\x04\x35\x09\x35\x04\x36\x09\x36\x04\
	\x37\x09\x37\x04\x38\x09\x38\x04\x39\x09\x39\x04\x3a\x09\x3a\x04\x3b\x09\
	\x3b\x04\x3c\x09\x3c\x04\x3d\x09\x3d\x04\x3e\x09\x3e\x04\x3f\x09\x3f\x04\
	\x40\x09\x40\x04\x41\x09\x41\x04\x42\x09\x42\x04\x43\x09\x43\x04\x44\x09\
	\x44\x04\x45\x09\x45\x04\x46\x09\x46\x04\x47\x09\x47\x04\x48\x09\x48\x04\
	\x49\x09\x49\x04\x4a\x09\x4a\x04\x4b\x09\x4b\x04\x4c\x09\x4c\x04\x4d\x09\
	\x4d\x04\x4e\x09\x4e\x04\x4f\x09\x4f\x04\x50\x09\x50\x04\x51\x09\x51\x04\
	\x52\x09\x52\x04\x53\x09\x53\x04\x54\x09\x54\x04\x55\x09\x55\x04\x56\x09\
	\x56\x04\x57\x09\x57\x04\x58\x09\x58\x04\x59\x09\x59\x04\x5a\x09\x5a\x04\
	\x5b\x09\x5b\x04\x5c\x09\x5c\x04\x5d\x09\x5d\x04\x5e\x09\x5e\x04\x5f\x09\
	\x5f\x04\x60\x09\x60\x04\x61\x09\x61\x04\x62\x09\x62\x04\x63\x09\x63\x04\
	\x64\x09\x64\x04\x65\x09\x65\x04\x66\x09\x66\x04\x67\x09\x67\x04\x68\x09\
	\x68\x04\x69\x09\x69\x04\x6a\x09\x6a\x04\x6b\x09\x6b\x04\x6c\x09\x6c\x04\
	\x6d\x09\x6d\x04\x6e\x09\x6e\x04\x6f\x09\x6f\x04\x70\x09\x70\x04\x71\x09\
	\x71\x04\x72\x09\x72\x04\x73\x09\x73\x04\x74\x09\x74\x04\x75\x09\x75\x04\
	\x76\x09\x76\x04\x77\x09\x77\x04\x78\x09\x78\x04\x79\x09\x79\x04\x7a\x09\
	\x7a\x04\x7b\x09\x7b\x04\x7c\x09\x7c\x04\x7d\x09\x7d\x04\x7e\x09\x7e\x04\
	\x7f\x09\x7f\x04\u{80}\x09\u{80}\x04\u{81}\x09\u{81}\x04\u{82}\x09\u{82}\
	\x04\u{83}\x09\u{83}\x04\u{84}\x09\u{84}\x04\u{85}\x09\u{85}\x04\u{86}\x09\
	\u{86}\x04\u{87}\x09\u{87}\x04\u{88}\x09\u{88}\x04\u{89}\x09\u{89}\x04\u{8a}\
	\x09\u{8a}\x04\u{8b}\x09\u{8b}\x04\u{8c}\x09\u{8c}\x04\u{8d}\x09\u{8d}\x04\
	\u{8e}\x09\u{8e}\x04\u{8f}\x09\u{8f}\x04\u{90}\x09\u{90}\x04\u{91}\x09\u{91}\
	\x04\u{92}\x09\u{92}\x04\u{93}\x09\u{93}\x04\u{94}\x09\u{94}\x04\u{95}\x09\
	\u{95}\x04\u{96}\x09\u{96}\x04\u{97}\x09\u{97}\x04\u{98}\x09\u{98}\x04\u{99}\
	\x09\u{99}\x04\u{9a}\x09\u{9a}\x04\u{9b}\x09\u{9b}\x04\u{9c}\x09\u{9c}\x04\
	\u{9d}\x09\u{9d}\x04\u{9e}\x09\u{9e}\x04\u{9f}\x09\u{9f}\x04\u{a0}\x09\u{a0}\
	\x04\u{a1}\x09\u{a1}\x04\u{a2}\x09\u{a2}\x04\u{a3}\x09\u{a3}\x04\u{a4}\x09\
	\u{a4}\x04\u{a5}\x09\u{a5}\x04\u{a6}\x09\u{a6}\x04\u{a7}\x09\u{a7}\x04\u{a8}\
	\x09\u{a8}\x04\u{a9}\x09\u{a9}\x04\u{aa}\x09\u{aa}\x04\u{ab}\x09\u{ab}\x04\
	\u{ac}\x09\u{ac}\x04\u{ad}\x09\u{ad}\x04\u{ae}\x09\u{ae}\x04\u{af}\x09\u{af}\
	\x04\u{b0}\x09\u{b0}\x04\u{b1}\x09\u{b1}\x04\u{b2}\x09\u{b2}\x04\u{b3}\x09\
	\u{b3}\x04\u{b4}\x09\u{b4}\x04\u{b5}\x09\u{b5}\x04\u{b6}\x09\u{b6}\x04\u{b7}\
	\x09\u{b7}\x04\u{b8}\x09\u{b8}\x04\u{b9}\x09\u{b9}\x04\u{ba}\x09\u{ba}\x04\
	\u{bb}\x09\u{bb}\x04\u{bc}\x09\u{bc}\x04\u{bd}\x09\u{bd}\x04\u{be}\x09\u{be}\
	\x04\u{bf}\x09\u{bf}\x04\u{c0}\x09\u{c0}\x04\u{c1}\x09\u{c1}\x04\u{c2}\x09\
	\u{c2}\x04\u{c3}\x09\u{c3}\x04\u{c4}\x09\u{c4}\x04\u{c5}\x09\u{c5}\x04\u{c6}\
	\x09\u{c6}\x04\u{c7}\x09\u{c7}\x04\u{c8}\x09\u{c8}\x04\u{c9}\x09\u{c9}\x04\
	\u{ca}\x09\u{ca}\x04\u{cb}\x09\u{cb}\x04\u{cc}\x09\u{cc}\x04\u{cd}\x09\u{cd}\
	\x04\u{ce}\x09\u{ce}\x04\u{cf}\x09\u{cf}\x04\u{d0}\x09\u{d0}\x04\u{d1}\x09\
	\u{d1}\x04\u{d2}\x09\u{d2}\x04\u{d3}\x09\u{d3}\x04\u{d4}\x09\u{d4}\x04\u{d5}\
	\x09\u{d5}\x04\u{d6}\x09\u{d6}\x04\u{d7}\x09\u{d7}\x04\u{d8}\x09\u{d8}\x04\
	\u{d9}\x09\u{d9}\x04\u{da}\x09\u{da}\x04\u{db}\x09\u{db}\x04\u{dc}\x09\u{dc}\
	\x04\u{dd}\x09\u{dd}\x04\u{de}\x09\u{de}\x04\u{df}\x09\u{df}\x04\u{e0}\x09\
	\u{e0}\x04\u{e1}\x09\u{e1}\x04\u{e2}\x09\u{e2}\x04\u{e3}\x09\u{e3}\x04\u{e4}\
	\x09\u{e4}\x04\u{e5}\x09\u{e5}\x04\u{e6}\x09\u{e6}\x04\u{e7}\x09\u{e7}\x04\
	\u{e8}\x09\u{e8}\x04\u{e9}\x09\u{e9}\x04\u{ea}\x09\u{ea}\x04\u{eb}\x09\u{eb}\
	\x04\u{ec}\x09\u{ec}\x04\u{ed}\x09\u{ed}\x04\u{ee}\x09\u{ee}\x04\u{ef}\x09\
	\u{ef}\x04\u{f0}\x09\u{f0}\x04\u{f1}\x09\u{f1}\x04\u{f2}\x09\u{f2}\x04\u{f3}\
	\x09\u{f3}\x04\u{f4}\x09\u{f4}\x04\u{f5}\x09\u{f5}\x04\u{f6}\x09\u{f6}\x03\
	\x02\x03\x02\x03\x02\x03\x03\x03\x03\x03\x04\x03\x04\x03\x05\x03\x05\x03\
	\x06\x07\x06\u{1f7}\x0a\x06\x0c\x06\x0e\x06\u{1fa}\x0b\x06\x03\x06\x03\x06\
	\x05\x06\u{1fe}\x0a\x06\x03\x07\x03\x07\x05\x07\u{202}\x0a\x07\x03\x08\x03\
	\x08\x03\x09\x03\x09\x03\x0a\x03\x0a\x03\x0a\x05\x0a\u{20b}\x0a\x0a\x03\
	\x0b\x03\x0b\x07\x0b\u{20f}\x0a\x0b\x0c\x0b\x0e\x0b\u{212}\x0b\x0b\x03\x0b\
	\x03\x0b\x05\x0b\u{216}\x0a\x0b\x03\x0b\x05\x0b\u{219}\x0a\x0b\x03\x0c\x03\
	\x0c\x03\x0c\x05\x0c\u{21e}\x0a\x0c\x03\x0c\x07\x0c\u{221}\x0a\x0c\x0c\x0c\
	\x0e\x0c\u{224}\x0b\x0c\x03\x0c\x03\x0c\x05\x0c\u{228}\x0a\x0c\x03\x0c\x05\
	\x0c\u{22b}\x0a\x0c\x03\x0d\x07\x0d\u{22e}\x0a\x0d\x0c\x0d\x0e\x0d\u{231}\
	\x0b\x0d\x03\x0d\x03\x0d\x05\x0d\u{235}\x0a\x0d\x03\x0d\x03\x0d\x03\x0d\
	\x07\x0d\u{23a}\x0a\x0d\x0c\x0d\x0e\x0d\u{23d}\x0b\x0d\x03\x0d\x03\x0d\x05\
	\x0d\u{241}\x0a\x0d\x03\x0d\x03\x0d\x03\x0d\x07\x0d\u{246}\x0a\x0d\x0c\x0d\
	\x0e\x0d\u{249}\x0b\x0d\x03\x0d\x03\x0d\x05\x0d\u{24d}\x0a\x0d\x05\x0d\u{24f}\
	\x0a\x0d\x03\x0e\x03\x0e\x03\x0f\x07\x0f\u{254}\x0a\x0f\x0c\x0f\x0e\x0f\
	\u{257}\x0b\x0f\x03\x0f\x03\x0f\x03\x10\x03\x10\x03\x10\x03\x10\x03\x10\
	\x03\x10\x03\x10\x03\x10\x03\x10\x05\x10\u{264}\x0a\x10\x03\x11\x07\x11\
	\u{267}\x0a\x11\x0c\x11\x0e\x11\u{26a}\x0b\x11\x03\x11\x03\x11\x03\x11\x07\
	\x11\u{26f}\x0a\x11\x0c\x11\x0e\x11\u{272}\x0b\x11\x03\x11\x03\x11\x07\x11\
	\u{276}\x0a\x11\x0c\x11\x0e\x11\u{279}\x0b\x11\x03\x12\x07\x12\u{27c}\x0a\
	\x12\x0c\x12\x0e\x12\u{27f}\x0b\x12\x03\x12\x03\x12\x05\x12\u{283}\x0a\x12\
	\x03\x13\x03\x13\x03\x14\x03\x14\x03\x14\x03\x14\x07\x14\u{28b}\x0a\x14\
	\x0c\x14\x0e\x14\u{28e}\x0b\x14\x05\x14\u{290}\x0a\x14\x03\x15\x03\x15\x03\
	\x15\x03\x16\x03\x16\x03\x16\x03\x16\x03\x17\x03\x17\x03\x17\x07\x17\u{29c}\
	\x0a\x17\x0c\x17\x0e\x17\u{29f}\x0b\x17\x03\x18\x03\x18\x05\x18\u{2a3}\x0a\
	\x18\x03\x19\x07\x19\u{2a6}\x0a\x19\x0c\x19\x0e\x19\u{2a9}\x0b\x19\x03\x19\
	\x03\x19\x05\x19\u{2ad}\x0a\x19\x03\x1a\x03\x1a\x03\x1a\x03\x1a\x05\x1a\
	\u{2b3}\x0a\x1a\x03\x1b\x03\x1b\x03\x1b\x05\x1b\u{2b8}\x0a\x1b\x03\x1c\x03\
	\x1c\x03\x1c\x05\x1c\u{2bd}\x0a\x1c\x03\x1d\x03\x1d\x03\x1d\x05\x1d\u{2c2}\
	\x0a\x1d\x03\x1e\x03\x1e\x03\x1e\x05\x1e\u{2c7}\x0a\x1e\x03\x1f\x03\x1f\
	\x03\x1f\x05\x1f\u{2cc}\x0a\x1f\x03\x1f\x03\x1f\x03\x20\x03\x20\x03\x21\
	\x03\x21\x03\x21\x05\x21\u{2d5}\x0a\x21\x03\x22\x03\x22\x05\x22\u{2d9}\x0a\
	\x22\x03\x23\x05\x23\u{2dc}\x0a\x23\x03\x23\x07\x23\u{2df}\x0a\x23\x0c\x23\
	\x0e\x23\u{2e2}\x0b\x23\x03\x23\x07\x23\u{2e5}\x0a\x23\x0c\x23\x0e\x23\u{2e8}\
	\x0b\x23\x03\x24\x07\x24\u{2eb}\x0a\x24\x0c\x24\x0e\x24\u{2ee}\x0b\x24\x03\
	\x24\x03\x24\x03\x25\x07\x25\u{2f3}\x0a\x25\x0c\x25\x0e\x25\u{2f6}\x0b\x25\
	\x03\x25\x03\x25\x03\x25\x03\x25\x07\x25\u{2fc}\x0a\x25\x0c\x25\x0e\x25\
	\u{2ff}\x0b\x25\x03\x25\x03\x25\x03\x26\x03\x26\x03\x27\x03\x27\x03\x27\
	\x03\x27\x05\x27\u{309}\x0a\x27\x03\x28\x03\x28\x03\x28\x03\x28\x03\x29\
	\x03\x29\x03\x29\x03\x29\x03\x29\x03\x29\x03\x2a\x03\x2a\x03\x2a\x03\x2a\
	\x03\x2a\x03\x2a\x03\x2a\x03\x2b\x03\x2b\x03\x2b\x03\x2b\x03\x2b\x03\x2b\
	\x03\x2b\x03\x2c\x03\x2c\x03\x2c\x05\x2c\u{326}\x0a\x2c\x03\x2d\x07\x2d\
	\u{329}\x0a\x2d\x0c\x2d\x0e\x2d\u{32c}\x0b\x2d\x03\x2d\x05\x2d\u{32f}\x0a\
	\x2d\x03\x2d\x03\x2d\x03\x2d\x03\x2d\x07\x2d\u{335}\x0a\x2d\x0c\x2d\x0e\
	\x2d\u{338}\x0b\x2d\x03\x2d\x03\x2d\x07\x2d\u{33c}\x0a\x2d\x0c\x2d\x0e\x2d\
	\u{33f}\x0b\x2d\x03\x2d\x03\x2d\x03\x2e\x03\x2e\x07\x2e\u{345}\x0a\x2e\x0c\
	\x2e\x0e\x2e\u{348}\x0b\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x03\
	\x2e\x03\x2e\x03\x2e\x03\x2e\x07\x2e\u{353}\x0a\x2e\x0c\x2e\x0e\x2e\u{356}\
	\x0b\x2e\x05\x2e\u{358}\x0a\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\
	\x03\x2e\x03\x2e\x03\x2e\x07\x2e\u{362}\x0a\x2e\x0c\x2e\x0e\x2e\u{365}\x0b\
	\x2e\x05\x2e\u{367}\x0a\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x03\
	\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x07\x2e\u{375}\x0a\
	\x2e\x0c\x2e\x0e\x2e\u{378}\x0b\x2e\x03\x2e\x03\x2e\x05\x2e\u{37c}\x0a\x2e\
	\x03\x2f\x03\x2f\x03\x30\x03\x30\x03\x30\x05\x30\u{383}\x0a\x30\x03\x31\
	\x07\x31\u{386}\x0a\x31\x0c\x31\x0e\x31\u{389}\x0b\x31\x03\x31\x03\x31\x03\
	\x31\x05\x31\u{38e}\x0a\x31\x03\x31\x05\x31\u{391}\x0a\x31\x03\x31\x05\x31\
	\u{394}\x0a\x31\x03\x31\x05\x31\u{397}\x0a\x31\x03\x31\x03\x31\x03\x32\x03\
	\x32\x03\x32\x03\x32\x03\x32\x03\x32\x03\x32\x03\x32\x03\x32\x03\x32\x05\
	\x32\u{3a5}\x0a\x32\x03\x33\x03\x33\x03\x33\x03\x33\x03\x34\x03\x34\x03\
	\x34\x07\x34\u{3ae}\x0a\x34\x0c\x34\x0e\x34\u{3b1}\x0b\x34\x03\x35\x03\x35\
	\x03\x35\x03\x36\x03\x36\x03\x36\x03\x37\x03\x37\x03\x37\x07\x37\u{3bc}\
	\x0a\x37\x0c\x37\x0e\x37\u{3bf}\x0b\x37\x03\x38\x03\x38\x03\x38\x03\x38\
	\x07\x38\u{3c5}\x0a\x38\x0c\x38\x0e\x38\u{3c8}\x0b\x38\x03\x39\x03\x39\x07\
	\x39\u{3cc}\x0a\x39\x0c\x39\x0e\x39\u{3cf}\x0b\x39\x03\x39\x03\x39\x03\x3a\
	\x03\x3a\x03\x3a\x03\x3a\x05\x3a\u{3d7}\x0a\x3a\x03\x3b\x03\x3b\x03\x3b\
	\x03\x3b\x03\x3b\x05\x3b\u{3de}\x0a\x3b\x03\x3c\x07\x3c\u{3e1}\x0a\x3c\x0c\
	\x3c\x0e\x3c\u{3e4}\x0b\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3d\x03\
	\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x05\x3d\u{3f2}\x0a\
	\x3d\x03\x3e\x03\x3e\x03\x3e\x07\x3e\u{3f7}\x0a\x3e\x0c\x3e\x0e\x3e\u{3fa}\
	\x0b\x3e\x03\x3f\x03\x3f\x03\x3f\x05\x3f\u{3ff}\x0a\x3f\x03\x40\x03\x40\
	\x05\x40\u{403}\x0a\x40\x03\x41\x03\x41\x05\x41\u{407}\x0a\x41\x03\x42\x03\
	\x42\x05\x42\u{40b}\x0a\x42\x03\x43\x03\x43\x05\x43\u{40f}\x0a\x43\x03\x44\
	\x03\x44\x03\x44\x05\x44\u{414}\x0a\x44\x03\x45\x03\x45\x03\x45\x07\x45\
	\u{419}\x0a\x45\x0c\x45\x0e\x45\u{41c}\x0b\x45\x05\x45\u{41e}\x0a\x45\x03\
	\x45\x03\x45\x05\x45\u{422}\x0a\x45\x03\x45\x05\x45\u{425}\x0a\x45\x03\x46\
	\x03\x46\x07\x46\u{429}\x0a\x46\x0c\x46\x0e\x46\u{42c}\x0b\x46\x03\x46\x03\
	\x46\x05\x46\u{430}\x0a\x46\x03\x46\x05\x46\u{433}\x0a\x46\x03\x47\x03\x47\
	\x05\x47\u{437}\x0a\x47\x03\x47\x03\x47\x05\x47\u{43b}\x0a\x47\x03\x47\x03\
	\x47\x07\x47\u{43f}\x0a\x47\x0c\x47\x0e\x47\u{442}\x0b\x47\x03\x47\x03\x47\
	\x05\x47\u{446}\x0a\x47\x05\x47\u{448}\x0a\x47\x03\x48\x03\x48\x03\x49\x03\
	\x49\x03\x4a\x03\x4a\x03\x4a\x05\x4a\u{451}\x0a\x4a\x03\x4a\x03\x4a\x03\
	\x4b\x07\x4b\u{456}\x0a\x4b\x0c\x4b\x0e\x4b\u{459}\x0b\x4b\x03\x4b\x03\x4b\
	\x03\x4b\x03\x4c\x03\x4c\x03\x4c\x03\x4c\x03\x4c\x03\x4c\x03\x4c\x03\x4c\
	\x03\x4c\x03\x4c\x05\x4c\u{468}\x0a\x4c\x03\x4d\x03\x4d\x07\x4d\u{46c}\x0a\
	\x4d\x0c\x4d\x0e\x4d\u{46f}\x0b\x4d\x05\x4d\u{471}\x0a\x4d\x03\x4d\x03\x4d\
	\x03\x4d\x05\x4d\u{476}\x0a\x4d\x03\x4e\x03\x4e\x05\x4e\u{47a}\x0a\x4e\x03\
	\x4f\x03\x4f\x03\x4f\x03\x4f\x03\x4f\x05\x4f\u{481}\x0a\x4f\x03\x4f\x05\
	\x4f\u{484}\x0a\x4f\x03\x4f\x03\x4f\x05\x4f\u{488}\x0a\x4f\x03\x50\x07\x50\
	\u{48b}\x0a\x50\x0c\x50\x0e\x50\u{48e}\x0b\x50\x03\x50\x03\x50\x03\x50\x05\
	\x50\u{493}\x0a\x50\x03\x50\x03\x50\x03\x51\x03\x51\x03\x51\x07\x51\u{49a}\
	\x0a\x51\x0c\x51\x0e\x51\u{49d}\x0b\x51\x03\x52\x07\x52\u{4a0}\x0a\x52\x0c\
	\x52\x0e\x52\u{4a3}\x0b\x52\x03\x52\x03\x52\x03\x52\x03\x52\x05\x52\u{4a9}\
	\x0a\x52\x03\x53\x07\x53\u{4ac}\x0a\x53\x0c\x53\x0e\x53\u{4af}\x0b\x53\x03\
	\x53\x03\x53\x07\x53\u{4b3}\x0a\x53\x0c\x53\x0e\x53\u{4b6}\x0b\x53\x03\x53\
	\x03\x53\x03\x53\x03\x54\x03\x54\x05\x54\u{4bd}\x0a\x54\x03\x55\x03\x55\
	\x03\x55\x03\x56\x03\x56\x03\x56\x07\x56\u{4c5}\x0a\x56\x0c\x56\x0e\x56\
	\u{4c8}\x0b\x56\x03\x57\x03\x57\x05\x57\u{4cc}\x0a\x57\x03\x58\x03\x58\x05\
	\x58\u{4d0}\x0a\x58\x03\x59\x03\x59\x03\x5a\x03\x5a\x03\x5a\x03\x5b\x07\
	\x5b\u{4d8}\x0a\x5b\x0c\x5b\x0e\x5b\u{4db}\x0b\x5b\x03\x5b\x03\x5b\x05\x5b\
	\u{4df}\x0a\x5b\x03\x5b\x03\x5b\x03\x5c\x03\x5c\x03\x5c\x03\x5c\x05\x5c\
	\u{4e7}\x0a\x5c\x03\x5d\x05\x5d\u{4ea}\x0a\x5d\x03\x5d\x03\x5d\x03\x5d\x03\
	\x5d\x03\x5d\x05\x5d\u{4f1}\x0a\x5d\x03\x5d\x05\x5d\u{4f4}\x0a\x5d\x03\x5d\
	\x03\x5d\x03\x5e\x03\x5e\x03\x5f\x03\x5f\x05\x5f\u{4fc}\x0a\x5f\x03\x5f\
	\x05\x5f\u{4ff}\x0a\x5f\x03\x5f\x03\x5f\x03\x60\x05\x60\u{504}\x0a\x60\x03\
	\x60\x03\x60\x03\x60\x05\x60\u{509}\x0a\x60\x03\x60\x03\x60\x03\x60\x03\
	\x60\x05\x60\u{50f}\x0a\x60\x03\x60\x03\x60\x05\x60\u{513}\x0a\x60\x03\x60\
	\x03\x60\x03\x60\x05\x60\u{518}\x0a\x60\x03\x60\x03\x60\x03\x60\x05\x60\
	\u{51d}\x0a\x60\x03\x61\x07\x61\u{520}\x0a\x61\x0c\x61\x0e\x61\u{523}\x0b\
	\x61\x03\x61\x03\x61\x03\x61\x05\x61\u{528}\x0a\x61\x03\x61\x03\x61\x03\
	\x62\x03\x62\x05\x62\u{52e}\x0a\x62\x03\x62\x05\x62\u{531}\x0a\x62\x03\x62\
	\x05\x62\u{534}\x0a\x62\x03\x62\x03\x62\x03\x63\x03\x63\x03\x63\x07\x63\
	\u{53b}\x0a\x63\x0c\x63\x0e\x63\u{53e}\x0b\x63\x03\x64\x07\x64\u{541}\x0a\
	\x64\x0c\x64\x0e\x64\u{544}\x0b\x64\x03\x64\x03\x64\x03\x64\x05\x64\u{549}\
	\x0a\x64\x03\x64\x05\x64\u{54c}\x0a\x64\x03\x64\x05\x64\u{54f}\x0a\x64\x03\
	\x65\x03\x65\x03\x66\x03\x66\x07\x66\u{555}\x0a\x66\x0c\x66\x0e\x66\u{558}\
	\x0b\x66\x03\x67\x07\x67\u{55b}\x0a\x67\x0c\x67\x0e\x67\u{55e}\x0b\x67\x03\
	\x67\x03\x67\x03\x67\x05\x67\u{563}\x0a\x67\x03\x67\x03\x67\x05\x67\u{567}\
	\x0a\x67\x03\x67\x03\x67\x03\x68\x03\x68\x05\x68\u{56d}\x0a\x68\x03\x68\
	\x03\x68\x03\x69\x03\x69\x03\x69\x07\x69\u{574}\x0a\x69\x0c\x69\x0e\x69\
	\u{577}\x0b\x69\x03\x6a\x07\x6a\u{57a}\x0a\x6a\x0c\x6a\x0e\x6a\u{57d}\x0b\
	\x6a\x03\x6a\x03\x6a\x03\x6a\x03\x6a\x05\x6a\u{583}\x0a\x6a\x03\x6b\x07\
	\x6b\u{586}\x0a\x6b\x0c\x6b\x0e\x6b\u{589}\x0b\x6b\x03\x6b\x03\x6b\x07\x6b\
	\u{58d}\x0a\x6b\x0c\x6b\x0e\x6b\u{590}\x0b\x6b\x03\x6b\x03\x6b\x03\x6b\x03\
	\x6c\x03\x6c\x03\x6d\x03\x6d\x07\x6d\u{599}\x0a\x6d\x0c\x6d\x0e\x6d\u{59c}\
	\x0b\x6d\x03\x6d\x03\x6d\x03\x6e\x03\x6e\x05\x6e\u{5a2}\x0a\x6e\x03\x6f\
	\x07\x6f\u{5a5}\x0a\x6f\x0c\x6f\x0e\x6f\u{5a8}\x0b\x6f\x03\x6f\x03\x6f\x03\
	\x6f\x03\x70\x03\x70\x05\x70\u{5af}\x0a\x70\x03\x71\x07\x71\u{5b2}\x0a\x71\
	\x0c\x71\x0e\x71\u{5b5}\x0b\x71\x03\x71\x03\x71\x03\x71\x05\x71\u{5ba}\x0a\
	\x71\x03\x71\x05\x71\u{5bd}\x0a\x71\x03\x71\x05\x71\u{5c0}\x0a\x71\x03\x71\
	\x03\x71\x03\x72\x03\x72\x03\x72\x03\x72\x03\x72\x03\x72\x03\x72\x03\x72\
	\x03\x72\x05\x72\u{5cd}\x0a\x72\x03\x73\x03\x73\x03\x73\x03\x74\x03\x74\
	\x03\x74\x03\x74\x07\x74\u{5d6}\x0a\x74\x0c\x74\x0e\x74\u{5d9}\x0b\x74\x03\
	\x75\x03\x75\x07\x75\u{5dd}\x0a\x75\x0c\x75\x0e\x75\u{5e0}\x0b\x75\x03\x75\
	\x03\x75\x03\x76\x03\x76\x03\x76\x03\x76\x03\x76\x05\x76\u{5e9}\x0a\x76\
	\x03\x77\x07\x77\u{5ec}\x0a\x77\x0c\x77\x0e\x77\u{5ef}\x0b\x77\x03\x77\x03\
	\x77\x03\x77\x03\x77\x03\x78\x03\x78\x03\x78\x03\x78\x05\x78\u{5f9}\x0a\
	\x78\x03\x79\x07\x79\u{5fc}\x0a\x79\x0c\x79\x0e\x79\u{5ff}\x0b\x79\x03\x79\
	\x03\x79\x03\x79\x03\x7a\x03\x7a\x03\x7a\x03\x7a\x03\x7a\x03\x7a\x03\x7a\
	\x05\x7a\u{60b}\x0a\x7a\x03\x7b\x07\x7b\u{60e}\x0a\x7b\x0c\x7b\x0e\x7b\u{611}\
	\x0b\x7b\x03\x7b\x03\x7b\x03\x7b\x03\x7b\x03\x7b\x03\x7c\x03\x7c\x07\x7c\
	\u{61a}\x0a\x7c\x0c\x7c\x0e\x7c\u{61d}\x0b\x7c\x03\x7c\x03\x7c\x03\x7d\x03\
	\x7d\x03\x7d\x03\x7d\x03\x7d\x05\x7d\u{626}\x0a\x7d\x03\x7e\x07\x7e\u{629}\
	\x0a\x7e\x0c\x7e\x0e\x7e\u{62c}\x0b\x7e\x03\x7e\x03\x7e\x03\x7e\x03\x7e\
	\x03\x7e\x05\x7e\u{633}\x0a\x7e\x03\x7e\x05\x7e\u{636}\x0a\x7e\x03\x7e\x03\
	\x7e\x03\x7f\x03\x7f\x03\x7f\x05\x7f\u{63d}\x0a\x7f\x03\u{80}\x03\u{80}\
	\x03\u{80}\x03\u{81}\x03\u{81}\x03\u{81}\x05\u{81}\u{645}\x0a\u{81}\x03\
	\u{82}\x03\u{82}\x03\u{82}\x03\u{82}\x05\u{82}\u{64b}\x0a\u{82}\x03\u{82}\
	\x03\u{82}\x03\u{83}\x03\u{83}\x03\u{83}\x07\u{83}\u{652}\x0a\u{83}\x0c\
	\u{83}\x0e\u{83}\u{655}\x0b\u{83}\x03\u{84}\x03\u{84}\x03\u{84}\x03\u{84}\
	\x03\u{85}\x03\u{85}\x03\u{85}\x05\u{85}\u{65e}\x0a\u{85}\x03\u{86}\x03\
	\u{86}\x05\u{86}\u{662}\x0a\u{86}\x03\u{86}\x05\u{86}\u{665}\x0a\u{86}\x03\
	\u{86}\x03\u{86}\x03\u{87}\x03\u{87}\x03\u{87}\x07\u{87}\u{66c}\x0a\u{87}\
	\x0c\u{87}\x0e\u{87}\u{66f}\x0b\u{87}\x03\u{88}\x03\u{88}\x03\u{88}\x03\
	\u{89}\x03\u{89}\x03\u{89}\x03\u{89}\x03\u{89}\x03\u{89}\x03\u{8a}\x03\u{8a}\
	\x05\u{8a}\u{67c}\x0a\u{8a}\x03\u{8a}\x05\u{8a}\u{67f}\x0a\u{8a}\x03\u{8a}\
	\x03\u{8a}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x07\u{8b}\u{686}\x0a\u{8b}\x0c\
	\u{8b}\x0e\u{8b}\u{689}\x0b\u{8b}\x03\u{8c}\x03\u{8c}\x05\u{8c}\u{68d}\x0a\
	\u{8c}\x03\u{8c}\x03\u{8c}\x03\u{8d}\x03\u{8d}\x07\u{8d}\u{693}\x0a\u{8d}\
	\x0c\u{8d}\x0e\u{8d}\u{696}\x0b\u{8d}\x03\u{8e}\x03\u{8e}\x03\u{8e}\x05\
	\u{8e}\u{69b}\x0a\u{8e}\x03\u{8f}\x03\u{8f}\x05\u{8f}\u{69f}\x0a\u{8f}\x03\
	\u{90}\x07\u{90}\u{6a2}\x0a\u{90}\x0c\u{90}\x0e\u{90}\u{6a5}\x0b\u{90}\x03\
	\u{90}\x03\u{90}\x05\u{90}\u{6a9}\x0a\u{90}\x03\u{91}\x03\u{91}\x05\u{91}\
	\u{6ad}\x0a\u{91}\x03\u{92}\x03\u{92}\x03\u{92}\x03\u{93}\x03\u{93}\x03\
	\u{93}\x03\u{93}\x03\u{93}\x03\u{93}\x05\u{93}\u{6b8}\x0a\u{93}\x03\u{94}\
	\x03\u{94}\x03\u{94}\x03\u{94}\x03\u{94}\x05\u{94}\u{6bf}\x0a\u{94}\x03\
	\u{95}\x03\u{95}\x03\u{95}\x03\u{95}\x03\u{95}\x03\u{95}\x03\u{95}\x03\u{95}\
	\x03\u{95}\x03\u{95}\x03\u{95}\x03\u{95}\x03\u{95}\x05\u{95}\u{6ce}\x0a\
	\u{95}\x03\u{96}\x03\u{96}\x03\u{97}\x03\u{97}\x03\u{97}\x03\u{97}\x03\u{98}\
	\x03\u{98}\x03\u{98}\x03\u{98}\x03\u{99}\x03\u{99}\x03\u{99}\x03\u{9a}\x03\
	\u{9a}\x03\u{9a}\x03\u{9a}\x03\u{9a}\x03\u{9a}\x03\u{9a}\x05\u{9a}\u{6e4}\
	\x0a\u{9a}\x03\u{9b}\x03\u{9b}\x03\u{9b}\x03\u{9b}\x03\u{9b}\x03\u{9b}\x03\
	\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\
	\x03\u{9d}\x03\u{9d}\x03\u{9d}\x03\u{9d}\x03\u{9d}\x03\u{9d}\x03\u{9d}\x03\
	\u{9d}\x03\u{9e}\x03\u{9e}\x03\u{9e}\x03\u{9e}\x05\u{9e}\u{700}\x0a\u{9e}\
	\x03\u{9e}\x03\u{9e}\x03\u{9f}\x03\u{9f}\x03\u{9f}\x03\u{9f}\x03\u{9f}\x03\
	\u{9f}\x03\u{a0}\x03\u{a0}\x03\u{a0}\x07\u{a0}\u{70d}\x0a\u{a0}\x0c\u{a0}\
	\x0e\u{a0}\u{710}\x0b\u{a0}\x03\u{a0}\x03\u{a0}\x03\u{a0}\x03\u{a0}\x07\
	\u{a0}\u{716}\x0a\u{a0}\x0c\u{a0}\x0e\u{a0}\u{719}\x0b\u{a0}\x03\u{a0}\x03\
	\u{a0}\x03\u{a0}\x07\u{a0}\u{71e}\x0a\u{a0}\x0c\u{a0}\x0e\u{a0}\u{721}\x0b\
	\u{a0}\x03\u{a0}\x05\u{a0}\u{724}\x0a\u{a0}\x03\u{a1}\x03\u{a1}\x03\u{a1}\
	\x03\u{a1}\x03\u{a1}\x03\u{a1}\x03\u{a1}\x05\u{a1}\u{72d}\x0a\u{a1}\x03\
	\u{a2}\x03\u{a2}\x03\u{a2}\x03\u{a2}\x03\u{a2}\x07\u{a2}\u{734}\x0a\u{a2}\
	\x0c\u{a2}\x0e\u{a2}\u{737}\x0b\u{a2}\x03\u{a2}\x03\u{a2}\x03\u{a3}\x03\
	\u{a3}\x03\u{a3}\x03\u{a3}\x07\u{a3}\u{73f}\x0a\u{a3}\x0c\u{a3}\x0e\u{a3}\
	\u{742}\x0b\u{a3}\x03\u{a3}\x05\u{a3}\u{745}\x0a\u{a3}\x03\u{a4}\x03\u{a4}\
	\x03\u{a5}\x03\u{a5}\x03\u{a5}\x03\u{a5}\x03\u{a5}\x03\u{a5}\x03\u{a6}\x03\
	\u{a6}\x03\u{a6}\x03\u{a6}\x03\u{a6}\x03\u{a6}\x03\u{a7}\x03\u{a7}\x03\u{a7}\
	\x03\u{a7}\x03\u{a7}\x03\u{a7}\x03\u{a7}\x03\u{a7}\x03\u{a8}\x03\u{a8}\x05\
	\u{a8}\u{75f}\x0a\u{a8}\x03\u{a9}\x03\u{a9}\x05\u{a9}\u{763}\x0a\u{a9}\x03\
	\u{aa}\x03\u{aa}\x03\u{aa}\x05\u{aa}\u{768}\x0a\u{aa}\x03\u{aa}\x03\u{aa}\
	\x05\u{aa}\u{76c}\x0a\u{aa}\x03\u{aa}\x03\u{aa}\x05\u{aa}\u{770}\x0a\u{aa}\
	\x03\u{aa}\x03\u{aa}\x03\u{aa}\x03\u{ab}\x03\u{ab}\x03\u{ab}\x05\u{ab}\u{778}\
	\x0a\u{ab}\x03\u{ab}\x03\u{ab}\x05\u{ab}\u{77c}\x0a\u{ab}\x03\u{ab}\x03\
	\u{ab}\x05\u{ab}\u{780}\x0a\u{ab}\x03\u{ab}\x03\u{ab}\x03\u{ab}\x03\u{ac}\
	\x03\u{ac}\x05\u{ac}\u{787}\x0a\u{ac}\x03\u{ad}\x03\u{ad}\x03\u{ae}\x03\
	\u{ae}\x03\u{ae}\x07\u{ae}\u{78e}\x0a\u{ae}\x0c\u{ae}\x0e\u{ae}\u{791}\x0b\
	\u{ae}\x03\u{af}\x03\u{af}\x03\u{af}\x03\u{af}\x03\u{af}\x03\u{af}\x03\u{af}\
	\x03\u{af}\x03\u{b0}\x03\u{b0}\x03\u{b0}\x03\u{b0}\x03\u{b0}\x03\u{b0}\x03\
	\u{b0}\x03\u{b0}\x03\u{b1}\x03\u{b1}\x05\u{b1}\u{7a5}\x0a\u{b1}\x03\u{b1}\
	\x03\u{b1}\x03\u{b2}\x03\u{b2}\x05\u{b2}\u{7ab}\x0a\u{b2}\x03\u{b2}\x03\
	\u{b2}\x03\u{b3}\x03\u{b3}\x05\u{b3}\u{7b1}\x0a\u{b3}\x03\u{b3}\x03\u{b3}\
	\x03\u{b4}\x03\u{b4}\x03\u{b4}\x03\u{b4}\x03\u{b5}\x03\u{b5}\x03\u{b5}\x03\
	\u{b5}\x03\u{b5}\x03\u{b5}\x03\u{b6}\x03\u{b6}\x03\u{b6}\x03\u{b6}\x03\u{b6}\
	\x03\u{b6}\x03\u{b6}\x03\u{b6}\x03\u{b6}\x03\u{b6}\x03\u{b6}\x05\u{b6}\u{7ca}\
	\x0a\u{b6}\x03\u{b6}\x03\u{b6}\x03\u{b6}\x05\u{b6}\u{7cf}\x0a\u{b6}\x03\
	\u{b7}\x03\u{b7}\x07\u{b7}\u{7d3}\x0a\u{b7}\x0c\u{b7}\x0e\u{b7}\u{7d6}\x0b\
	\u{b7}\x03\u{b8}\x03\u{b8}\x03\u{b8}\x03\u{b8}\x03\u{b8}\x03\u{b8}\x03\u{b9}\
	\x07\u{b9}\u{7df}\x0a\u{b9}\x0c\u{b9}\x0e\u{b9}\u{7e2}\x0b\u{b9}\x03\u{b9}\
	\x03\u{b9}\x03\u{b9}\x03\u{ba}\x03\u{ba}\x03\u{ba}\x07\u{ba}\u{7ea}\x0a\
	\u{ba}\x0c\u{ba}\x0e\u{ba}\u{7ed}\x0b\u{ba}\x03\u{bb}\x03\u{bb}\x03\u{bb}\
	\x03\u{bc}\x03\u{bc}\x03\u{bc}\x03\u{bc}\x05\u{bc}\u{7f6}\x0a\u{bc}\x03\
	\u{bc}\x05\u{bc}\u{7f9}\x0a\u{bc}\x03\u{bd}\x03\u{bd}\x03\u{bd}\x05\u{bd}\
	\u{7fe}\x0a\u{bd}\x03\u{bd}\x03\u{bd}\x03\u{be}\x03\u{be}\x03\u{be}\x07\
	\u{be}\u{805}\x0a\u{be}\x0c\u{be}\x0e\u{be}\u{808}\x0b\u{be}\x03\u{bf}\x03\
	\u{bf}\x05\u{bf}\u{80c}\x0a\u{bf}\x03\u{c0}\x03\u{c0}\x05\u{c0}\u{810}\x0a\
	\u{c0}\x03\u{c1}\x03\u{c1}\x03\u{c1}\x03\u{c1}\x03\u{c2}\x03\u{c2}\x03\u{c3}\
	\x03\u{c3}\x03\u{c4}\x03\u{c4}\x05\u{c4}\u{81c}\x0a\u{c4}\x03\u{c5}\x03\
	\u{c5}\x05\u{c5}\u{820}\x0a\u{c5}\x03\u{c6}\x03\u{c6}\x05\u{c6}\u{824}\x0a\
	\u{c6}\x03\u{c6}\x03\u{c6}\x05\u{c6}\u{828}\x0a\u{c6}\x03\u{c6}\x03\u{c6}\
	\x05\u{c6}\u{82c}\x0a\u{c6}\x03\u{c6}\x03\u{c6}\x03\u{c6}\x03\u{c6}\x05\
	\u{c6}\u{832}\x0a\u{c6}\x03\u{c6}\x03\u{c6}\x03\u{c6}\x03\u{c6}\x05\u{c6}\
	\u{838}\x0a\u{c6}\x03\u{c6}\x03\u{c6}\x05\u{c6}\u{83c}\x0a\u{c6}\x03\u{c6}\
	\x03\u{c6}\x03\u{c6}\x03\u{c6}\x05\u{c6}\u{842}\x0a\u{c6}\x03\u{c6}\x03\
	\u{c6}\x03\u{c6}\x03\u{c6}\x05\u{c6}\u{848}\x0a\u{c6}\x03\u{c6}\x03\u{c6}\
	\x03\u{c6}\x03\u{c6}\x05\u{c6}\u{84e}\x0a\u{c6}\x03\u{c6}\x03\u{c6}\x03\
	\u{c6}\x03\u{c6}\x05\u{c6}\u{854}\x0a\u{c6}\x03\u{c6}\x03\u{c6}\x03\u{c6}\
	\x03\u{c6}\x03\u{c6}\x03\u{c6}\x05\u{c6}\u{85c}\x0a\u{c6}\x03\u{c6}\x03\
	\u{c6}\x03\u{c6}\x03\u{c6}\x03\u{c6}\x05\u{c6}\u{863}\x0a\u{c6}\x03\u{c6}\
	\x03\u{c6}\x03\u{c6}\x03\u{c6}\x03\u{c6}\x05\u{c6}\u{86a}\x0a\u{c6}\x03\
	\u{c6}\x03\u{c6}\x03\u{c6}\x05\u{c6}\u{86f}\x0a\u{c6}\x03\u{c6}\x03\u{c6}\
	\x05\u{c6}\u{873}\x0a\u{c6}\x03\u{c6}\x03\u{c6}\x03\u{c6}\x05\u{c6}\u{878}\
	\x0a\u{c6}\x03\u{c6}\x03\u{c6}\x03\u{c6}\x05\u{c6}\u{87d}\x0a\u{c6}\x03\
	\u{c6}\x03\u{c6}\x05\u{c6}\u{881}\x0a\u{c6}\x03\u{c6}\x03\u{c6}\x03\u{c6}\
	\x05\u{c6}\u{886}\x0a\u{c6}\x03\u{c6}\x03\u{c6}\x03\u{c6}\x05\u{c6}\u{88b}\
	\x0a\u{c6}\x03\u{c6}\x03\u{c6}\x05\u{c6}\u{88f}\x0a\u{c6}\x03\u{c6}\x03\
	\u{c6}\x03\u{c6}\x05\u{c6}\u{894}\x0a\u{c6}\x03\u{c6}\x03\u{c6}\x03\u{c6}\
	\x05\u{c6}\u{899}\x0a\u{c6}\x03\u{c6}\x03\u{c6}\x05\u{c6}\u{89d}\x0a\u{c6}\
	\x03\u{c6}\x03\u{c6}\x03\u{c6}\x05\u{c6}\u{8a2}\x0a\u{c6}\x03\u{c6}\x03\
	\u{c6}\x03\u{c6}\x05\u{c6}\u{8a7}\x0a\u{c6}\x03\u{c6}\x03\u{c6}\x05\u{c6}\
	\u{8ab}\x0a\u{c6}\x03\u{c6}\x03\u{c6}\x03\u{c6}\x03\u{c6}\x03\u{c6}\x05\
	\u{c6}\u{8b2}\x0a\u{c6}\x03\u{c6}\x03\u{c6}\x03\u{c6}\x05\u{c6}\u{8b7}\x0a\
	\u{c6}\x03\u{c6}\x03\u{c6}\x05\u{c6}\u{8bb}\x0a\u{c6}\x03\u{c6}\x03\u{c6}\
	\x03\u{c6}\x05\u{c6}\u{8c0}\x0a\u{c6}\x03\u{c6}\x03\u{c6}\x05\u{c6}\u{8c4}\
	\x0a\u{c6}\x03\u{c6}\x03\u{c6}\x03\u{c6}\x05\u{c6}\u{8c9}\x0a\u{c6}\x03\
	\u{c6}\x03\u{c6}\x05\u{c6}\u{8cd}\x0a\u{c6}\x03\u{c6}\x03\u{c6}\x03\u{c6}\
	\x05\u{c6}\u{8d2}\x0a\u{c6}\x03\u{c6}\x03\u{c6}\x05\u{c6}\u{8d6}\x0a\u{c6}\
	\x03\u{c6}\x03\u{c6}\x03\u{c6}\x05\u{c6}\u{8db}\x0a\u{c6}\x03\u{c6}\x03\
	\u{c6}\x05\u{c6}\u{8df}\x0a\u{c6}\x03\u{c6}\x03\u{c6}\x03\u{c6}\x03\u{c6}\
	\x03\u{c6}\x05\u{c6}\u{8e6}\x0a\u{c6}\x03\u{c6}\x03\u{c6}\x05\u{c6}\u{8ea}\
	\x0a\u{c6}\x03\u{c6}\x03\u{c6}\x03\u{c6}\x05\u{c6}\u{8ef}\x0a\u{c6}\x03\
	\u{c6}\x03\u{c6}\x05\u{c6}\u{8f3}\x0a\u{c6}\x03\u{c6}\x03\u{c6}\x03\u{c6}\
	\x03\u{c6}\x05\u{c6}\u{8f9}\x0a\u{c6}\x05\u{c6}\u{8fb}\x0a\u{c6}\x03\u{c7}\
	\x03\u{c7}\x03\u{c7}\x05\u{c7}\u{900}\x0a\u{c7}\x03\u{c7}\x03\u{c7}\x03\
	\u{c7}\x05\u{c7}\u{905}\x0a\u{c7}\x03\u{c7}\x03\u{c7}\x03\u{c7}\x03\u{c7}\
	\x05\u{c7}\u{90b}\x0a\u{c7}\x03\u{c7}\x03\u{c7}\x05\u{c7}\u{90f}\x0a\u{c7}\
	\x03\u{c7}\x03\u{c7}\x03\u{c7}\x05\u{c7}\u{914}\x0a\u{c7}\x03\u{c7}\x03\
	\u{c7}\x05\u{c7}\u{918}\x0a\u{c7}\x03\u{c7}\x03\u{c7}\x05\u{c7}\u{91c}\x0a\
	\u{c7}\x03\u{c7}\x03\u{c7}\x05\u{c7}\u{920}\x0a\u{c7}\x05\u{c7}\u{922}\x0a\
	\u{c7}\x03\u{c8}\x03\u{c8}\x03\u{c8}\x07\u{c8}\u{927}\x0a\u{c8}\x0c\u{c8}\
	\x0e\u{c8}\u{92a}\x0b\u{c8}\x03\u{c8}\x03\u{c8}\x03\u{c8}\x03\u{c8}\x03\
	\u{c8}\x03\u{c8}\x07\u{c8}\u{932}\x0a\u{c8}\x0c\u{c8}\x0e\u{c8}\u{935}\x0b\
	\u{c8}\x03\u{c8}\x03\u{c8}\x03\u{c8}\x03\u{c8}\x03\u{c8}\x03\u{c8}\x07\u{c8}\
	\u{93d}\x0a\u{c8}\x0c\u{c8}\x0e\u{c8}\u{940}\x0b\u{c8}\x03\u{c8}\x03\u{c8}\
	\x03\u{c8}\x03\u{c8}\x03\u{c8}\x05\u{c8}\u{947}\x0a\u{c8}\x03\u{c9}\x03\
	\u{c9}\x03\u{c9}\x03\u{c9}\x03\u{c9}\x03\u{c9}\x03\u{c9}\x03\u{c9}\x03\u{c9}\
	\x05\u{c9}\u{952}\x0a\u{c9}\x03\u{ca}\x03\u{ca}\x05\u{ca}\u{956}\x0a\u{ca}\
	\x03\u{ca}\x03\u{ca}\x03\u{ca}\x05\u{ca}\u{95b}\x0a\u{ca}\x03\u{ca}\x03\
	\u{ca}\x05\u{ca}\u{95f}\x0a\u{ca}\x03\u{cb}\x07\u{cb}\u{962}\x0a\u{cb}\x0c\
	\u{cb}\x0e\u{cb}\u{965}\x0b\u{cb}\x03\u{cb}\x03\u{cb}\x03\u{cb}\x07\u{cb}\
	\u{96a}\x0a\u{cb}\x0c\u{cb}\x0e\u{cb}\u{96d}\x0b\u{cb}\x03\u{cb}\x07\u{cb}\
	\u{970}\x0a\u{cb}\x0c\u{cb}\x0e\u{cb}\u{973}\x0b\u{cb}\x03\u{cb}\x05\u{cb}\
	\u{976}\x0a\u{cb}\x03\u{cc}\x03\u{cc}\x05\u{cc}\u{97a}\x0a\u{cc}\x03\u{cd}\
	\x03\u{cd}\x05\u{cd}\u{97e}\x0a\u{cd}\x03\u{ce}\x03\u{ce}\x03\u{ce}\x03\
	\u{ce}\x05\u{ce}\u{984}\x0a\u{ce}\x03\u{ce}\x03\u{ce}\x03\u{ce}\x03\u{ce}\
	\x05\u{ce}\u{98a}\x0a\u{ce}\x05\u{ce}\u{98c}\x0a\u{ce}\x03\u{cf}\x03\u{cf}\
	\x03\u{cf}\x03\u{cf}\x03\u{cf}\x03\u{cf}\x03\u{cf}\x03\u{cf}\x03\u{cf}\x03\
	\u{cf}\x05\u{cf}\u{998}\x0a\u{cf}\x03\u{d0}\x03\u{d0}\x07\u{d0}\u{99c}\x0a\
	\u{d0}\x0c\u{d0}\x0e\u{d0}\u{99f}\x0b\u{d0}\x03\u{d1}\x07\u{d1}\u{9a2}\x0a\
	\u{d1}\x0c\u{d1}\x0e\u{d1}\u{9a5}\x0b\u{d1}\x03\u{d1}\x03\u{d1}\x03\u{d1}\
	\x03\u{d1}\x03\u{d2}\x03\u{d2}\x03\u{d2}\x03\u{d2}\x03\u{d2}\x03\u{d2}\x03\
	\u{d2}\x03\u{d2}\x03\u{d2}\x03\u{d2}\x03\u{d2}\x03\u{d2}\x03\u{d2}\x03\u{d2}\
	\x03\u{d2}\x05\u{d2}\u{9ba}\x0a\u{d2}\x03\u{d3}\x03\u{d3}\x03\u{d3}\x03\
	\u{d3}\x03\u{d3}\x03\u{d3}\x03\u{d3}\x03\u{d3}\x03\u{d3}\x03\u{d3}\x03\u{d3}\
	\x03\u{d3}\x03\u{d3}\x05\u{d3}\u{9c9}\x0a\u{d3}\x03\u{d4}\x03\u{d4}\x03\
	\u{d4}\x05\u{d4}\u{9ce}\x0a\u{d4}\x03\u{d4}\x03\u{d4}\x03\u{d4}\x03\u{d4}\
	\x03\u{d4}\x05\u{d4}\u{9d5}\x0a\u{d4}\x03\u{d4}\x03\u{d4}\x03\u{d4}\x05\
	\u{d4}\u{9da}\x0a\u{d4}\x03\u{d4}\x03\u{d4}\x03\u{d4}\x03\u{d4}\x03\u{d4}\
	\x05\u{d4}\u{9e1}\x0a\u{d4}\x03\u{d4}\x03\u{d4}\x03\u{d4}\x05\u{d4}\u{9e6}\
	\x0a\u{d4}\x03\u{d4}\x03\u{d4}\x03\u{d4}\x03\u{d4}\x03\u{d4}\x05\u{d4}\u{9ed}\
	\x0a\u{d4}\x03\u{d4}\x03\u{d4}\x03\u{d4}\x05\u{d4}\u{9f2}\x0a\u{d4}\x03\
	\u{d4}\x03\u{d4}\x03\u{d4}\x03\u{d4}\x03\u{d4}\x05\u{d4}\u{9f9}\x0a\u{d4}\
	\x03\u{d4}\x03\u{d4}\x03\u{d4}\x05\u{d4}\u{9fe}\x0a\u{d4}\x03\u{d4}\x03\
	\u{d4}\x03\u{d4}\x03\u{d4}\x03\u{d4}\x03\u{d4}\x05\u{d4}\u{a06}\x0a\u{d4}\
	\x03\u{d4}\x03\u{d4}\x03\u{d4}\x05\u{d4}\u{a0b}\x0a\u{d4}\x03\u{d4}\x03\
	\u{d4}\x05\u{d4}\u{a0f}\x0a\u{d4}\x03\u{d5}\x03\u{d5}\x03\u{d5}\x07\u{d5}\
	\u{a14}\x0a\u{d5}\x0c\u{d5}\x0e\u{d5}\u{a17}\x0b\u{d5}\x03\u{d6}\x03\u{d6}\
	\x03\u{d6}\x05\u{d6}\u{a1c}\x0a\u{d6}\x03\u{d6}\x03\u{d6}\x03\u{d6}\x03\
	\u{d6}\x03\u{d6}\x05\u{d6}\u{a23}\x0a\u{d6}\x03\u{d6}\x03\u{d6}\x03\u{d6}\
	\x03\u{d6}\x03\u{d6}\x05\u{d6}\u{a2a}\x0a\u{d6}\x03\u{d6}\x03\u{d6}\x03\
	\u{d6}\x03\u{d6}\x03\u{d6}\x05\u{d6}\u{a31}\x0a\u{d6}\x03\u{d6}\x03\u{d6}\
	\x03\u{d6}\x03\u{d6}\x03\u{d6}\x03\u{d6}\x05\u{d6}\u{a39}\x0a\u{d6}\x03\
	\u{d6}\x03\u{d6}\x03\u{d6}\x03\u{d6}\x03\u{d6}\x05\u{d6}\u{a40}\x0a\u{d6}\
	\x03\u{d6}\x03\u{d6}\x03\u{d6}\x03\u{d6}\x03\u{d6}\x03\u{d6}\x05\u{d6}\u{a48}\
	\x0a\u{d6}\x03\u{d7}\x03\u{d7}\x05\u{d7}\u{a4c}\x0a\u{d7}\x03\u{d7}\x03\
	\u{d7}\x05\u{d7}\u{a50}\x0a\u{d7}\x05\u{d7}\u{a52}\x0a\u{d7}\x03\u{d8}\x03\
	\u{d8}\x05\u{d8}\u{a56}\x0a\u{d8}\x03\u{d8}\x03\u{d8}\x05\u{d8}\u{a5a}\x0a\
	\u{d8}\x05\u{d8}\u{a5c}\x0a\u{d8}\x03\u{d9}\x03\u{d9}\x03\u{d9}\x03\u{da}\
	\x03\u{da}\x03\u{da}\x03\u{db}\x03\u{db}\x03\u{db}\x03\u{db}\x03\u{db}\x03\
	\u{db}\x03\u{db}\x05\u{db}\u{a6b}\x0a\u{db}\x03\u{dc}\x03\u{dc}\x03\u{dc}\
	\x03\u{dd}\x03\u{dd}\x03\u{dd}\x03\u{de}\x03\u{de}\x03\u{de}\x03\u{de}\x03\
	\u{de}\x03\u{de}\x03\u{de}\x05\u{de}\u{a7a}\x0a\u{de}\x03\u{df}\x03\u{df}\
	\x03\u{df}\x03\u{df}\x03\u{df}\x03\u{df}\x03\u{df}\x03\u{df}\x07\u{df}\u{a84}\
	\x0a\u{df}\x0c\u{df}\x0e\u{df}\u{a87}\x0b\u{df}\x03\u{df}\x03\u{df}\x03\
	\u{df}\x03\u{df}\x03\u{df}\x03\u{df}\x07\u{df}\u{a8f}\x0a\u{df}\x0c\u{df}\
	\x0e\u{df}\u{a92}\x0b\u{df}\x03\u{df}\x03\u{df}\x03\u{df}\x05\u{df}\u{a97}\
	\x0a\u{df}\x03\u{e0}\x03\u{e0}\x03\u{e0}\x03\u{e0}\x03\u{e0}\x03\u{e0}\x03\
	\u{e0}\x03\u{e0}\x03\u{e0}\x03\u{e0}\x03\u{e0}\x03\u{e0}\x07\u{e0}\u{aa5}\
	\x0a\u{e0}\x0c\u{e0}\x0e\u{e0}\u{aa8}\x0b\u{e0}\x03\u{e1}\x03\u{e1}\x03\
	\u{e1}\x03\u{e1}\x03\u{e1}\x03\u{e1}\x03\u{e1}\x03\u{e1}\x03\u{e1}\x07\u{e1}\
	\u{ab3}\x0a\u{e1}\x0c\u{e1}\x0e\u{e1}\u{ab6}\x0b\u{e1}\x03\u{e2}\x03\u{e2}\
	\x03\u{e2}\x03\u{e2}\x03\u{e2}\x03\u{e2}\x03\u{e2}\x03\u{e2}\x03\u{e2}\x03\
	\u{e2}\x03\u{e2}\x03\u{e2}\x03\u{e2}\x03\u{e2}\x03\u{e2}\x03\u{e2}\x07\u{e2}\
	\u{ac8}\x0a\u{e2}\x0c\u{e2}\x0e\u{e2}\u{acb}\x0b\u{e2}\x03\u{e3}\x03\u{e3}\
	\x03\u{e3}\x03\u{e3}\x03\u{e3}\x03\u{e3}\x03\u{e3}\x03\u{e3}\x03\u{e3}\x03\
	\u{e3}\x03\u{e3}\x03\u{e3}\x03\u{e3}\x03\u{e3}\x03\u{e3}\x03\u{e3}\x03\u{e3}\
	\x03\u{e3}\x03\u{e3}\x05\u{e3}\u{ae0}\x0a\u{e3}\x07\u{e3}\u{ae2}\x0a\u{e3}\
	\x0c\u{e3}\x0e\u{e3}\u{ae5}\x0b\u{e3}\x03\u{e4}\x03\u{e4}\x03\u{e4}\x03\
	\u{e4}\x03\u{e4}\x03\u{e4}\x03\u{e4}\x03\u{e4}\x03\u{e4}\x07\u{e4}\u{af0}\
	\x0a\u{e4}\x0c\u{e4}\x0e\u{e4}\u{af3}\x0b\u{e4}\x03\u{e5}\x03\u{e5}\x03\
	\u{e5}\x03\u{e5}\x03\u{e5}\x03\u{e5}\x07\u{e5}\u{afb}\x0a\u{e5}\x0c\u{e5}\
	\x0e\u{e5}\u{afe}\x0b\u{e5}\x03\u{e6}\x03\u{e6}\x03\u{e6}\x03\u{e6}\x03\
	\u{e6}\x03\u{e6}\x07\u{e6}\u{b06}\x0a\u{e6}\x0c\u{e6}\x0e\u{e6}\u{b09}\x0b\
	\u{e6}\x03\u{e7}\x03\u{e7}\x03\u{e7}\x03\u{e7}\x03\u{e7}\x03\u{e7}\x07\u{e7}\
	\u{b11}\x0a\u{e7}\x0c\u{e7}\x0e\u{e7}\u{b14}\x0b\u{e7}\x03\u{e8}\x03\u{e8}\
	\x03\u{e8}\x03\u{e8}\x03\u{e8}\x03\u{e8}\x07\u{e8}\u{b1c}\x0a\u{e8}\x0c\
	\u{e8}\x0e\u{e8}\u{b1f}\x0b\u{e8}\x03\u{e9}\x03\u{e9}\x03\u{e9}\x03\u{e9}\
	\x03\u{e9}\x03\u{e9}\x07\u{e9}\u{b27}\x0a\u{e9}\x0c\u{e9}\x0e\u{e9}\u{b2a}\
	\x0b\u{e9}\x03\u{ea}\x03\u{ea}\x03\u{ea}\x03\u{ea}\x03\u{ea}\x03\u{ea}\x03\
	\u{ea}\x03\u{ea}\x03\u{ea}\x03\u{ea}\x03\u{ea}\x03\u{ea}\x03\u{ea}\x05\u{ea}\
	\u{b39}\x0a\u{ea}\x03\u{eb}\x03\u{eb}\x05\u{eb}\u{b3d}\x0a\u{eb}\x03\u{ec}\
	\x03\u{ec}\x03\u{ec}\x03\u{ec}\x03\u{ed}\x03\u{ed}\x03\u{ed}\x05\u{ed}\u{b46}\
	\x0a\u{ed}\x03\u{ee}\x03\u{ee}\x03\u{ef}\x03\u{ef}\x03\u{ef}\x03\u{ef}\x03\
	\u{f0}\x03\u{f0}\x05\u{f0}\u{b50}\x0a\u{f0}\x03\u{f0}\x03\u{f0}\x05\u{f0}\
	\u{b54}\x0a\u{f0}\x03\u{f1}\x03\u{f1}\x03\u{f1}\x07\u{f1}\u{b59}\x0a\u{f1}\
	\x0c\u{f1}\x0e\u{f1}\u{b5c}\x0b\u{f1}\x03\u{f1}\x03\u{f1}\x03\u{f1}\x07\
	\u{f1}\u{b61}\x0a\u{f1}\x0c\u{f1}\x0e\u{f1}\u{b64}\x0b\u{f1}\x05\u{f1}\u{b66}\
	\x0a\u{f1}\x03\u{f2}\x07\u{f2}\u{b69}\x0a\u{f2}\x0c\u{f2}\x0e\u{f2}\u{b6c}\
	\x0b\u{f2}\x03\u{f2}\x03\u{f2}\x03\u{f2}\x03\u{f2}\x05\u{f2}\u{b72}\x0a\
	\u{f2}\x03\u{f3}\x03\u{f3}\x05\u{f3}\u{b76}\x0a\u{f3}\x03\u{f4}\x03\u{f4}\
	\x05\u{f4}\u{b7a}\x0a\u{f4}\x03\u{f5}\x03\u{f5}\x03\u{f5}\x03\u{f5}\x03\
	\u{f5}\x03\u{f5}\x03\u{f6}\x03\u{f6}\x03\u{f6}\x02\x0c\u{1be}\u{1c0}\u{1c2}\
	\u{1c4}\u{1c6}\u{1c8}\u{1ca}\u{1cc}\u{1ce}\u{1d0}\u{f7}\x02\x04\x06\x08\
	\x0a\x0c\x0e\x10\x12\x14\x16\x18\x1a\x1c\x1e\x20\x22\x24\x26\x28\x2a\x2c\
	\x2e\x30\x32\x34\x36\x38\x3a\x3c\x3e\x40\x42\x44\x46\x48\x4a\x4c\x4e\x50\
	\x52\x54\x56\x58\x5a\x5c\x5e\x60\x62\x64\x66\x68\x6a\x6c\x6e\x70\x72\x74\
	\x76\x78\x7a\x7c\x7e\u{80}\u{82}\u{84}\u{86}\u{88}\u{8a}\u{8c}\u{8e}\u{90}\
	\u{92}\u{94}\u{96}\u{98}\u{9a}\u{9c}\u{9e}\u{a0}\u{a2}\u{a4}\u{a6}\u{a8}\
	\u{aa}\u{ac}\u{ae}\u{b0}\u{b2}\u{b4}\u{b6}\u{b8}\u{ba}\u{bc}\u{be}\u{c0}\
	\u{c2}\u{c4}\u{c6}\u{c8}\u{ca}\u{cc}\u{ce}\u{d0}\u{d2}\u{d4}\u{d6}\u{d8}\
	\u{da}\u{dc}\u{de}\u{e0}\u{e2}\u{e4}\u{e6}\u{e8}\u{ea}\u{ec}\u{ee}\u{f0}\
	\u{f2}\u{f4}\u{f6}\u{f8}\u{fa}\u{fc}\u{fe}\u{100}\u{102}\u{104}\u{106}\u{108}\
	\u{10a}\u{10c}\u{10e}\u{110}\u{112}\u{114}\u{116}\u{118}\u{11a}\u{11c}\u{11e}\
	\u{120}\u{122}\u{124}\u{126}\u{128}\u{12a}\u{12c}\u{12e}\u{130}\u{132}\u{134}\
	\u{136}\u{138}\u{13a}\u{13c}\u{13e}\u{140}\u{142}\u{144}\u{146}\u{148}\u{14a}\
	\u{14c}\u{14e}\u{150}\u{152}\u{154}\u{156}\u{158}\u{15a}\u{15c}\u{15e}\u{160}\
	\u{162}\u{164}\u{166}\u{168}\u{16a}\u{16c}\u{16e}\u{170}\u{172}\u{174}\u{176}\
	\u{178}\u{17a}\u{17c}\u{17e}\u{180}\u{182}\u{184}\u{186}\u{188}\u{18a}\u{18c}\
	\u{18e}\u{190}\u{192}\u{194}\u{196}\u{198}\u{19a}\u{19c}\u{19e}\u{1a0}\u{1a2}\
	\u{1a4}\u{1a6}\u{1a8}\u{1aa}\u{1ac}\u{1ae}\u{1b0}\u{1b2}\u{1b4}\u{1b6}\u{1b8}\
	\u{1ba}\u{1bc}\u{1be}\u{1c0}\u{1c2}\u{1c4}\u{1c6}\u{1c8}\u{1ca}\u{1cc}\u{1ce}\
	\u{1d0}\u{1d2}\u{1d4}\u{1d6}\u{1d8}\u{1da}\u{1dc}\u{1de}\u{1e0}\u{1e2}\u{1e4}\
	\u{1e6}\u{1e8}\u{1ea}\x02\x08\x03\x02\x47\x4d\x07\x02\x18\x18\x1b\x1b\x2e\
	\x2e\x30\x30\x38\x38\x04\x02\x21\x21\x27\x27\x04\x02\x0f\x0f\x39\x39\x04\
	\x02\x3b\x3b\x3e\x3e\x04\x02\x5a\x5a\x72\x7c\x02\u{c88}\x02\u{1ec}\x03\x02\
	\x02\x02\x04\u{1ef}\x03\x02\x02\x02\x06\u{1f1}\x03\x02\x02\x02\x08\u{1f3}\
	\x03\x02\x02\x02\x0a\u{1f8}\x03\x02\x02\x02\x0c\u{201}\x03\x02\x02\x02\x0e\
	\u{203}\x03\x02\x02\x02\x10\u{205}\x03\x02\x02\x02\x12\u{20a}\x03\x02\x02\
	\x02\x14\u{20c}\x03\x02\x02\x02\x16\u{21d}\x03\x02\x02\x02\x18\u{24e}\x03\
	\x02\x02\x02\x1a\u{250}\x03\x02\x02\x02\x1c\u{255}\x03\x02\x02\x02\x1e\u{263}\
	\x03\x02\x02\x02\x20\u{268}\x03\x02\x02\x02\x22\u{27d}\x03\x02\x02\x02\x24\
	\u{284}\x03\x02\x02\x02\x26\u{286}\x03\x02\x02\x02\x28\u{291}\x03\x02\x02\
	\x02\x2a\u{294}\x03\x02\x02\x02\x2c\u{298}\x03\x02\x02\x02\x2e\u{2a2}\x03\
	\x02\x02\x02\x30\u{2a7}\x03\x02\x02\x02\x32\u{2b2}\x03\x02\x02\x02\x34\u{2b4}\
	\x03\x02\x02\x02\x36\u{2b9}\x03\x02\x02\x02\x38\u{2be}\x03\x02\x02\x02\x3a\
	\u{2c3}\x03\x02\x02\x02\x3c\u{2cb}\x03\x02\x02\x02\x3e\u{2cf}\x03\x02\x02\
	\x02\x40\u{2d1}\x03\x02\x02\x02\x42\u{2d8}\x03\x02\x02\x02\x44\u{2db}\x03\
	\x02\x02\x02\x46\u{2ec}\x03\x02\x02\x02\x48\u{2f4}\x03\x02\x02\x02\x4a\u{302}\
	\x03\x02\x02\x02\x4c\u{308}\x03\x02\x02\x02\x4e\u{30a}\x03\x02\x02\x02\x50\
	\u{30e}\x03\x02\x02\x02\x52\u{314}\x03\x02\x02\x02\x54\u{31b}\x03\x02\x02\
	\x02\x56\u{325}\x03\x02\x02\x02\x58\u{32a}\x03\x02\x02\x02\x5a\u{37b}\x03\
	\x02\x02\x02\x5c\u{37d}\x03\x02\x02\x02\x5e\u{382}\x03\x02\x02\x02\x60\u{387}\
	\x03\x02\x02\x02\x62\u{3a4}\x03\x02\x02\x02\x64\u{3a6}\x03\x02\x02\x02\x66\
	\u{3aa}\x03\x02\x02\x02\x68\u{3b2}\x03\x02\x02\x02\x6a\u{3b5}\x03\x02\x02\
	\x02\x6c\u{3b8}\x03\x02\x02\x02\x6e\u{3c0}\x03\x02\x02\x02\x70\u{3c9}\x03\
	\x02\x02\x02\x72\u{3d6}\x03\x02\x02\x02\x74\u{3dd}\x03\x02\x02\x02\x76\u{3e2}\
	\x03\x02\x02\x02\x78\u{3f1}\x03\x02\x02\x02\x7a\u{3f3}\x03\x02\x02\x02\x7c\
	\u{3fb}\x03\x02\x02\x02\x7e\u{400}\x03\x02\x02\x02\u{80}\u{406}\x03\x02\
	\x02\x02\u{82}\u{40a}\x03\x02\x02\x02\u{84}\u{40e}\x03\x02\x02\x02\u{86}\
	\u{413}\x03\x02\x02\x02\u{88}\u{41d}\x03\x02\x02\x02\u{8a}\u{426}\x03\x02\
	\x02\x02\u{8c}\u{447}\x03\x02\x02\x02\u{8e}\u{449}\x03\x02\x02\x02\u{90}\
	\u{44b}\x03\x02\x02\x02\u{92}\u{450}\x03\x02\x02\x02\u{94}\u{457}\x03\x02\
	\x02\x02\u{96}\u{467}\x03\x02\x02\x02\u{98}\u{470}\x03\x02\x02\x02\u{9a}\
	\u{479}\x03\x02\x02\x02\u{9c}\u{47b}\x03\x02\x02\x02\u{9e}\u{48c}\x03\x02\
	\x02\x02\u{a0}\u{496}\x03\x02\x02\x02\u{a2}\u{4a8}\x03\x02\x02\x02\u{a4}\
	\u{4ad}\x03\x02\x02\x02\u{a6}\u{4bc}\x03\x02\x02\x02\u{a8}\u{4be}\x03\x02\
	\x02\x02\u{aa}\u{4c1}\x03\x02\x02\x02\u{ac}\u{4cb}\x03\x02\x02\x02\u{ae}\
	\u{4cf}\x03\x02\x02\x02\u{b0}\u{4d1}\x03\x02\x02\x02\u{b2}\u{4d3}\x03\x02\
	\x02\x02\u{b4}\u{4d9}\x03\x02\x02\x02\u{b6}\u{4e6}\x03\x02\x02\x02\u{b8}\
	\u{4e9}\x03\x02\x02\x02\u{ba}\u{4f7}\x03\x02\x02\x02\u{bc}\u{4f9}\x03\x02\
	\x02\x02\u{be}\u{51c}\x03\x02\x02\x02\u{c0}\u{521}\x03\x02\x02\x02\u{c2}\
	\u{52b}\x03\x02\x02\x02\u{c4}\u{537}\x03\x02\x02\x02\u{c6}\u{542}\x03\x02\
	\x02\x02\u{c8}\u{550}\x03\x02\x02\x02\u{ca}\u{552}\x03\x02\x02\x02\u{cc}\
	\u{55c}\x03\x02\x02\x02\u{ce}\u{56a}\x03\x02\x02\x02\u{d0}\u{570}\x03\x02\
	\x02\x02\u{d2}\u{582}\x03\x02\x02\x02\u{d4}\u{587}\x03\x02\x02\x02\u{d6}\
	\u{594}\x03\x02\x02\x02\u{d8}\u{596}\x03\x02\x02\x02\u{da}\u{5a1}\x03\x02\
	\x02\x02\u{dc}\u{5a6}\x03\x02\x02\x02\u{de}\u{5ae}\x03\x02\x02\x02\u{e0}\
	\u{5b3}\x03\x02\x02\x02\u{e2}\u{5cc}\x03\x02\x02\x02\u{e4}\u{5ce}\x03\x02\
	\x02\x02\u{e6}\u{5d1}\x03\x02\x02\x02\u{e8}\u{5da}\x03\x02\x02\x02\u{ea}\
	\u{5e8}\x03\x02\x02\x02\u{ec}\u{5ed}\x03\x02\x02\x02\u{ee}\u{5f8}\x03\x02\
	\x02\x02\u{f0}\u{5fd}\x03\x02\x02\x02\u{f2}\u{60a}\x03\x02\x02\x02\u{f4}\
	\u{60f}\x03\x02\x02\x02\u{f6}\u{617}\x03\x02\x02\x02\u{f8}\u{625}\x03\x02\
	\x02\x02\u{fa}\u{62a}\x03\x02\x02\x02\u{fc}\u{63c}\x03\x02\x02\x02\u{fe}\
	\u{63e}\x03\x02\x02\x02\u{100}\u{644}\x03\x02\x02\x02\u{102}\u{646}\x03\
	\x02\x02\x02\u{104}\u{64e}\x03\x02\x02\x02\u{106}\u{656}\x03\x02\x02\x02\
	\u{108}\u{65d}\x03\x02\x02\x02\u{10a}\u{65f}\x03\x02\x02\x02\u{10c}\u{668}\
	\x03\x02\x02\x02\u{10e}\u{670}\x03\x02\x02\x02\u{110}\u{673}\x03\x02\x02\
	\x02\u{112}\u{679}\x03\x02\x02\x02\u{114}\u{682}\x03\x02\x02\x02\u{116}\
	\u{68a}\x03\x02\x02\x02\u{118}\u{690}\x03\x02\x02\x02\u{11a}\u{69a}\x03\
	\x02\x02\x02\u{11c}\u{69e}\x03\x02\x02\x02\u{11e}\u{6a3}\x03\x02\x02\x02\
	\u{120}\u{6ac}\x03\x02\x02\x02\u{122}\u{6ae}\x03\x02\x02\x02\u{124}\u{6b7}\
	\x03\x02\x02\x02\u{126}\u{6be}\x03\x02\x02\x02\u{128}\u{6cd}\x03\x02\x02\
	\x02\u{12a}\u{6cf}\x03\x02\x02\x02\u{12c}\u{6d1}\x03\x02\x02\x02\u{12e}\
	\u{6d5}\x03\x02\x02\x02\u{130}\u{6d9}\x03\x02\x02\x02\u{132}\u{6e3}\x03\
	\x02\x02\x02\u{134}\u{6e5}\x03\x02\x02\x02\u{136}\u{6eb}\x03\x02\x02\x02\
	\u{138}\u{6f3}\x03\x02\x02\x02\u{13a}\u{6fb}\x03\x02\x02\x02\u{13c}\u{703}\
	\x03\x02\x02\x02\u{13e}\u{723}\x03\x02\x02\x02\u{140}\u{725}\x03\x02\x02\
	\x02\u{142}\u{72e}\x03\x02\x02\x02\u{144}\u{744}\x03\x02\x02\x02\u{146}\
	\u{746}\x03\x02\x02\x02\u{148}\u{748}\x03\x02\x02\x02\u{14a}\u{74e}\x03\
	\x02\x02\x02\u{14c}\u{754}\x03\x02\x02\x02\u{14e}\u{75e}\x03\x02\x02\x02\
	\u{150}\u{762}\x03\x02\x02\x02\u{152}\u{764}\x03\x02\x02\x02\u{154}\u{774}\
	\x03\x02\x02\x02\u{156}\u{786}\x03\x02\x02\x02\u{158}\u{788}\x03\x02\x02\
	\x02\u{15a}\u{78a}\x03\x02\x02\x02\u{15c}\u{792}\x03\x02\x02\x02\u{15e}\
	\u{79a}\x03\x02\x02\x02\u{160}\u{7a2}\x03\x02\x02\x02\u{162}\u{7a8}\x03\
	\x02\x02\x02\u{164}\u{7ae}\x03\x02\x02\x02\u{166}\u{7b4}\x03\x02\x02\x02\
	\u{168}\u{7b8}\x03\x02\x02\x02\u{16a}\u{7ce}\x03\x02\x02\x02\u{16c}\u{7d0}\
	\x03\x02\x02\x02\u{16e}\u{7d7}\x03\x02\x02\x02\u{170}\u{7e0}\x03\x02\x02\
	\x02\u{172}\u{7e6}\x03\x02\x02\x02\u{174}\u{7ee}\x03\x02\x02\x02\u{176}\
	\u{7f1}\x03\x02\x02\x02\u{178}\u{7fa}\x03\x02\x02\x02\u{17a}\u{801}\x03\
	\x02\x02\x02\u{17c}\u{80b}\x03\x02\x02\x02\u{17e}\u{80f}\x03\x02\x02\x02\
	\u{180}\u{811}\x03\x02\x02\x02\u{182}\u{815}\x03\x02\x02\x02\u{184}\u{817}\
	\x03\x02\x02\x02\u{186}\u{81b}\x03\x02\x02\x02\u{188}\u{81f}\x03\x02\x02\
	\x02\u{18a}\u{8fa}\x03\x02\x02\x02\u{18c}\u{921}\x03\x02\x02\x02\u{18e}\
	\u{946}\x03\x02\x02\x02\u{190}\u{951}\x03\x02\x02\x02\u{192}\u{953}\x03\
	\x02\x02\x02\u{194}\u{963}\x03\x02\x02\x02\u{196}\u{979}\x03\x02\x02\x02\
	\u{198}\u{97d}\x03\x02\x02\x02\u{19a}\u{98b}\x03\x02\x02\x02\u{19c}\u{997}\
	\x03\x02\x02\x02\u{19e}\u{999}\x03\x02\x02\x02\u{1a0}\u{9a3}\x03\x02\x02\
	\x02\u{1a2}\u{9b9}\x03\x02\x02\x02\u{1a4}\u{9c8}\x03\x02\x02\x02\u{1a6}\
	\u{a0e}\x03\x02\x02\x02\u{1a8}\u{a10}\x03\x02\x02\x02\u{1aa}\u{a47}\x03\
	\x02\x02\x02\u{1ac}\u{a51}\x03\x02\x02\x02\u{1ae}\u{a5b}\x03\x02\x02\x02\
	\u{1b0}\u{a5d}\x03\x02\x02\x02\u{1b2}\u{a60}\x03\x02\x02\x02\u{1b4}\u{a6a}\
	\x03\x02\x02\x02\u{1b6}\u{a6c}\x03\x02\x02\x02\u{1b8}\u{a6f}\x03\x02\x02\
	\x02\u{1ba}\u{a79}\x03\x02\x02\x02\u{1bc}\u{a96}\x03\x02\x02\x02\u{1be}\
	\u{a98}\x03\x02\x02\x02\u{1c0}\u{aa9}\x03\x02\x02\x02\u{1c2}\u{ab7}\x03\
	\x02\x02\x02\u{1c4}\u{acc}\x03\x02\x02\x02\u{1c6}\u{ae6}\x03\x02\x02\x02\
	\u{1c8}\u{af4}\x03\x02\x02\x02\u{1ca}\u{aff}\x03\x02\x02\x02\u{1cc}\u{b0a}\
	\x03\x02\x02\x02\u{1ce}\u{b15}\x03\x02\x02\x02\u{1d0}\u{b20}\x03\x02\x02\
	\x02\u{1d2}\u{b38}\x03\x02\x02\x02\u{1d4}\u{b3c}\x03\x02\x02\x02\u{1d6}\
	\u{b3e}\x03\x02\x02\x02\u{1d8}\u{b45}\x03\x02\x02\x02\u{1da}\u{b47}\x03\
	\x02\x02\x02\u{1dc}\u{b49}\x03\x02\x02\x02\u{1de}\u{b53}\x03\x02\x02\x02\
	\u{1e0}\u{b65}\x03\x02\x02\x02\u{1e2}\u{b71}\x03\x02\x02\x02\u{1e4}\u{b75}\
	\x03\x02\x02\x02\u{1e6}\u{b79}\x03\x02\x02\x02\u{1e8}\u{b7b}\x03\x02\x02\
	\x02\u{1ea}\u{b81}\x03\x02\x02\x02\u{1ec}\u{1ed}\x05\x42\x22\x02\u{1ed}\
	\u{1ee}\x07\x02\x02\x03\u{1ee}\x03\x03\x02\x02\x02\u{1ef}\u{1f0}\x09\x02\
	\x02\x02\u{1f0}\x05\x03\x02\x02\x02\u{1f1}\u{1f2}\x07\x7d\x02\x02\u{1f2}\
	\x07\x03\x02\x02\x02\u{1f3}\u{1f4}\x07\x7d\x02\x02\u{1f4}\x09\x03\x02\x02\
	\x02\u{1f5}\u{1f7}\x05\u{100}\u{81}\x02\u{1f6}\u{1f5}\x03\x02\x02\x02\u{1f7}\
	\u{1fa}\x03\x02\x02\x02\u{1f8}\u{1f6}\x03\x02\x02\x02\u{1f8}\u{1f9}\x03\
	\x02\x02\x02\u{1f9}\u{1fd}\x03\x02\x02\x02\u{1fa}\u{1f8}\x03\x02\x02\x02\
	\u{1fb}\u{1fe}\x05\x0c\x07\x02\u{1fc}\u{1fe}\x07\x16\x02\x02\u{1fd}\u{1fb}\
	\x03\x02\x02\x02\u{1fd}\u{1fc}\x03\x02\x02\x02\u{1fe}\x0b\x03\x02\x02\x02\
	\u{1ff}\u{202}\x05\x0e\x08\x02\u{200}\u{202}\x05\x10\x09\x02\u{201}\u{1ff}\
	\x03\x02\x02\x02\u{201}\u{200}\x03\x02\x02\x02\u{202}\x0d\x03\x02\x02\x02\
	\u{203}\u{204}\x09\x03\x02\x02\u{204}\x0f\x03\x02\x02\x02\u{205}\u{206}\
	\x09\x04\x02\x02\u{206}\x11\x03\x02\x02\x02\u{207}\u{20b}\x05\x16\x0c\x02\
	\u{208}\u{20b}\x05\x1c\x0f\x02\u{209}\u{20b}\x05\x1e\x10\x02\u{20a}\u{207}\
	\x03\x02\x02\x02\u{20a}\u{208}\x03\x02\x02\x02\u{20a}\u{209}\x03\x02\x02\
	\x02\u{20b}\x13\x03\x02\x02\x02\u{20c}\u{210}\x07\x56\x02\x02\u{20d}\u{20f}\
	\x05\u{100}\u{81}\x02\u{20e}\u{20d}\x03\x02\x02\x02\u{20f}\u{212}\x03\x02\
	\x02\x02\u{210}\u{20e}\x03\x02\x02\x02\u{210}\u{211}\x03\x02\x02\x02\u{211}\
	\u{213}\x03\x02\x02\x02\u{212}\u{210}\x03\x02\x02\x02\u{213}\u{215}\x05\
	\x06\x04\x02\u{214}\u{216}\x05\x2a\x16\x02\u{215}\u{214}\x03\x02\x02\x02\
	\u{215}\u{216}\x03\x02\x02\x02\u{216}\u{218}\x03\x02\x02\x02\u{217}\u{219}\
	\x05\x14\x0b\x02\u{218}\u{217}\x03\x02\x02\x02\u{218}\u{219}\x03\x02\x02\
	\x02\u{219}\x15\x03\x02\x02\x02\u{21a}\u{21b}\x05\x36\x1c\x02\u{21b}\u{21c}\
	\x07\x56\x02\x02\u{21c}\u{21e}\x03\x02\x02\x02\u{21d}\u{21a}\x03\x02\x02\
	\x02\u{21d}\u{21e}\x03\x02\x02\x02\u{21e}\u{222}\x03\x02\x02\x02\u{21f}\
	\u{221}\x05\u{100}\u{81}\x02\u{220}\u{21f}\x03\x02\x02\x02\u{221}\u{224}\
	\x03\x02\x02\x02\u{222}\u{220}\x03\x02\x02\x02\u{222}\u{223}\x03\x02\x02\
	\x02\u{223}\u{225}\x03\x02\x02\x02\u{224}\u{222}\x03\x02\x02\x02\u{225}\
	\u{227}\x05\x06\x04\x02\u{226}\u{228}\x05\x2a\x16\x02\u{227}\u{226}\x03\
	\x02\x02\x02\u{227}\u{228}\x03\x02\x02\x02\u{228}\u{22a}\x03\x02\x02\x02\
	\u{229}\u{22b}\x05\x14\x0b\x02\u{22a}\u{229}\x03\x02\x02\x02\u{22a}\u{22b}\
	\x03\x02\x02\x02\u{22b}\x17\x03\x02\x02\x02\u{22c}\u{22e}\x05\u{100}\u{81}\
	\x02\u{22d}\u{22c}\x03\x02\x02\x02\u{22e}\u{231}\x03\x02\x02\x02\u{22f}\
	\u{22d}\x03\x02\x02\x02\u{22f}\u{230}\x03\x02\x02\x02\u{230}\u{232}\x03\
	\x02\x02\x02\u{231}\u{22f}\x03\x02\x02\x02\u{232}\u{234}\x05\x06\x04\x02\
	\u{233}\u{235}\x05\x2a\x16\x02\u{234}\u{233}\x03\x02\x02\x02\u{234}\u{235}\
	\x03\x02\x02\x02\u{235}\u{24f}\x03\x02\x02\x02\u{236}\u{237}\x05\x36\x1c\
	\x02\u{237}\u{23b}\x07\x56\x02\x02\u{238}\u{23a}\x05\u{100}\u{81}\x02\u{239}\
	\u{238}\x03\x02\x02\x02\u{23a}\u{23d}\x03\x02\x02\x02\u{23b}\u{239}\x03\
	\x02\x02\x02\u{23b}\u{23c}\x03\x02\x02\x02\u{23c}\u{23e}\x03\x02\x02\x02\
	\u{23d}\u{23b}\x03\x02\x02\x02\u{23e}\u{240}\x05\x06\x04\x02\u{23f}\u{241}\
	\x05\x2a\x16\x02\u{240}\u{23f}\x03\x02\x02\x02\u{240}\u{241}\x03\x02\x02\
	\x02\u{241}\u{24f}\x03\x02\x02\x02\u{242}\u{243}\x05\x16\x0c\x02\u{243}\
	\u{247}\x07\x56\x02\x02\u{244}\u{246}\x05\u{100}\u{81}\x02\u{245}\u{244}\
	\x03\x02\x02\x02\u{246}\u{249}\x03\x02\x02\x02\u{247}\u{245}\x03\x02\x02\
	\x02\u{247}\u{248}\x03\x02\x02\x02\u{248}\u{24a}\x03\x02\x02\x02\u{249}\
	\u{247}\x03\x02\x02\x02\u{24a}\u{24c}\x05\x06\x04\x02\u{24b}\u{24d}\x05\
	\x2a\x16\x02\u{24c}\u{24b}\x03\x02\x02\x02\u{24c}\u{24d}\x03\x02\x02\x02\
	\u{24d}\u{24f}\x03\x02\x02\x02\u{24e}\u{22f}\x03\x02\x02\x02\u{24e}\u{236}\
	\x03\x02\x02\x02\u{24e}\u{242}\x03\x02\x02\x02\u{24f}\x19\x03\x02\x02\x02\
	\u{250}\u{251}\x05\x18\x0d\x02\u{251}\x1b\x03\x02\x02\x02\u{252}\u{254}\
	\x05\u{100}\u{81}\x02\u{253}\u{252}\x03\x02\x02\x02\u{254}\u{257}\x03\x02\
	\x02\x02\u{255}\u{253}\x03\x02\x02\x02\u{255}\u{256}\x03\x02\x02\x02\u{256}\
	\u{258}\x03\x02\x02\x02\u{257}\u{255}\x03\x02\x02\x02\u{258}\u{259}\x05\
	\x06\x04\x02\u{259}\x1d\x03\x02\x02\x02\u{25a}\u{25b}\x05\x0a\x06\x02\u{25b}\
	\u{25c}\x05\x20\x11\x02\u{25c}\u{264}\x03\x02\x02\x02\u{25d}\u{25e}\x05\
	\x18\x0d\x02\u{25e}\u{25f}\x05\x20\x11\x02\u{25f}\u{264}\x03\x02\x02\x02\
	\u{260}\u{261}\x05\x1c\x0f\x02\u{261}\u{262}\x05\x20\x11\x02\u{262}\u{264}\
	\x03\x02\x02\x02\u{263}\u{25a}\x03\x02\x02\x02\u{263}\u{25d}\x03\x02\x02\
	\x02\u{263}\u{260}\x03\x02\x02\x02\u{264}\x1f\x03\x02\x02\x02\u{265}\u{267}\
	\x05\u{100}\u{81}\x02\u{266}\u{265}\x03\x02\x02\x02\u{267}\u{26a}\x03\x02\
	\x02\x02\u{268}\u{266}\x03\x02\x02\x02\u{268}\u{269}\x03\x02\x02\x02\u{269}\
	\u{26b}\x03\x02\x02\x02\u{26a}\u{268}\x03\x02\x02\x02\u{26b}\u{26c}\x07\
	\x52\x02\x02\u{26c}\u{277}\x07\x53\x02\x02\u{26d}\u{26f}\x05\u{100}\u{81}\
	\x02\u{26e}\u{26d}\x03\x02\x02\x02\u{26f}\u{272}\x03\x02\x02\x02\u{270}\
	\u{26e}\x03\x02\x02\x02\u{270}\u{271}\x03\x02\x02\x02\u{271}\u{273}\x03\
	\x02\x02\x02\u{272}\u{270}\x03\x02\x02\x02\u{273}\u{274}\x07\x52\x02\x02\
	\u{274}\u{276}\x07\x53\x02\x02\u{275}\u{270}\x03\x02\x02\x02\u{276}\u{279}\
	\x03\x02\x02\x02\u{277}\u{275}\x03\x02\x02\x02\u{277}\u{278}\x03\x02\x02\
	\x02\u{278}\x21\x03\x02\x02\x02\u{279}\u{277}\x03\x02\x02\x02\u{27a}\u{27c}\
	\x05\x24\x13\x02\u{27b}\u{27a}\x03\x02\x02\x02\u{27c}\u{27f}\x03\x02\x02\
	\x02\u{27d}\u{27b}\x03\x02\x02\x02\u{27d}\u{27e}\x03\x02\x02\x02\u{27e}\
	\u{280}\x03\x02\x02\x02\u{27f}\u{27d}\x03\x02\x02\x02\u{280}\u{282}\x05\
	\x06\x04\x02\u{281}\u{283}\x05\x26\x14\x02\u{282}\u{281}\x03\x02\x02\x02\
	\u{282}\u{283}\x03\x02\x02\x02\u{283}\x23\x03\x02\x02\x02\u{284}\u{285}\
	\x05\u{100}\u{81}\x02\u{285}\x25\x03\x02\x02\x02\u{286}\u{28f}\x07\x24\x02\
	\x02\u{287}\u{290}\x05\x1c\x0f\x02\u{288}\u{28c}\x05\x16\x0c\x02\u{289}\
	\u{28b}\x05\x28\x15\x02\u{28a}\u{289}\x03\x02\x02\x02\u{28b}\u{28e}\x03\
	\x02\x02\x02\u{28c}\u{28a}\x03\x02\x02\x02\u{28c}\u{28d}\x03\x02\x02\x02\
	\u{28d}\u{290}\x03\x02\x02\x02\u{28e}\u{28c}\x03\x02\x02\x02\u{28f}\u{287}\
	\x03\x02\x02\x02\u{28f}\u{288}\x03\x02\x02\x02\u{290}\x27\x03\x02\x02\x02\
	\u{291}\u{292}\x07\x6e\x02\x02\u{292}\u{293}\x05\x1a\x0e\x02\u{293}\x29\
	\x03\x02\x02\x02\u{294}\u{295}\x07\x5c\x02\x02\u{295}\u{296}\x05\x2c\x17\
	\x02\u{296}\u{297}\x07\x5b\x02\x02\u{297}\x2b\x03\x02\x02\x02\u{298}\u{29d}\
	\x05\x2e\x18\x02\u{299}\u{29a}\x07\x55\x02\x02\u{29a}\u{29c}\x05\x2e\x18\
	\x02\u{29b}\u{299}\x03\x02\x02\x02\u{29c}\u{29f}\x03\x02\x02\x02\u{29d}\
	\u{29b}\x03\x02\x02\x02\u{29d}\u{29e}\x03\x02\x02\x02\u{29e}\x2d\x03\x02\
	\x02\x02\u{29f}\u{29d}\x03\x02\x02\x02\u{2a0}\u{2a3}\x05\x12\x0a\x02\u{2a1}\
	\u{2a3}\x05\x30\x19\x02\u{2a2}\u{2a0}\x03\x02\x02\x02\u{2a2}\u{2a1}\x03\
	\x02\x02\x02\u{2a3}\x2f\x03\x02\x02\x02\u{2a4}\u{2a6}\x05\u{100}\u{81}\x02\
	\u{2a5}\u{2a4}\x03\x02\x02\x02\u{2a6}\u{2a9}\x03\x02\x02\x02\u{2a7}\u{2a5}\
	\x03\x02\x02\x02\u{2a7}\u{2a8}\x03\x02\x02\x02\u{2a8}\u{2aa}\x03\x02\x02\
	\x02\u{2a9}\u{2a7}\x03\x02\x02\x02\u{2aa}\u{2ac}\x07\x5f\x02\x02\u{2ab}\
	\u{2ad}\x05\x32\x1a\x02\u{2ac}\u{2ab}\x03\x02\x02\x02\u{2ac}\u{2ad}\x03\
	\x02\x02\x02\u{2ad}\x31\x03\x02\x02\x02\u{2ae}\u{2af}\x07\x24\x02\x02\u{2af}\
	\u{2b3}\x05\x12\x0a\x02\u{2b0}\u{2b1}\x07\x3b\x02\x02\u{2b1}\u{2b3}\x05\
	\x12\x0a\x02\u{2b2}\u{2ae}\x03\x02\x02\x02\u{2b2}\u{2b0}\x03\x02\x02\x02\
	\u{2b3}\x33\x03\x02\x02\x02\u{2b4}\u{2b7}\x07\x7d\x02\x02\u{2b5}\u{2b6}\
	\x07\x56\x02\x02\u{2b6}\u{2b8}\x05\x34\x1b\x02\u{2b7}\u{2b5}\x03\x02\x02\
	\x02\u{2b7}\u{2b8}\x03\x02\x02\x02\u{2b8}\x35\x03\x02\x02\x02\u{2b9}\u{2bc}\
	\x07\x7d\x02\x02\u{2ba}\u{2bb}\x07\x56\x02\x02\u{2bb}\u{2bd}\x05\x36\x1c\
	\x02\u{2bc}\u{2ba}\x03\x02\x02\x02\u{2bc}\u{2bd}\x03\x02\x02\x02\u{2bd}\
	\x37\x03\x02\x02\x02\u{2be}\u{2c1}\x05\x36\x1c\x02\u{2bf}\u{2c0}\x07\x56\
	\x02\x02\u{2c0}\u{2c2}\x05\x06\x04\x02\u{2c1}\u{2bf}\x03\x02\x02\x02\u{2c1}\
	\u{2c2}\x03\x02\x02\x02\u{2c2}\x39\x03\x02\x02\x02\u{2c3}\u{2c6}\x07\x7d\
	\x02\x02\u{2c4}\u{2c5}\x07\x56\x02\x02\u{2c5}\u{2c7}\x05\x3a\x1e\x02\u{2c6}\
	\u{2c4}\x03\x02\x02\x02\u{2c6}\u{2c7}\x03\x02\x02\x02\u{2c7}\x3b\x03\x02\
	\x02\x02\u{2c8}\u{2c9}\x05\x40\x21\x02\u{2c9}\u{2ca}\x07\x56\x02\x02\u{2ca}\
	\u{2cc}\x03\x02\x02\x02\u{2cb}\u{2c8}\x03\x02\x02\x02\u{2cb}\u{2cc}\x03\
	\x02\x02\x02\u{2cc}\u{2cd}\x03\x02\x02\x02\u{2cd}\u{2ce}\x07\x7d\x02\x02\
	\u{2ce}\x3d\x03\x02\x02\x02\u{2cf}\u{2d0}\x05\x08\x05\x02\u{2d0}\x3f\x03\
	\x02\x02\x02\u{2d1}\u{2d4}\x07\x7d\x02\x02\u{2d2}\u{2d3}\x07\x56\x02\x02\
	\u{2d3}\u{2d5}\x05\x40\x21\x02\u{2d4}\u{2d2}\x03\x02\x02\x02\u{2d4}\u{2d5}\
	\x03\x02\x02\x02\u{2d5}\x41\x03\x02\x02\x02\u{2d6}\u{2d9}\x05\x44\x23\x02\
	\u{2d7}\u{2d9}\x05\x46\x24\x02\u{2d8}\u{2d6}\x03\x02\x02\x02\u{2d8}\u{2d7}\
	\x03\x02\x02\x02\u{2d9}\x43\x03\x02\x02\x02\u{2da}\u{2dc}\x05\x48\x25\x02\
	\u{2db}\u{2da}\x03\x02\x02\x02\u{2db}\u{2dc}\x03\x02\x02\x02\u{2dc}\u{2e0}\
	\x03\x02\x02\x02\u{2dd}\u{2df}\x05\x4c\x27\x02\u{2de}\u{2dd}\x03\x02\x02\
	\x02\u{2df}\u{2e2}\x03\x02\x02\x02\u{2e0}\u{2de}\x03\x02\x02\x02\u{2e0}\
	\u{2e1}\x03\x02\x02\x02\u{2e1}\u{2e6}\x03\x02\x02\x02\u{2e2}\u{2e0}\x03\
	\x02\x02\x02\u{2e3}\u{2e5}\x05\x56\x2c\x02\u{2e4}\u{2e3}\x03\x02\x02\x02\
	\u{2e5}\u{2e8}\x03\x02\x02\x02\u{2e6}\u{2e4}\x03\x02\x02\x02\u{2e6}\u{2e7}\
	\x03\x02\x02\x02\u{2e7}\x45\x03\x02\x02\x02\u{2e8}\u{2e6}\x03\x02\x02\x02\
	\u{2e9}\u{2eb}\x05\x4c\x27\x02\u{2ea}\u{2e9}\x03\x02\x02\x02\u{2eb}\u{2ee}\
	\x03\x02\x02\x02\u{2ec}\u{2ea}\x03\x02\x02\x02\u{2ec}\u{2ed}\x03\x02\x02\
	\x02\u{2ed}\u{2ef}\x03\x02\x02\x02\u{2ee}\u{2ec}\x03\x02\x02\x02\u{2ef}\
	\u{2f0}\x05\x58\x2d\x02\u{2f0}\x47\x03\x02\x02\x02\u{2f1}\u{2f3}\x05\x4a\
	\x26\x02\u{2f2}\u{2f1}\x03\x02\x02\x02\u{2f3}\u{2f6}\x03\x02\x02\x02\u{2f4}\
	\u{2f2}\x03\x02\x02\x02\u{2f4}\u{2f5}\x03\x02\x02\x02\u{2f5}\u{2f7}\x03\
	\x02\x02\x02\u{2f6}\u{2f4}\x03\x02\x02\x02\u{2f7}\u{2f8}\x07\x33\x02\x02\
	\u{2f8}\u{2fd}\x07\x7d\x02\x02\u{2f9}\u{2fa}\x07\x56\x02\x02\u{2fa}\u{2fc}\
	\x07\x7d\x02\x02\u{2fb}\u{2f9}\x03\x02\x02\x02\u{2fc}\u{2ff}\x03\x02\x02\
	\x02\u{2fd}\u{2fb}\x03\x02\x02\x02\u{2fd}\u{2fe}\x03\x02\x02\x02\u{2fe}\
	\u{300}\x03\x02\x02\x02\u{2ff}\u{2fd}\x03\x02\x02\x02\u{300}\u{301}\x07\
	\x54\x02\x02\u{301}\x49\x03\x02\x02\x02\u{302}\u{303}\x05\u{100}\u{81}\x02\
	\u{303}\x4b\x03\x02\x02\x02\u{304}\u{309}\x05\x4e\x28\x02\u{305}\u{309}\
	\x05\x50\x29\x02\u{306}\u{309}\x05\x52\x2a\x02\u{307}\u{309}\x05\x54\x2b\
	\x02\u{308}\u{304}\x03\x02\x02\x02\u{308}\u{305}\x03\x02\x02\x02\u{308}\
	\u{306}\x03\x02\x02\x02\u{308}\u{307}\x03\x02\x02\x02\u{309}\x4d\x03\x02\
	\x02\x02\u{30a}\u{30b}\x07\x2c\x02\x02\u{30b}\u{30c}\x05\x38\x1d\x02\u{30c}\
	\u{30d}\x07\x54\x02\x02\u{30d}\x4f\x03\x02\x02\x02\u{30e}\u{30f}\x07\x2c\
	\x02\x02\u{30f}\u{310}\x05\x3a\x1e\x02\u{310}\u{311}\x07\x56\x02\x02\u{311}\
	\u{312}\x07\x6c\x02\x02\u{312}\u{313}\x07\x54\x02\x02\u{313}\x51\x03\x02\
	\x02\x02\u{314}\u{315}\x07\x2c\x02\x02\u{315}\u{316}\x07\x39\x02\x02\u{316}\
	\u{317}\x05\x38\x1d\x02\u{317}\u{318}\x07\x56\x02\x02\u{318}\u{319}\x07\
	\x7d\x02\x02\u{319}\u{31a}\x07\x54\x02\x02\u{31a}\x53\x03\x02\x02\x02\u{31b}\
	\u{31c}\x07\x2c\x02\x02\u{31c}\u{31d}\x07\x39\x02\x02\u{31d}\u{31e}\x05\
	\x38\x1d\x02\u{31e}\u{31f}\x07\x56\x02\x02\u{31f}\u{320}\x07\x6c\x02\x02\
	\u{320}\u{321}\x07\x54\x02\x02\u{321}\x55\x03\x02\x02\x02\u{322}\u{326}\
	\x05\x5e\x30\x02\u{323}\u{326}\x05\u{de}\x70\x02\u{324}\u{326}\x07\x54\x02\
	\x02\u{325}\u{322}\x03\x02\x02\x02\u{325}\u{323}\x03\x02\x02\x02\u{325}\
	\u{324}\x03\x02\x02\x02\u{326}\x57\x03\x02\x02\x02\u{327}\u{329}\x05\u{100}\
	\u{81}\x02\u{328}\u{327}\x03\x02\x02\x02\u{329}\u{32c}\x03\x02\x02\x02\u{32a}\
	\u{328}\x03\x02\x02\x02\u{32a}\u{32b}\x03\x02\x02\x02\u{32b}\u{32e}\x03\
	\x02\x02\x02\u{32c}\u{32a}\x03\x02\x02\x02\u{32d}\u{32f}\x07\x07\x02\x02\
	\u{32e}\u{32d}\x03\x02\x02\x02\u{32e}\u{32f}\x03\x02\x02\x02\u{32f}\u{330}\
	\x03\x02\x02\x02\u{330}\u{331}\x07\x04\x02\x02\u{331}\u{336}\x07\x7d\x02\
	\x02\u{332}\u{333}\x07\x56\x02\x02\u{333}\u{335}\x07\x7d\x02\x02\u{334}\
	\u{332}\x03\x02\x02\x02\u{335}\u{338}\x03\x02\x02\x02\u{336}\u{334}\x03\
	\x02\x02\x02\u{336}\u{337}\x03\x02\x02\x02\u{337}\u{339}\x03\x02\x02\x02\
	\u{338}\u{336}\x03\x02\x02\x02\u{339}\u{33d}\x07\x50\x02\x02\u{33a}\u{33c}\
	\x05\x5a\x2e\x02\u{33b}\u{33a}\x03\x02\x02\x02\u{33c}\u{33f}\x03\x02\x02\
	\x02\u{33d}\u{33b}\x03\x02\x02\x02\u{33d}\u{33e}\x03\x02\x02\x02\u{33e}\
	\u{340}\x03\x02\x02\x02\u{33f}\u{33d}\x03\x02\x02\x02\u{340}\u{341}\x07\
	\x51\x02\x02\u{341}\x59\x03\x02\x02\x02\u{342}\u{346}\x07\x0c\x02\x02\u{343}\
	\u{345}\x05\x5c\x2f\x02\u{344}\u{343}\x03\x02\x02\x02\u{345}\u{348}\x03\
	\x02\x02\x02\u{346}\u{344}\x03\x02\x02\x02\u{346}\u{347}\x03\x02\x02\x02\
	\u{347}\u{349}\x03\x02\x02\x02\u{348}\u{346}\x03\x02\x02\x02\u{349}\u{34a}\
	\x05\x34\x1b\x02\u{34a}\u{34b}\x07\x54\x02\x02\u{34b}\u{37c}\x03\x02\x02\
	\x02\u{34c}\u{34d}\x07\x03\x02\x02\u{34d}\u{357}\x05\x36\x1c\x02\u{34e}\
	\u{34f}\x07\x0e\x02\x02\u{34f}\u{354}\x05\x34\x1b\x02\u{350}\u{351}\x07\
	\x55\x02\x02\u{351}\u{353}\x05\x34\x1b\x02\u{352}\u{350}\x03\x02\x02\x02\
	\u{353}\u{356}\x03\x02\x02\x02\u{354}\u{352}\x03\x02\x02\x02\u{354}\u{355}\
	\x03\x02\x02\x02\u{355}\u{358}\x03\x02\x02\x02\u{356}\u{354}\x03\x02\x02\
	\x02\u{357}\u{34e}\x03\x02\x02\x02\u{357}\u{358}\x03\x02\x02\x02\u{358}\
	\u{359}\x03\x02\x02\x02\u{359}\u{35a}\x07\x54\x02\x02\u{35a}\u{37c}\x03\
	\x02\x02\x02\u{35b}\u{35c}\x07\x08\x02\x02\u{35c}\u{366}\x05\x36\x1c\x02\
	\u{35d}\u{35e}\x07\x0e\x02\x02\u{35e}\u{363}\x05\x34\x1b\x02\u{35f}\u{360}\
	\x07\x55\x02\x02\u{360}\u{362}\x05\x34\x1b\x02\u{361}\u{35f}\x03\x02\x02\
	\x02\u{362}\u{365}\x03\x02\x02\x02\u{363}\u{361}\x03\x02\x02\x02\u{363}\
	\u{364}\x03\x02\x02\x02\u{364}\u{367}\x03\x02\x02\x02\u{365}\u{363}\x03\
	\x02\x02\x02\u{366}\u{35d}\x03\x02\x02\x02\u{366}\u{367}\x03\x02\x02\x02\
	\u{367}\u{368}\x03\x02\x02\x02\u{368}\u{369}\x07\x54\x02\x02\u{369}\u{37c}\
	\x03\x02\x02\x02\u{36a}\u{36b}\x07\x10\x02\x02\u{36b}\u{36c}\x05\x38\x1d\
	\x02\u{36c}\u{36d}\x07\x54\x02\x02\u{36d}\u{37c}\x03\x02\x02\x02\u{36e}\
	\u{36f}\x07\x0a\x02\x02\u{36f}\u{370}\x05\x38\x1d\x02\u{370}\u{371}\x07\
	\x12\x02\x02\u{371}\u{376}\x05\x38\x1d\x02\u{372}\u{373}\x07\x55\x02\x02\
	\u{373}\u{375}\x05\x38\x1d\x02\u{374}\u{372}\x03\x02\x02\x02\u{375}\u{378}\
	\x03\x02\x02\x02\u{376}\u{374}\x03\x02\x02\x02\u{376}\u{377}\x03\x02\x02\
	\x02\u{377}\u{379}\x03\x02\x02\x02\u{378}\u{376}\x03\x02\x02\x02\u{379}\
	\u{37a}\x07\x54\x02\x02\u{37a}\u{37c}\x03\x02\x02\x02\u{37b}\u{342}\x03\
	\x02\x02\x02\u{37b}\u{34c}\x03\x02\x02\x02\u{37b}\u{35b}\x03\x02\x02\x02\
	\u{37b}\u{36a}\x03\x02\x02\x02\u{37b}\u{36e}\x03\x02\x02\x02\u{37c}\x5b\
	\x03\x02\x02\x02\u{37d}\u{37e}\x09\x05\x02\x02\u{37e}\x5d\x03\x02\x02\x02\
	\u{37f}\u{383}\x05\x60\x31\x02\u{380}\u{383}\x05\u{c0}\x61\x02\u{381}\u{383}\
	\x05\u{cc}\x67\x02\u{382}\u{37f}\x03\x02\x02\x02\u{382}\u{380}\x03\x02\x02\
	\x02\u{382}\u{381}\x03\x02\x02\x02\u{383}\x5f\x03\x02\x02\x02\u{384}\u{386}\
	\x05\x62\x32\x02\u{385}\u{384}\x03\x02\x02\x02\u{386}\u{389}\x03\x02\x02\
	\x02\u{387}\u{385}\x03\x02\x02\x02\u{387}\u{388}\x03\x02\x02\x02\u{388}\
	\u{38a}\x03\x02\x02\x02\u{389}\u{387}\x03\x02\x02\x02\u{38a}\u{38b}\x07\
	\x1c\x02\x02\u{38b}\u{38d}\x05\x06\x04\x02\u{38c}\u{38e}\x05\x64\x33\x02\
	\u{38d}\u{38c}\x03\x02\x02\x02\u{38d}\u{38e}\x03\x02\x02\x02\u{38e}\u{390}\
	\x03\x02\x02\x02\u{38f}\u{391}\x05\x68\x35\x02\u{390}\u{38f}\x03\x02\x02\
	\x02\u{390}\u{391}\x03\x02\x02\x02\u{391}\u{393}\x03\x02\x02\x02\u{392}\
	\u{394}\x05\x6a\x36\x02\u{393}\u{392}\x03\x02\x02\x02\u{393}\u{394}\x03\
	\x02\x02\x02\u{394}\u{396}\x03\x02\x02\x02\u{395}\u{397}\x05\x6e\x38\x02\
	\u{396}\u{395}\x03\x02\x02\x02\u{396}\u{397}\x03\x02\x02\x02\u{397}\u{398}\
	\x03\x02\x02\x02\u{398}\u{399}\x05\x70\x39\x02\u{399}\x61\x03\x02\x02\x02\
	\u{39a}\u{3a5}\x05\u{100}\u{81}\x02\u{39b}\u{3a5}\x07\x36\x02\x02\u{39c}\
	\u{3a5}\x07\x35\x02\x02\u{39d}\u{3a5}\x07\x34\x02\x02\u{39e}\u{3a5}\x07\
	\x14\x02\x02\u{39f}\u{3a5}\x07\x39\x02\x02\u{3a0}\u{3a5}\x07\x25\x02\x02\
	\u{3a1}\u{3a5}\x07\x0d\x02\x02\u{3a2}\u{3a5}\x07\x05\x02\x02\u{3a3}\u{3a5}\
	\x07\x3a\x02\x02\u{3a4}\u{39a}\x03\x02\x02\x02\u{3a4}\u{39b}\x03\x02\x02\
	\x02\u{3a4}\u{39c}\x03\x02\x02\x02\u{3a4}\u{39d}\x03\x02\x02\x02\u{3a4}\
	\u{39e}\x03\x02\x02\x02\u{3a4}\u{39f}\x03\x02\x02\x02\u{3a4}\u{3a0}\x03\
	\x02\x02\x02\u{3a4}\u{3a1}\x03\x02\x02\x02\u{3a4}\u{3a2}\x03\x02\x02\x02\
	\u{3a4}\u{3a3}\x03\x02\x02\x02\u{3a5}\x63\x03\x02\x02\x02\u{3a6}\u{3a7}\
	\x07\x5c\x02\x02\u{3a7}\u{3a8}\x05\x66\x34\x02\u{3a8}\u{3a9}\x07\x5b\x02\
	\x02\u{3a9}\x65\x03\x02\x02\x02\u{3aa}\u{3af}\x05\x22\x12\x02\u{3ab}\u{3ac}\
	\x07\x55\x02\x02\u{3ac}\u{3ae}\x05\x22\x12\x02\u{3ad}\u{3ab}\x03\x02\x02\
	\x02\u{3ae}\u{3b1}\x03\x02\x02\x02\u{3af}\u{3ad}\x03\x02\x02\x02\u{3af}\
	\u{3b0}\x03\x02\x02\x02\u{3b0}\x67\x03\x02\x02\x02\u{3b1}\u{3af}\x03\x02\
	\x02\x02\u{3b2}\u{3b3}\x07\x24\x02\x02\u{3b3}\u{3b4}\x05\x18\x0d\x02\u{3b4}\
	\x69\x03\x02\x02\x02\u{3b5}\u{3b6}\x07\x2b\x02\x02\u{3b6}\u{3b7}\x05\x6c\
	\x37\x02\u{3b7}\x6b\x03\x02\x02\x02\u{3b8}\u{3bd}\x05\x1a\x0e\x02\u{3b9}\
	\u{3ba}\x07\x55\x02\x02\u{3ba}\u{3bc}\x05\x1a\x0e\x02\u{3bb}\u{3b9}\x03\
	\x02\x02\x02\u{3bc}\u{3bf}\x03\x02\x02\x02\u{3bd}\u{3bb}\x03\x02\x02\x02\
	\u{3bd}\u{3be}\x03\x02\x02\x02\u{3be}\x6d\x03\x02\x02\x02\u{3bf}\u{3bd}\
	\x03\x02\x02\x02\u{3c0}\u{3c1}\x07\x09\x02\x02\u{3c1}\u{3c6}\x05\x38\x1d\
	\x02\u{3c2}\u{3c3}\x07\x55\x02\x02\u{3c3}\u{3c5}\x05\x38\x1d\x02\u{3c4}\
	\u{3c2}\x03\x02\x02\x02\u{3c5}\u{3c8}\x03\x02\x02\x02\u{3c6}\u{3c4}\x03\
	\x02\x02\x02\u{3c6}\u{3c7}\x03\x02\x02\x02\u{3c7}\x6f\x03\x02\x02\x02\u{3c8}\
	\u{3c6}\x03\x02\x02\x02\u{3c9}\u{3cd}\x07\x50\x02\x02\u{3ca}\u{3cc}\x05\
	\x72\x3a\x02\u{3cb}\u{3ca}\x03\x02\x02\x02\u{3cc}\u{3cf}\x03\x02\x02\x02\
	\u{3cd}\u{3cb}\x03\x02\x02\x02\u{3cd}\u{3ce}\x03\x02\x02\x02\u{3ce}\u{3d0}\
	\x03\x02\x02\x02\u{3cf}\u{3cd}\x03\x02\x02\x02\u{3d0}\u{3d1}\x07\x51\x02\
	\x02\u{3d1}\x71\x03\x02\x02\x02\u{3d2}\u{3d7}\x05\x74\x3b\x02\u{3d3}\u{3d7}\
	\x05\u{b0}\x59\x02\u{3d4}\u{3d7}\x05\u{b2}\x5a\x02\u{3d5}\u{3d7}\x05\u{b4}\
	\x5b\x02\u{3d6}\u{3d2}\x03\x02\x02\x02\u{3d6}\u{3d3}\x03\x02\x02\x02\u{3d6}\
	\u{3d4}\x03\x02\x02\x02\u{3d6}\u{3d5}\x03\x02\x02\x02\u{3d7}\x73\x03\x02\
	\x02\x02\u{3d8}\u{3de}\x05\x76\x3c\x02\u{3d9}\u{3de}\x05\u{94}\x4b\x02\u{3da}\
	\u{3de}\x05\x5e\x30\x02\u{3db}\u{3de}\x05\u{de}\x70\x02\u{3dc}\u{3de}\x07\
	\x54\x02\x02\u{3dd}\u{3d8}\x03\x02\x02\x02\u{3dd}\u{3d9}\x03\x02\x02\x02\
	\u{3dd}\u{3da}\x03\x02\x02\x02\u{3dd}\u{3db}\x03\x02\x02\x02\u{3dd}\u{3dc}\
	\x03\x02\x02\x02\u{3de}\x75\x03\x02\x02\x02\u{3df}\u{3e1}\x05\x78\x3d\x02\
	\u{3e0}\u{3df}\x03\x02\x02\x02\u{3e1}\u{3e4}\x03\x02\x02\x02\u{3e2}\u{3e0}\
	\x03\x02\x02\x02\u{3e2}\u{3e3}\x03\x02\x02\x02\u{3e3}\u{3e5}\x03\x02\x02\
	\x02\u{3e4}\u{3e2}\x03\x02\x02\x02\u{3e5}\u{3e6}\x05\u{82}\x42\x02\u{3e6}\
	\u{3e7}\x05\x7a\x3e\x02\u{3e7}\u{3e8}\x07\x54\x02\x02\u{3e8}\x77\x03\x02\
	\x02\x02\u{3e9}\u{3f2}\x05\u{100}\u{81}\x02\u{3ea}\u{3f2}\x07\x36\x02\x02\
	\u{3eb}\u{3f2}\x07\x35\x02\x02\u{3ec}\u{3f2}\x07\x34\x02\x02\u{3ed}\u{3f2}\
	\x07\x39\x02\x02\u{3ee}\u{3f2}\x07\x25\x02\x02\u{3ef}\u{3f2}\x07\x41\x02\
	\x02\u{3f0}\u{3f2}\x07\x44\x02\x02\u{3f1}\u{3e9}\x03\x02\x02\x02\u{3f1}\
	\u{3ea}\x03\x02\x02\x02\u{3f1}\u{3eb}\x03\x02\x02\x02\u{3f1}\u{3ec}\x03\
	\x02\x02\x02\u{3f1}\u{3ed}\x03\x02\x02\x02\u{3f1}\u{3ee}\x03\x02\x02\x02\
	\u{3f1}\u{3ef}\x03\x02\x02\x02\u{3f1}\u{3f0}\x03\x02\x02\x02\u{3f2}\x79\
	\x03\x02\x02\x02\u{3f3}\u{3f8}\x05\x7c\x3f\x02\u{3f4}\u{3f5}\x07\x55\x02\
	\x02\u{3f5}\u{3f7}\x05\x7c\x3f\x02\u{3f6}\u{3f4}\x03\x02\x02\x02\u{3f7}\
	\u{3fa}\x03\x02\x02\x02\u{3f8}\u{3f6}\x03\x02\x02\x02\u{3f8}\u{3f9}\x03\
	\x02\x02\x02\u{3f9}\x7b\x03\x02\x02\x02\u{3fa}\u{3f8}\x03\x02\x02\x02\u{3fb}\
	\u{3fe}\x05\x7e\x40\x02\u{3fc}\u{3fd}\x07\x5a\x02\x02\u{3fd}\u{3ff}\x05\
	\u{80}\x41\x02\u{3fe}\u{3fc}\x03\x02\x02\x02\u{3fe}\u{3ff}\x03\x02\x02\x02\
	\u{3ff}\x7d\x03\x02\x02\x02\u{400}\u{402}\x07\x7d\x02\x02\u{401}\u{403}\
	\x05\x20\x11\x02\u{402}\u{401}\x03\x02\x02\x02\u{402}\u{403}\x03\x02\x02\
	\x02\u{403}\x7f\x03\x02\x02\x02\u{404}\u{407}\x05\u{186}\u{c4}\x02\u{405}\
	\u{407}\x05\u{112}\u{8a}\x02\u{406}\u{404}\x03\x02\x02\x02\u{406}\u{405}\
	\x03\x02\x02\x02\u{407}\u{81}\x03\x02\x02\x02\u{408}\u{40b}\x05\u{84}\x43\
	\x02\u{409}\u{40b}\x05\u{86}\x44\x02\u{40a}\u{408}\x03\x02\x02\x02\u{40a}\
	\u{409}\x03\x02\x02\x02\u{40b}\u{83}\x03\x02\x02\x02\u{40c}\u{40f}\x05\x0c\
	\x07\x02\u{40d}\u{40f}\x07\x16\x02\x02\u{40e}\u{40c}\x03\x02\x02\x02\u{40e}\
	\u{40d}\x03\x02\x02\x02\u{40f}\u{85}\x03\x02\x02\x02\u{410}\u{414}\x05\u{88}\
	\x45\x02\u{411}\u{414}\x05\u{90}\x49\x02\u{412}\u{414}\x05\u{92}\x4a\x02\
	\u{413}\u{410}\x03\x02\x02\x02\u{413}\u{411}\x03\x02\x02\x02\u{413}\u{412}\
	\x03\x02\x02\x02\u{414}\u{87}\x03\x02\x02\x02\u{415}\u{416}\x05\x36\x1c\
	\x02\u{416}\u{41a}\x07\x56\x02\x02\u{417}\u{419}\x05\u{100}\u{81}\x02\u{418}\
	\u{417}\x03\x02\x02\x02\u{419}\u{41c}\x03\x02\x02\x02\u{41a}\u{418}\x03\
	\x02\x02\x02\u{41a}\u{41b}\x03\x02\x02\x02\u{41b}\u{41e}\x03\x02\x02\x02\
	\u{41c}\u{41a}\x03\x02\x02\x02\u{41d}\u{415}\x03\x02\x02\x02\u{41d}\u{41e}\
	\x03\x02\x02\x02\u{41e}\u{41f}\x03\x02\x02\x02\u{41f}\u{421}\x05\x06\x04\
	\x02\u{420}\u{422}\x05\x2a\x16\x02\u{421}\u{420}\x03\x02\x02\x02\u{421}\
	\u{422}\x03\x02\x02\x02\u{422}\u{424}\x03\x02\x02\x02\u{423}\u{425}\x05\
	\u{8a}\x46\x02\u{424}\u{423}\x03\x02\x02\x02\u{424}\u{425}\x03\x02\x02\x02\
	\u{425}\u{89}\x03\x02\x02\x02\u{426}\u{42a}\x07\x56\x02\x02\u{427}\u{429}\
	\x05\u{100}\u{81}\x02\u{428}\u{427}\x03\x02\x02\x02\u{429}\u{42c}\x03\x02\
	\x02\x02\u{42a}\u{428}\x03\x02\x02\x02\u{42a}\u{42b}\x03\x02\x02\x02\u{42b}\
	\u{42d}\x03\x02\x02\x02\u{42c}\u{42a}\x03\x02\x02\x02\u{42d}\u{42f}\x05\
	\x06\x04\x02\u{42e}\u{430}\x05\x2a\x16\x02\u{42f}\u{42e}\x03\x02\x02\x02\
	\u{42f}\u{430}\x03\x02\x02\x02\u{430}\u{432}\x03\x02\x02\x02\u{431}\u{433}\
	\x05\u{8a}\x46\x02\u{432}\u{431}\x03\x02\x02\x02\u{432}\u{433}\x03\x02\x02\
	\x02\u{433}\u{8b}\x03\x02\x02\x02\u{434}\u{436}\x05\x06\x04\x02\u{435}\u{437}\
	\x05\x2a\x16\x02\u{436}\u{435}\x03\x02\x02\x02\u{436}\u{437}\x03\x02\x02\
	\x02\u{437}\u{448}\x03\x02\x02\x02\u{438}\u{43b}\x05\x36\x1c\x02\u{439}\
	\u{43b}\x05\u{88}\x45\x02\u{43a}\u{438}\x03\x02\x02\x02\u{43a}\u{439}\x03\
	\x02\x02\x02\u{43b}\u{43c}\x03\x02\x02\x02\u{43c}\u{440}\x07\x56\x02\x02\
	\u{43d}\u{43f}\x05\u{100}\u{81}\x02\u{43e}\u{43d}\x03\x02\x02\x02\u{43f}\
	\u{442}\x03\x02\x02\x02\u{440}\u{43e}\x03\x02\x02\x02\u{440}\u{441}\x03\
	\x02\x02\x02\u{441}\u{443}\x03\x02\x02\x02\u{442}\u{440}\x03\x02\x02\x02\
	\u{443}\u{445}\x05\x06\x04\x02\u{444}\u{446}\x05\x2a\x16\x02\u{445}\u{444}\
	\x03\x02\x02\x02\u{445}\u{446}\x03\x02\x02\x02\u{446}\u{448}\x03\x02\x02\
	\x02\u{447}\u{434}\x03\x02\x02\x02\u{447}\u{43a}\x03\x02\x02\x02\u{448}\
	\u{8d}\x03\x02\x02\x02\u{449}\u{44a}\x05\u{8c}\x47\x02\u{44a}\u{8f}\x03\
	\x02\x02\x02\u{44b}\u{44c}\x05\x06\x04\x02\u{44c}\u{91}\x03\x02\x02\x02\
	\u{44d}\u{451}\x05\u{84}\x43\x02\u{44e}\u{451}\x05\u{88}\x45\x02\u{44f}\
	\u{451}\x05\u{90}\x49\x02\u{450}\u{44d}\x03\x02\x02\x02\u{450}\u{44e}\x03\
	\x02\x02\x02\u{450}\u{44f}\x03\x02\x02\x02\u{451}\u{452}\x03\x02\x02\x02\
	\u{452}\u{453}\x05\x20\x11\x02\u{453}\u{93}\x03\x02\x02\x02\u{454}\u{456}\
	\x05\u{96}\x4c\x02\u{455}\u{454}\x03\x02\x02\x02\u{456}\u{459}\x03\x02\x02\
	\x02\u{457}\u{455}\x03\x02\x02\x02\u{457}\u{458}\x03\x02\x02\x02\u{458}\
	\u{45a}\x03\x02\x02\x02\u{459}\u{457}\x03\x02\x02\x02\u{45a}\u{45b}\x05\
	\u{98}\x4d\x02\u{45b}\u{45c}\x05\u{ae}\x58\x02\u{45c}\u{95}\x03\x02\x02\
	\x02\u{45d}\u{468}\x05\u{100}\u{81}\x02\u{45e}\u{468}\x07\x36\x02\x02\u{45f}\
	\u{468}\x07\x35\x02\x02\u{460}\u{468}\x07\x34\x02\x02\u{461}\u{468}\x07\
	\x14\x02\x02\u{462}\u{468}\x07\x39\x02\x02\u{463}\u{468}\x07\x25\x02\x02\
	\u{464}\u{468}\x07\x3d\x02\x02\u{465}\u{468}\x07\x31\x02\x02\u{466}\u{468}\
	\x07\x3a\x02\x02\u{467}\u{45d}\x03\x02\x02\x02\u{467}\u{45e}\x03\x02\x02\
	\x02\u{467}\u{45f}\x03\x02\x02\x02\u{467}\u{460}\x03\x02\x02\x02\u{467}\
	\u{461}\x03\x02\x02\x02\u{467}\u{462}\x03\x02\x02\x02\u{467}\u{463}\x03\
	\x02\x02\x02\u{467}\u{464}\x03\x02\x02\x02\u{467}\u{465}\x03\x02\x02\x02\
	\u{467}\u{466}\x03\x02\x02\x02\u{468}\u{97}\x03\x02\x02\x02\u{469}\u{46d}\
	\x05\x64\x33\x02\u{46a}\u{46c}\x05\u{100}\u{81}\x02\u{46b}\u{46a}\x03\x02\
	\x02\x02\u{46c}\u{46f}\x03\x02\x02\x02\u{46d}\u{46b}\x03\x02\x02\x02\u{46d}\
	\u{46e}\x03\x02\x02\x02\u{46e}\u{471}\x03\x02\x02\x02\u{46f}\u{46d}\x03\
	\x02\x02\x02\u{470}\u{469}\x03\x02\x02\x02\u{470}\u{471}\x03\x02\x02\x02\
	\u{471}\u{472}\x03\x02\x02\x02\u{472}\u{473}\x05\u{9a}\x4e\x02\u{473}\u{475}\
	\x05\u{9c}\x4f\x02\u{474}\u{476}\x05\u{a8}\x55\x02\u{475}\u{474}\x03\x02\
	\x02\x02\u{475}\u{476}\x03\x02\x02\x02\u{476}\u{99}\x03\x02\x02\x02\u{477}\
	\u{47a}\x05\u{82}\x42\x02\u{478}\u{47a}\x07\x43\x02\x02\u{479}\u{477}\x03\
	\x02\x02\x02\u{479}\u{478}\x03\x02\x02\x02\u{47a}\u{9b}\x03\x02\x02\x02\
	\u{47b}\u{47c}\x07\x7d\x02\x02\u{47c}\u{480}\x07\x4e\x02\x02\u{47d}\u{47e}\
	\x05\u{9e}\x50\x02\u{47e}\u{47f}\x07\x55\x02\x02\u{47f}\u{481}\x03\x02\x02\
	\x02\u{480}\u{47d}\x03\x02\x02\x02\u{480}\u{481}\x03\x02\x02\x02\u{481}\
	\u{483}\x03\x02\x02\x02\u{482}\u{484}\x05\u{a0}\x51\x02\u{483}\u{482}\x03\
	\x02\x02\x02\u{483}\u{484}\x03\x02\x02\x02\u{484}\u{485}\x03\x02\x02\x02\
	\u{485}\u{487}\x07\x4f\x02\x02\u{486}\u{488}\x05\x20\x11\x02\u{487}\u{486}\
	\x03\x02\x02\x02\u{487}\u{488}\x03\x02\x02\x02\u{488}\u{9d}\x03\x02\x02\
	\x02\u{489}\u{48b}\x05\u{100}\u{81}\x02\u{48a}\u{489}\x03\x02\x02\x02\u{48b}\
	\u{48e}\x03\x02\x02\x02\u{48c}\u{48a}\x03\x02\x02\x02\u{48c}\u{48d}\x03\
	\x02\x02\x02\u{48d}\u{48f}\x03\x02\x02\x02\u{48e}\u{48c}\x03\x02\x02\x02\
	\u{48f}\u{492}\x05\u{82}\x42\x02\u{490}\u{491}\x07\x7d\x02\x02\u{491}\u{493}\
	\x07\x56\x02\x02\u{492}\u{490}\x03\x02\x02\x02\u{492}\u{493}\x03\x02\x02\
	\x02\u{493}\u{494}\x03\x02\x02\x02\u{494}\u{495}\x07\x3e\x02\x02\u{495}\
	\u{9f}\x03\x02\x02\x02\u{496}\u{49b}\x05\u{a2}\x52\x02\u{497}\u{498}\x07\
	\x55\x02\x02\u{498}\u{49a}\x05\u{a2}\x52\x02\u{499}\u{497}\x03\x02\x02\x02\
	\u{49a}\u{49d}\x03\x02\x02\x02\u{49b}\u{499}\x03\x02\x02\x02\u{49b}\u{49c}\
	\x03\x02\x02\x02\u{49c}\u{a1}\x03\x02\x02\x02\u{49d}\u{49b}\x03\x02\x02\
	\x02\u{49e}\u{4a0}\x05\u{a6}\x54\x02\u{49f}\u{49e}\x03\x02\x02\x02\u{4a0}\
	\u{4a3}\x03\x02\x02\x02\u{4a1}\u{49f}\x03\x02\x02\x02\u{4a1}\u{4a2}\x03\
	\x02\x02\x02\u{4a2}\u{4a4}\x03\x02\x02\x02\u{4a3}\u{4a1}\x03\x02\x02\x02\
	\u{4a4}\u{4a5}\x05\u{82}\x42\x02\u{4a5}\u{4a6}\x05\x7e\x40\x02\u{4a6}\u{4a9}\
	\x03\x02\x02\x02\u{4a7}\u{4a9}\x05\u{a4}\x53\x02\u{4a8}\u{4a1}\x03\x02\x02\
	\x02\u{4a8}\u{4a7}\x03\x02\x02\x02\u{4a9}\u{a3}\x03\x02\x02\x02\u{4aa}\u{4ac}\
	\x05\u{a6}\x54\x02\u{4ab}\u{4aa}\x03\x02\x02\x02\u{4ac}\u{4af}\x03\x02\x02\
	\x02\u{4ad}\u{4ab}\x03\x02\x02\x02\u{4ad}\u{4ae}\x03\x02\x02\x02\u{4ae}\
	\u{4b0}\x03\x02\x02\x02\u{4af}\u{4ad}\x03\x02\x02\x02\u{4b0}\u{4b4}\x05\
	\u{82}\x42\x02\u{4b1}\u{4b3}\x05\u{100}\u{81}\x02\u{4b2}\u{4b1}\x03\x02\
	\x02\x02\u{4b3}\u{4b6}\x03\x02\x02\x02\u{4b4}\u{4b2}\x03\x02\x02\x02\u{4b4}\
	\u{4b5}\x03\x02\x02\x02\u{4b5}\u{4b7}\x03\x02\x02\x02\u{4b6}\u{4b4}\x03\
	\x02\x02\x02\u{4b7}\u{4b8}\x07\x57\x02\x02\u{4b8}\u{4b9}\x07\x7d\x02\x02\
	\u{4b9}\u{a5}\x03\x02\x02\x02\u{4ba}\u{4bd}\x05\u{100}\u{81}\x02\u{4bb}\
	\u{4bd}\x07\x25\x02\x02\u{4bc}\u{4ba}\x03\x02\x02\x02\u{4bc}\u{4bb}\x03\
	\x02\x02\x02\u{4bd}\u{a7}\x03\x02\x02\x02\u{4be}\u{4bf}\x07\x40\x02\x02\
	\u{4bf}\u{4c0}\x05\u{aa}\x56\x02\u{4c0}\u{a9}\x03\x02\x02\x02\u{4c1}\u{4c6}\
	\x05\u{ac}\x57\x02\u{4c2}\u{4c3}\x07\x55\x02\x02\u{4c3}\u{4c5}\x05\u{ac}\
	\x57\x02\u{4c4}\u{4c2}\x03\x02\x02\x02\u{4c5}\u{4c8}\x03\x02\x02\x02\u{4c6}\
	\u{4c4}\x03\x02\x02\x02\u{4c6}\u{4c7}\x03\x02\x02\x02\u{4c7}\u{ab}\x03\x02\
	\x02\x02\u{4c8}\u{4c6}\x03\x02\x02\x02\u{4c9}\u{4cc}\x05\x18\x0d\x02\u{4ca}\
	\u{4cc}\x05\x1c\x0f\x02\u{4cb}\u{4c9}\x03\x02\x02\x02\u{4cb}\u{4ca}\x03\
	\x02\x02\x02\u{4cc}\u{ad}\x03\x02\x02\x02\u{4cd}\u{4d0}\x05\u{116}\u{8c}\
	\x02\u{4ce}\u{4d0}\x07\x54\x02\x02\u{4cf}\u{4cd}\x03\x02\x02\x02\u{4cf}\
	\u{4ce}\x03\x02\x02\x02\u{4d0}\u{af}\x03\x02\x02\x02\u{4d1}\u{4d2}\x05\u{116}\
	\u{8c}\x02\u{4d2}\u{b1}\x03\x02\x02\x02\u{4d3}\u{4d4}\x07\x39\x02\x02\u{4d4}\
	\u{4d5}\x05\u{116}\u{8c}\x02\u{4d5}\u{b3}\x03\x02\x02\x02\u{4d6}\u{4d8}\
	\x05\u{b6}\x5c\x02\u{4d7}\u{4d6}\x03\x02\x02\x02\u{4d8}\u{4db}\x03\x02\x02\
	\x02\u{4d9}\u{4d7}\x03\x02\x02\x02\u{4d9}\u{4da}\x03\x02\x02\x02\u{4da}\
	\u{4dc}\x03\x02\x02\x02\u{4db}\u{4d9}\x03\x02\x02\x02\u{4dc}\u{4de}\x05\
	\u{b8}\x5d\x02\u{4dd}\u{4df}\x05\u{a8}\x55\x02\u{4de}\u{4dd}\x03\x02\x02\
	\x02\u{4de}\u{4df}\x03\x02\x02\x02\u{4df}\u{4e0}\x03\x02\x02\x02\u{4e0}\
	\u{4e1}\x05\u{bc}\x5f\x02\u{4e1}\u{b5}\x03\x02\x02\x02\u{4e2}\u{4e7}\x05\
	\u{100}\u{81}\x02\u{4e3}\u{4e7}\x07\x36\x02\x02\u{4e4}\u{4e7}\x07\x35\x02\
	\x02\u{4e5}\u{4e7}\x07\x34\x02\x02\u{4e6}\u{4e2}\x03\x02\x02\x02\u{4e6}\
	\u{4e3}\x03\x02\x02\x02\u{4e6}\u{4e4}\x03\x02\x02\x02\u{4e6}\u{4e5}\x03\
	\x02\x02\x02\u{4e7}\u{b7}\x03\x02\x02\x02\u{4e8}\u{4ea}\x05\x64\x33\x02\
	\u{4e9}\u{4e8}\x03\x02\x02\x02\u{4e9}\u{4ea}\x03\x02\x02\x02\u{4ea}\u{4eb}\
	\x03\x02\x02\x02\u{4eb}\u{4ec}\x05\u{ba}\x5e\x02\u{4ec}\u{4f0}\x07\x4e\x02\
	\x02\u{4ed}\u{4ee}\x05\u{9e}\x50\x02\u{4ee}\u{4ef}\x07\x55\x02\x02\u{4ef}\
	\u{4f1}\x03\x02\x02\x02\u{4f0}\u{4ed}\x03\x02\x02\x02\u{4f0}\u{4f1}\x03\
	\x02\x02\x02\u{4f1}\u{4f3}\x03\x02\x02\x02\u{4f2}\u{4f4}\x05\u{a0}\x51\x02\
	\u{4f3}\u{4f2}\x03\x02\x02\x02\u{4f3}\u{4f4}\x03\x02\x02\x02\u{4f4}\u{4f5}\
	\x03\x02\x02\x02\u{4f5}\u{4f6}\x07\x4f\x02\x02\u{4f6}\u{b9}\x03\x02\x02\
	\x02\u{4f7}\u{4f8}\x05\x06\x04\x02\u{4f8}\u{bb}\x03\x02\x02\x02\u{4f9}\u{4fb}\
	\x07\x50\x02\x02\u{4fa}\u{4fc}\x05\u{be}\x60\x02\u{4fb}\u{4fa}\x03\x02\x02\
	\x02\u{4fb}\u{4fc}\x03\x02\x02\x02\u{4fc}\u{4fe}\x03\x02\x02\x02\u{4fd}\
	\u{4ff}\x05\u{118}\u{8d}\x02\u{4fe}\u{4fd}\x03\x02\x02\x02\u{4fe}\u{4ff}\
	\x03\x02\x02\x02\u{4ff}\u{500}\x03\x02\x02\x02\u{500}\u{501}\x07\x51\x02\
	\x02\u{501}\u{bd}\x03\x02\x02\x02\u{502}\u{504}\x05\x2a\x16\x02\u{503}\u{502}\
	\x03\x02\x02\x02\u{503}\u{504}\x03\x02\x02\x02\u{504}\u{505}\x03\x02\x02\
	\x02\u{505}\u{506}\x09\x06\x02\x02\u{506}\u{508}\x07\x4e\x02\x02\u{507}\
	\u{509}\x05\u{1a8}\u{d5}\x02\u{508}\u{507}\x03\x02\x02\x02\u{508}\u{509}\
	\x03\x02\x02\x02\u{509}\u{50a}\x03\x02\x02\x02\u{50a}\u{50b}\x07\x4f\x02\
	\x02\u{50b}\u{51d}\x07\x54\x02\x02\u{50c}\u{50f}\x05\x3c\x1f\x02\u{50d}\
	\u{50f}\x05\u{188}\u{c5}\x02\u{50e}\u{50c}\x03\x02\x02\x02\u{50e}\u{50d}\
	\x03\x02\x02\x02\u{50f}\u{510}\x03\x02\x02\x02\u{510}\u{512}\x07\x56\x02\
	\x02\u{511}\u{513}\x05\x2a\x16\x02\u{512}\u{511}\x03\x02\x02\x02\u{512}\
	\u{513}\x03\x02\x02\x02\u{513}\u{514}\x03\x02\x02\x02\u{514}\u{515}\x07\
	\x3b\x02\x02\u{515}\u{517}\x07\x4e\x02\x02\u{516}\u{518}\x05\u{1a8}\u{d5}\
	\x02\u{517}\u{516}\x03\x02\x02\x02\u{517}\u{518}\x03\x02\x02\x02\u{518}\
	\u{519}\x03\x02\x02\x02\u{519}\u{51a}\x07\x4f\x02\x02\u{51a}\u{51b}\x07\
	\x54\x02\x02\u{51b}\u{51d}\x03\x02\x02\x02\u{51c}\u{503}\x03\x02\x02\x02\
	\u{51c}\u{50e}\x03\x02\x02\x02\u{51d}\u{bf}\x03\x02\x02\x02\u{51e}\u{520}\
	\x05\x62\x32\x02\u{51f}\u{51e}\x03\x02\x02\x02\u{520}\u{523}\x03\x02\x02\
	\x02\u{521}\u{51f}\x03\x02\x02\x02\u{521}\u{522}\x03\x02\x02\x02\u{522}\
	\u{524}\x03\x02\x02\x02\u{523}\u{521}\x03\x02\x02\x02\u{524}\u{525}\x07\
	\x23\x02\x02\u{525}\u{527}\x05\x06\x04\x02\u{526}\u{528}\x05\x6a\x36\x02\
	\u{527}\u{526}\x03\x02\x02\x02\u{527}\u{528}\x03\x02\x02\x02\u{528}\u{529}\
	\x03\x02\x02\x02\u{529}\u{52a}\x05\u{c2}\x62\x02\u{52a}\u{c1}\x03\x02\x02\
	\x02\u{52b}\u{52d}\x07\x50\x02\x02\u{52c}\u{52e}\x05\u{c4}\x63\x02\u{52d}\
	\u{52c}\x03\x02\x02\x02\u{52d}\u{52e}\x03\x02\x02\x02\u{52e}\u{530}\x03\
	\x02\x02\x02\u{52f}\u{531}\x07\x55\x02\x02\u{530}\u{52f}\x03\x02\x02\x02\
	\u{530}\u{531}\x03\x02\x02\x02\u{531}\u{533}\x03\x02\x02\x02\u{532}\u{534}\
	\x05\u{ca}\x66\x02\u{533}\u{532}\x03\x02\x02\x02\u{533}\u{534}\x03\x02\x02\
	\x02\u{534}\u{535}\x03\x02\x02\x02\u{535}\u{536}\x07\x51\x02\x02\u{536}\
	\u{c3}\x03\x02\x02\x02\u{537}\u{53c}\x05\u{c6}\x64\x02\u{538}\u{539}\x07\
	\x55\x02\x02\u{539}\u{53b}\x05\u{c6}\x64\x02\u{53a}\u{538}\x03\x02\x02\x02\
	\u{53b}\u{53e}\x03\x02\x02\x02\u{53c}\u{53a}\x03\x02\x02\x02\u{53c}\u{53d}\
	\x03\x02\x02\x02\u{53d}\u{c5}\x03\x02\x02\x02\u{53e}\u{53c}\x03\x02\x02\
	\x02\u{53f}\u{541}\x05\u{c8}\x65\x02\u{540}\u{53f}\x03\x02\x02\x02\u{541}\
	\u{544}\x03\x02\x02\x02\u{542}\u{540}\x03\x02\x02\x02\u{542}\u{543}\x03\
	\x02\x02\x02\u{543}\u{545}\x03\x02\x02\x02\u{544}\u{542}\x03\x02\x02\x02\
	\u{545}\u{54b}\x07\x7d\x02\x02\u{546}\u{548}\x07\x4e\x02\x02\u{547}\u{549}\
	\x05\u{1a8}\u{d5}\x02\u{548}\u{547}\x03\x02\x02\x02\u{548}\u{549}\x03\x02\
	\x02\x02\u{549}\u{54a}\x03\x02\x02\x02\u{54a}\u{54c}\x07\x4f\x02\x02\u{54b}\
	\u{546}\x03\x02\x02\x02\u{54b}\u{54c}\x03\x02\x02\x02\u{54c}\u{54e}\x03\
	\x02\x02\x02\u{54d}\u{54f}\x05\x70\x39\x02\u{54e}\u{54d}\x03\x02\x02\x02\
	\u{54e}\u{54f}\x03\x02\x02\x02\u{54f}\u{c7}\x03\x02\x02\x02\u{550}\u{551}\
	\x05\u{100}\u{81}\x02\u{551}\u{c9}\x03\x02\x02\x02\u{552}\u{556}\x07\x54\
	\x02\x02\u{553}\u{555}\x05\x72\x3a\x02\u{554}\u{553}\x03\x02\x02\x02\u{555}\
	\u{558}\x03\x02\x02\x02\u{556}\u{554}\x03\x02\x02\x02\u{556}\u{557}\x03\
	\x02\x02\x02\u{557}\u{cb}\x03\x02\x02\x02\u{558}\u{556}\x03\x02\x02\x02\
	\u{559}\u{55b}\x05\x62\x32\x02\u{55a}\u{559}\x03\x02\x02\x02\u{55b}\u{55e}\
	\x03\x02\x02\x02\u{55c}\u{55a}\x03\x02\x02\x02\u{55c}\u{55d}\x03\x02\x02\
	\x02\u{55d}\u{55f}\x03\x02\x02\x02\u{55e}\u{55c}\x03\x02\x02\x02\u{55f}\
	\u{560}\x07\x0b\x02\x02\u{560}\u{562}\x05\x06\x04\x02\u{561}\u{563}\x05\
	\x64\x33\x02\u{562}\u{561}\x03\x02\x02\x02\u{562}\u{563}\x03\x02\x02\x02\
	\u{563}\u{564}\x03\x02\x02\x02\u{564}\u{566}\x05\u{ce}\x68\x02\u{565}\u{567}\
	\x05\x6a\x36\x02\u{566}\u{565}\x03\x02\x02\x02\u{566}\u{567}\x03\x02\x02\
	\x02\u{567}\u{568}\x03\x02\x02\x02\u{568}\u{569}\x05\u{d8}\x6d\x02\u{569}\
	\u{cd}\x03\x02\x02\x02\u{56a}\u{56c}\x07\x4e\x02\x02\u{56b}\u{56d}\x05\u{d0}\
	\x69\x02\u{56c}\u{56b}\x03\x02\x02\x02\u{56c}\u{56d}\x03\x02\x02\x02\u{56d}\
	\u{56e}\x03\x02\x02\x02\u{56e}\u{56f}\x07\x4f\x02\x02\u{56f}\u{cf}\x03\x02\
	\x02\x02\u{570}\u{575}\x05\u{d2}\x6a\x02\u{571}\u{572}\x07\x55\x02\x02\u{572}\
	\u{574}\x05\u{d2}\x6a\x02\u{573}\u{571}\x03\x02\x02\x02\u{574}\u{577}\x03\
	\x02\x02\x02\u{575}\u{573}\x03\x02\x02\x02\u{575}\u{576}\x03\x02\x02\x02\
	\u{576}\u{d1}\x03\x02\x02\x02\u{577}\u{575}\x03\x02\x02\x02\u{578}\u{57a}\
	\x05\u{d6}\x6c\x02\u{579}\u{578}\x03\x02\x02\x02\u{57a}\u{57d}\x03\x02\x02\
	\x02\u{57b}\u{579}\x03\x02\x02\x02\u{57b}\u{57c}\x03\x02\x02\x02\u{57c}\
	\u{57e}\x03\x02\x02\x02\u{57d}\u{57b}\x03\x02\x02\x02\u{57e}\u{57f}\x05\
	\u{82}\x42\x02\u{57f}\u{580}\x07\x7d\x02\x02\u{580}\u{583}\x03\x02\x02\x02\
	\u{581}\u{583}\x05\u{d4}\x6b\x02\u{582}\u{57b}\x03\x02\x02\x02\u{582}\u{581}\
	\x03\x02\x02\x02\u{583}\u{d3}\x03\x02\x02\x02\u{584}\u{586}\x05\u{d6}\x6c\
	\x02\u{585}\u{584}\x03\x02\x02\x02\u{586}\u{589}\x03\x02\x02\x02\u{587}\
	\u{585}\x03\x02\x02\x02\u{587}\u{588}\x03\x02\x02\x02\u{588}\u{58a}\x03\
	\x02\x02\x02\u{589}\u{587}\x03\x02\x02\x02\u{58a}\u{58e}\x05\u{82}\x42\x02\
	\u{58b}\u{58d}\x05\u{100}\u{81}\x02\u{58c}\u{58b}\x03\x02\x02\x02\u{58d}\
	\u{590}\x03\x02\x02\x02\u{58e}\u{58c}\x03\x02\x02\x02\u{58e}\u{58f}\x03\
	\x02\x02\x02\u{58f}\u{591}\x03\x02\x02\x02\u{590}\u{58e}\x03\x02\x02\x02\
	\u{591}\u{592}\x07\x57\x02\x02\u{592}\u{593}\x07\x7d\x02\x02\u{593}\u{d5}\
	\x03\x02\x02\x02\u{594}\u{595}\x05\u{100}\u{81}\x02\u{595}\u{d7}\x03\x02\
	\x02\x02\u{596}\u{59a}\x07\x50\x02\x02\u{597}\u{599}\x05\u{da}\x6e\x02\u{598}\
	\u{597}\x03\x02\x02\x02\u{599}\u{59c}\x03\x02\x02\x02\u{59a}\u{598}\x03\
	\x02\x02\x02\u{59a}\u{59b}\x03\x02\x02\x02\u{59b}\u{59d}\x03\x02\x02\x02\
	\u{59c}\u{59a}\x03\x02\x02\x02\u{59d}\u{59e}\x07\x51\x02\x02\u{59e}\u{d9}\
	\x03\x02\x02\x02\u{59f}\u{5a2}\x05\x72\x3a\x02\u{5a0}\u{5a2}\x05\u{dc}\x6f\
	\x02\u{5a1}\u{59f}\x03\x02\x02\x02\u{5a1}\u{5a0}\x03\x02\x02\x02\u{5a2}\
	\u{db}\x03\x02\x02\x02\u{5a3}\u{5a5}\x05\u{b6}\x5c\x02\u{5a4}\u{5a3}\x03\
	\x02\x02\x02\u{5a5}\u{5a8}\x03\x02\x02\x02\u{5a6}\u{5a4}\x03\x02\x02\x02\
	\u{5a6}\u{5a7}\x03\x02\x02\x02\u{5a7}\u{5a9}\x03\x02\x02\x02\u{5a8}\u{5a6}\
	\x03\x02\x02\x02\u{5a9}\u{5aa}\x05\u{ba}\x5e\x02\u{5aa}\u{5ab}\x05\u{bc}\
	\x5f\x02\u{5ab}\u{dd}\x03\x02\x02\x02\u{5ac}\u{5af}\x05\u{e0}\x71\x02\u{5ad}\
	\u{5af}\x05\u{f4}\x7b\x02\u{5ae}\u{5ac}\x03\x02\x02\x02\u{5ae}\u{5ad}\x03\
	\x02\x02\x02\u{5af}\u{df}\x03\x02\x02\x02\u{5b0}\u{5b2}\x05\u{e2}\x72\x02\
	\u{5b1}\u{5b0}\x03\x02\x02\x02\u{5b2}\u{5b5}\x03\x02\x02\x02\u{5b3}\u{5b1}\
	\x03\x02\x02\x02\u{5b3}\u{5b4}\x03\x02\x02\x02\u{5b4}\u{5b6}\x03\x02\x02\
	\x02\u{5b5}\u{5b3}\x03\x02\x02\x02\u{5b6}\u{5b7}\x07\x2f\x02\x02\u{5b7}\
	\u{5b9}\x05\x06\x04\x02\u{5b8}\u{5ba}\x05\x64\x33\x02\u{5b9}\u{5b8}\x03\
	\x02\x02\x02\u{5b9}\u{5ba}\x03\x02\x02\x02\u{5ba}\u{5bc}\x03\x02\x02\x02\
	\u{5bb}\u{5bd}\x05\u{e4}\x73\x02\u{5bc}\u{5bb}\x03\x02\x02\x02\u{5bc}\u{5bd}\
	\x03\x02\x02\x02\u{5bd}\u{5bf}\x03\x02\x02\x02\u{5be}\u{5c0}\x05\u{e6}\x74\
	\x02\u{5bf}\u{5be}\x03\x02\x02\x02\u{5bf}\u{5c0}\x03\x02\x02\x02\u{5c0}\
	\u{5c1}\x03\x02\x02\x02\u{5c1}\u{5c2}\x05\u{e8}\x75\x02\u{5c2}\u{e1}\x03\
	\x02\x02\x02\u{5c3}\u{5cd}\x05\u{100}\u{81}\x02\u{5c4}\u{5cd}\x07\x36\x02\
	\x02\u{5c5}\u{5cd}\x07\x35\x02\x02\u{5c6}\u{5cd}\x07\x34\x02\x02\u{5c7}\
	\u{5cd}\x07\x14\x02\x02\u{5c8}\u{5cd}\x07\x39\x02\x02\u{5c9}\u{5cd}\x07\
	\x0d\x02\x02\u{5ca}\u{5cd}\x07\x05\x02\x02\u{5cb}\u{5cd}\x07\x3a\x02\x02\
	\u{5cc}\u{5c3}\x03\x02\x02\x02\u{5cc}\u{5c4}\x03\x02\x02\x02\u{5cc}\u{5c5}\
	\x03\x02\x02\x02\u{5cc}\u{5c6}\x03\x02\x02\x02\u{5cc}\u{5c7}\x03\x02\x02\
	\x02\u{5cc}\u{5c8}\x03\x02\x02\x02\u{5cc}\u{5c9}\x03\x02\x02\x02\u{5cc}\
	\u{5ca}\x03\x02\x02\x02\u{5cc}\u{5cb}\x03\x02\x02\x02\u{5cd}\u{e3}\x03\x02\
	\x02\x02\u{5ce}\u{5cf}\x07\x24\x02\x02\u{5cf}\u{5d0}\x05\x6c\x37\x02\u{5d0}\
	\u{e5}\x03\x02\x02\x02\u{5d1}\u{5d2}\x07\x09\x02\x02\u{5d2}\u{5d7}\x05\x38\
	\x1d\x02\u{5d3}\u{5d4}\x07\x55\x02\x02\u{5d4}\u{5d6}\x05\x38\x1d\x02\u{5d5}\
	\u{5d3}\x03\x02\x02\x02\u{5d6}\u{5d9}\x03\x02\x02\x02\u{5d7}\u{5d5}\x03\
	\x02\x02\x02\u{5d7}\u{5d8}\x03\x02\x02\x02\u{5d8}\u{e7}\x03\x02\x02\x02\
	\u{5d9}\u{5d7}\x03\x02\x02\x02\u{5da}\u{5de}\x07\x50\x02\x02\u{5db}\u{5dd}\
	\x05\u{ea}\x76\x02\u{5dc}\u{5db}\x03\x02\x02\x02\u{5dd}\u{5e0}\x03\x02\x02\
	\x02\u{5de}\u{5dc}\x03\x02\x02\x02\u{5de}\u{5df}\x03\x02\x02\x02\u{5df}\
	\u{5e1}\x03\x02\x02\x02\u{5e0}\u{5de}\x03\x02\x02\x02\u{5e1}\u{5e2}\x07\
	\x51\x02\x02\u{5e2}\u{e9}\x03\x02\x02\x02\u{5e3}\u{5e9}\x05\u{ec}\x77\x02\
	\u{5e4}\u{5e9}\x05\u{f0}\x79\x02\u{5e5}\u{5e9}\x05\x5e\x30\x02\u{5e6}\u{5e9}\
	\x05\u{de}\x70\x02\u{5e7}\u{5e9}\x07\x54\x02\x02\u{5e8}\u{5e3}\x03\x02\x02\
	\x02\u{5e8}\u{5e4}\x03\x02\x02\x02\u{5e8}\u{5e5}\x03\x02\x02\x02\u{5e8}\
	\u{5e6}\x03\x02\x02\x02\u{5e8}\u{5e7}\x03\x02\x02\x02\u{5e9}\u{eb}\x03\x02\
	\x02\x02\u{5ea}\u{5ec}\x05\u{ee}\x78\x02\u{5eb}\u{5ea}\x03\x02\x02\x02\u{5ec}\
	\u{5ef}\x03\x02\x02\x02\u{5ed}\u{5eb}\x03\x02\x02\x02\u{5ed}\u{5ee}\x03\
	\x02\x02\x02\u{5ee}\u{5f0}\x03\x02\x02\x02\u{5ef}\u{5ed}\x03\x02\x02\x02\
	\u{5f0}\u{5f1}\x05\u{82}\x42\x02\u{5f1}\u{5f2}\x05\x7a\x3e\x02\u{5f2}\u{5f3}\
	\x07\x54\x02\x02\u{5f3}\u{ed}\x03\x02\x02\x02\u{5f4}\u{5f9}\x05\u{100}\u{81}\
	\x02\u{5f5}\u{5f9}\x07\x36\x02\x02\u{5f6}\u{5f9}\x07\x39\x02\x02\u{5f7}\
	\u{5f9}\x07\x25\x02\x02\u{5f8}\u{5f4}\x03\x02\x02\x02\u{5f8}\u{5f5}\x03\
	\x02\x02\x02\u{5f8}\u{5f6}\x03\x02\x02\x02\u{5f8}\u{5f7}\x03\x02\x02\x02\
	\u{5f9}\u{ef}\x03\x02\x02\x02\u{5fa}\u{5fc}\x05\u{f2}\x7a\x02\u{5fb}\u{5fa}\
	\x03\x02\x02\x02\u{5fc}\u{5ff}\x03\x02\x02\x02\u{5fd}\u{5fb}\x03\x02\x02\
	\x02\u{5fd}\u{5fe}\x03\x02\x02\x02\u{5fe}\u{600}\x03\x02\x02\x02\u{5ff}\
	\u{5fd}\x03\x02\x02\x02\u{600}\u{601}\x05\u{98}\x4d\x02\u{601}\u{602}\x05\
	\u{ae}\x58\x02\u{602}\u{f1}\x03\x02\x02\x02\u{603}\u{60b}\x05\u{100}\u{81}\
	\x02\u{604}\u{60b}\x07\x36\x02\x02\u{605}\u{60b}\x07\x34\x02\x02\u{606}\
	\u{60b}\x07\x14\x02\x02\u{607}\u{60b}\x07\x1f\x02\x02\u{608}\u{60b}\x07\
	\x39\x02\x02\u{609}\u{60b}\x07\x3a\x02\x02\u{60a}\u{603}\x03\x02\x02\x02\
	\u{60a}\u{604}\x03\x02\x02\x02\u{60a}\u{605}\x03\x02\x02\x02\u{60a}\u{606}\
	\x03\x02\x02\x02\u{60a}\u{607}\x03\x02\x02\x02\u{60a}\u{608}\x03\x02\x02\
	\x02\u{60a}\u{609}\x03\x02\x02\x02\u{60b}\u{f3}\x03\x02\x02\x02\u{60c}\u{60e}\
	\x05\u{e2}\x72\x02\u{60d}\u{60c}\x03\x02\x02\x02\u{60e}\u{611}\x03\x02\x02\
	\x02\u{60f}\u{60d}\x03\x02\x02\x02\u{60f}\u{610}\x03\x02\x02\x02\u{610}\
	\u{612}\x03\x02\x02\x02\u{611}\u{60f}\x03\x02\x02\x02\u{612}\u{613}\x07\
	\x58\x02\x02\u{613}\u{614}\x07\x2f\x02\x02\u{614}\u{615}\x05\x06\x04\x02\
	\u{615}\u{616}\x05\u{f6}\x7c\x02\u{616}\u{f5}\x03\x02\x02\x02\u{617}\u{61b}\
	\x07\x50\x02\x02\u{618}\u{61a}\x05\u{f8}\x7d\x02\u{619}\u{618}\x03\x02\x02\
	\x02\u{61a}\u{61d}\x03\x02\x02\x02\u{61b}\u{619}\x03\x02\x02\x02\u{61b}\
	\u{61c}\x03\x02\x02\x02\u{61c}\u{61e}\x03\x02\x02\x02\u{61d}\u{61b}\x03\
	\x02\x02\x02\u{61e}\u{61f}\x07\x51\x02\x02\u{61f}\u{f7}\x03\x02\x02\x02\
	\u{620}\u{626}\x05\u{fa}\x7e\x02\u{621}\u{626}\x05\u{ec}\x77\x02\u{622}\
	\u{626}\x05\x5e\x30\x02\u{623}\u{626}\x05\u{de}\x70\x02\u{624}\u{626}\x07\
	\x54\x02\x02\u{625}\u{620}\x03\x02\x02\x02\u{625}\u{621}\x03\x02\x02\x02\
	\u{625}\u{622}\x03\x02\x02\x02\u{625}\u{623}\x03\x02\x02\x02\u{625}\u{624}\
	\x03\x02\x02\x02\u{626}\u{f9}\x03\x02\x02\x02\u{627}\u{629}\x05\u{fc}\x7f\
	\x02\u{628}\u{627}\x03\x02\x02\x02\u{629}\u{62c}\x03\x02\x02\x02\u{62a}\
	\u{628}\x03\x02\x02\x02\u{62a}\u{62b}\x03\x02\x02\x02\u{62b}\u{62d}\x03\
	\x02\x02\x02\u{62c}\u{62a}\x03\x02\x02\x02\u{62d}\u{62e}\x05\u{82}\x42\x02\
	\u{62e}\u{62f}\x07\x7d\x02\x02\u{62f}\u{630}\x07\x4e\x02\x02\u{630}\u{632}\
	\x07\x4f\x02\x02\u{631}\u{633}\x05\x20\x11\x02\u{632}\u{631}\x03\x02\x02\
	\x02\u{632}\u{633}\x03\x02\x02\x02\u{633}\u{635}\x03\x02\x02\x02\u{634}\
	\u{636}\x05\u{fe}\u{80}\x02\u{635}\u{634}\x03\x02\x02\x02\u{635}\u{636}\
	\x03\x02\x02\x02\u{636}\u{637}\x03\x02\x02\x02\u{637}\u{638}\x07\x54\x02\
	\x02\u{638}\u{fb}\x03\x02\x02\x02\u{639}\u{63d}\x05\u{100}\u{81}\x02\u{63a}\
	\u{63d}\x07\x36\x02\x02\u{63b}\u{63d}\x07\x14\x02\x02\u{63c}\u{639}\x03\
	\x02\x02\x02\u{63c}\u{63a}\x03\x02\x02\x02\u{63c}\u{63b}\x03\x02\x02\x02\
	\u{63d}\u{fd}\x03\x02\x02\x02\u{63e}\u{63f}\x07\x1f\x02\x02\u{63f}\u{640}\
	\x05\u{108}\u{85}\x02\u{640}\u{ff}\x03\x02\x02\x02\u{641}\u{645}\x05\u{102}\
	\u{82}\x02\u{642}\u{645}\x05\u{10e}\u{88}\x02\u{643}\u{645}\x05\u{110}\u{89}\
	\x02\u{644}\u{641}\x03\x02\x02\x02\u{644}\u{642}\x03\x02\x02\x02\u{644}\
	\u{643}\x03\x02\x02\x02\u{645}\u{101}\x03\x02\x02\x02\u{646}\u{647}\x07\
	\x58\x02\x02\u{647}\u{648}\x05\x38\x1d\x02\u{648}\u{64a}\x07\x4e\x02\x02\
	\u{649}\u{64b}\x05\u{104}\u{83}\x02\u{64a}\u{649}\x03\x02\x02\x02\u{64a}\
	\u{64b}\x03\x02\x02\x02\u{64b}\u{64c}\x03\x02\x02\x02\u{64c}\u{64d}\x07\
	\x4f\x02\x02\u{64d}\u{103}\x03\x02\x02\x02\u{64e}\u{653}\x05\u{106}\u{84}\
	\x02\u{64f}\u{650}\x07\x55\x02\x02\u{650}\u{652}\x05\u{106}\u{84}\x02\u{651}\
	\u{64f}\x03\x02\x02\x02\u{652}\u{655}\x03\x02\x02\x02\u{653}\u{651}\x03\
	\x02\x02\x02\u{653}\u{654}\x03\x02\x02\x02\u{654}\u{105}\x03\x02\x02\x02\
	\u{655}\u{653}\x03\x02\x02\x02\u{656}\u{657}\x07\x7d\x02\x02\u{657}\u{658}\
	\x07\x5a\x02\x02\u{658}\u{659}\x05\u{108}\u{85}\x02\u{659}\u{107}\x03\x02\
	\x02\x02\u{65a}\u{65e}\x05\u{1d2}\u{ea}\x02\u{65b}\u{65e}\x05\u{10a}\u{86}\
	\x02\u{65c}\u{65e}\x05\u{100}\u{81}\x02\u{65d}\u{65a}\x03\x02\x02\x02\u{65d}\
	\u{65b}\x03\x02\x02\x02\u{65d}\u{65c}\x03\x02\x02\x02\u{65e}\u{109}\x03\
	\x02\x02\x02\u{65f}\u{661}\x07\x50\x02\x02\u{660}\u{662}\x05\u{10c}\u{87}\
	\x02\u{661}\u{660}\x03\x02\x02\x02\u{661}\u{662}\x03\x02\x02\x02\u{662}\
	\u{664}\x03\x02\x02\x02\u{663}\u{665}\x07\x55\x02\x02\u{664}\u{663}\x03\
	\x02\x02\x02\u{664}\u{665}\x03\x02\x02\x02\u{665}\u{666}\x03\x02\x02\x02\
	\u{666}\u{667}\x07\x51\x02\x02\u{667}\u{10b}\x03\x02\x02\x02\u{668}\u{66d}\
	\x05\u{108}\u{85}\x02\u{669}\u{66a}\x07\x55\x02\x02\u{66a}\u{66c}\x05\u{108}\
	\u{85}\x02\u{66b}\u{669}\x03\x02\x02\x02\u{66c}\u{66f}\x03\x02\x02\x02\u{66d}\
	\u{66b}\x03\x02\x02\x02\u{66d}\u{66e}\x03\x02\x02\x02\u{66e}\u{10d}\x03\
	\x02\x02\x02\u{66f}\u{66d}\x03\x02\x02\x02\u{670}\u{671}\x07\x58\x02\x02\
	\u{671}\u{672}\x05\x38\x1d\x02\u{672}\u{10f}\x03\x02\x02\x02\u{673}\u{674}\
	\x07\x58\x02\x02\u{674}\u{675}\x05\x38\x1d\x02\u{675}\u{676}\x07\x4e\x02\
	\x02\u{676}\u{677}\x05\u{108}\u{85}\x02\u{677}\u{678}\x07\x4f\x02\x02\u{678}\
	\u{111}\x03\x02\x02\x02\u{679}\u{67b}\x07\x50\x02\x02\u{67a}\u{67c}\x05\
	\u{114}\u{8b}\x02\u{67b}\u{67a}\x03\x02\x02\x02\u{67b}\u{67c}\x03\x02\x02\
	\x02\u{67c}\u{67e}\x03\x02\x02\x02\u{67d}\u{67f}\x07\x55\x02\x02\u{67e}\
	\u{67d}\x03\x02\x02\x02\u{67e}\u{67f}\x03\x02\x02\x02\u{67f}\u{680}\x03\
	\x02\x02\x02\u{680}\u{681}\x07\x51\x02\x02\u{681}\u{113}\x03\x02\x02\x02\
	\u{682}\u{687}\x05\u{80}\x41\x02\u{683}\u{684}\x07\x55\x02\x02\u{684}\u{686}\
	\x05\u{80}\x41\x02\u{685}\u{683}\x03\x02\x02\x02\u{686}\u{689}\x03\x02\x02\
	\x02\u{687}\u{685}\x03\x02\x02\x02\u{687}\u{688}\x03\x02\x02\x02\u{688}\
	\u{115}\x03\x02\x02\x02\u{689}\u{687}\x03\x02\x02\x02\u{68a}\u{68c}\x07\
	\x50\x02\x02\u{68b}\u{68d}\x05\u{118}\u{8d}\x02\u{68c}\u{68b}\x03\x02\x02\
	\x02\u{68c}\u{68d}\x03\x02\x02\x02\u{68d}\u{68e}\x03\x02\x02\x02\u{68e}\
	\u{68f}\x07\x51\x02\x02\u{68f}\u{117}\x03\x02\x02\x02\u{690}\u{694}\x05\
	\u{11a}\u{8e}\x02\u{691}\u{693}\x05\u{11a}\u{8e}\x02\u{692}\u{691}\x03\x02\
	\x02\x02\u{693}\u{696}\x03\x02\x02\x02\u{694}\u{692}\x03\x02\x02\x02\u{694}\
	\u{695}\x03\x02\x02\x02\u{695}\u{119}\x03\x02\x02\x02\u{696}\u{694}\x03\
	\x02\x02\x02\u{697}\u{69b}\x05\u{11c}\u{8f}\x02\u{698}\u{69b}\x05\u{122}\
	\u{92}\x02\u{699}\u{69b}\x05\u{124}\u{93}\x02\u{69a}\u{697}\x03\x02\x02\
	\x02\u{69a}\u{698}\x03\x02\x02\x02\u{69a}\u{699}\x03\x02\x02\x02\u{69b}\
	\u{11b}\x03\x02\x02\x02\u{69c}\u{69f}\x05\x5e\x30\x02\u{69d}\u{69f}\x05\
	\u{e0}\x71\x02\u{69e}\u{69c}\x03\x02\x02\x02\u{69e}\u{69d}\x03\x02\x02\x02\
	\u{69f}\u{11d}\x03\x02\x02\x02\u{6a0}\u{6a2}\x05\u{a6}\x54\x02\u{6a1}\u{6a0}\
	\x03\x02\x02\x02\u{6a2}\u{6a5}\x03\x02\x02\x02\u{6a3}\u{6a1}\x03\x02\x02\
	\x02\u{6a3}\u{6a4}\x03\x02\x02\x02\u{6a4}\u{6a6}\x03\x02\x02\x02\u{6a5}\
	\u{6a3}\x03\x02\x02\x02\u{6a6}\u{6a8}\x05\u{120}\u{91}\x02\u{6a7}\u{6a9}\
	\x05\x7a\x3e\x02\u{6a8}\u{6a7}\x03\x02\x02\x02\u{6a8}\u{6a9}\x03\x02\x02\
	\x02\u{6a9}\u{11f}\x03\x02\x02\x02\u{6aa}\u{6ad}\x05\u{82}\x42\x02\u{6ab}\
	\u{6ad}\x07\x11\x02\x02\u{6ac}\u{6aa}\x03\x02\x02\x02\u{6ac}\u{6ab}\x03\
	\x02\x02\x02\u{6ad}\u{121}\x03\x02\x02\x02\u{6ae}\u{6af}\x05\u{11e}\u{90}\
	\x02\u{6af}\u{6b0}\x07\x54\x02\x02\u{6b0}\u{123}\x03\x02\x02\x02\u{6b1}\
	\u{6b8}\x05\u{128}\u{95}\x02\u{6b2}\u{6b8}\x05\u{12c}\u{97}\x02\u{6b3}\u{6b8}\
	\x05\u{134}\u{9b}\x02\u{6b4}\u{6b8}\x05\u{136}\u{9c}\x02\u{6b5}\u{6b8}\x05\
	\u{148}\u{a5}\x02\u{6b6}\u{6b8}\x05\u{14e}\u{a8}\x02\u{6b7}\u{6b1}\x03\x02\
	\x02\x02\u{6b7}\u{6b2}\x03\x02\x02\x02\u{6b7}\u{6b3}\x03\x02\x02\x02\u{6b7}\
	\u{6b4}\x03\x02\x02\x02\u{6b7}\u{6b5}\x03\x02\x02\x02\u{6b7}\u{6b6}\x03\
	\x02\x02\x02\u{6b8}\u{125}\x03\x02\x02\x02\u{6b9}\u{6bf}\x05\u{128}\u{95}\
	\x02\u{6ba}\u{6bf}\x05\u{12e}\u{98}\x02\u{6bb}\u{6bf}\x05\u{138}\u{9d}\x02\
	\u{6bc}\u{6bf}\x05\u{14a}\u{a6}\x02\u{6bd}\u{6bf}\x05\u{150}\u{a9}\x02\u{6be}\
	\u{6b9}\x03\x02\x02\x02\u{6be}\u{6ba}\x03\x02\x02\x02\u{6be}\u{6bb}\x03\
	\x02\x02\x02\u{6be}\u{6bc}\x03\x02\x02\x02\u{6be}\u{6bd}\x03\x02\x02\x02\
	\u{6bf}\u{127}\x03\x02\x02\x02\u{6c0}\u{6ce}\x05\u{116}\u{8c}\x02\u{6c1}\
	\u{6ce}\x05\u{12a}\u{96}\x02\u{6c2}\u{6ce}\x05\u{130}\u{99}\x02\u{6c3}\u{6ce}\
	\x05\u{13a}\u{9e}\x02\u{6c4}\u{6ce}\x05\u{13c}\u{9f}\x02\u{6c5}\u{6ce}\x05\
	\u{14c}\u{a7}\x02\u{6c6}\u{6ce}\x05\u{160}\u{b1}\x02\u{6c7}\u{6ce}\x05\u{162}\
	\u{b2}\x02\u{6c8}\u{6ce}\x05\u{164}\u{b3}\x02\u{6c9}\u{6ce}\x05\u{168}\u{b5}\
	\x02\u{6ca}\u{6ce}\x05\u{166}\u{b4}\x02\u{6cb}\u{6ce}\x05\u{16a}\u{b6}\x02\
	\u{6cc}\u{6ce}\x05\u{180}\u{c1}\x02\u{6cd}\u{6c0}\x03\x02\x02\x02\u{6cd}\
	\u{6c1}\x03\x02\x02\x02\u{6cd}\u{6c2}\x03\x02\x02\x02\u{6cd}\u{6c3}\x03\
	\x02\x02\x02\u{6cd}\u{6c4}\x03\x02\x02\x02\u{6cd}\u{6c5}\x03\x02\x02\x02\
	\u{6cd}\u{6c6}\x03\x02\x02\x02\u{6cd}\u{6c7}\x03\x02\x02\x02\u{6cd}\u{6c8}\
	\x03\x02\x02\x02\u{6cd}\u{6c9}\x03\x02\x02\x02\u{6cd}\u{6ca}\x03\x02\x02\
	\x02\u{6cd}\u{6cb}\x03\x02\x02\x02\u{6cd}\u{6cc}\x03\x02\x02\x02\u{6ce}\
	\u{129}\x03\x02\x02\x02\u{6cf}\u{6d0}\x07\x54\x02\x02\u{6d0}\u{12b}\x03\
	\x02\x02\x02\u{6d1}\u{6d2}\x07\x7d\x02\x02\u{6d2}\u{6d3}\x07\x60\x02\x02\
	\u{6d3}\u{6d4}\x05\u{124}\u{93}\x02\u{6d4}\u{12d}\x03\x02\x02\x02\u{6d5}\
	\u{6d6}\x07\x7d\x02\x02\u{6d6}\u{6d7}\x07\x60\x02\x02\u{6d7}\u{6d8}\x05\
	\u{126}\u{94}\x02\u{6d8}\u{12f}\x03\x02\x02\x02\u{6d9}\u{6da}\x05\u{132}\
	\u{9a}\x02\u{6da}\u{6db}\x07\x54\x02\x02\u{6db}\u{131}\x03\x02\x02\x02\u{6dc}\
	\u{6e4}\x05\u{1d6}\u{ec}\x02\u{6dd}\u{6e4}\x05\u{1b6}\u{dc}\x02\u{6de}\u{6e4}\
	\x05\u{1b8}\u{dd}\x02\u{6df}\u{6e4}\x05\u{1b0}\u{d9}\x02\u{6e0}\u{6e4}\x05\
	\u{1b2}\u{da}\x02\u{6e1}\u{6e4}\x05\u{1a6}\u{d4}\x02\u{6e2}\u{6e4}\x05\u{190}\
	\u{c9}\x02\u{6e3}\u{6dc}\x03\x02\x02\x02\u{6e3}\u{6dd}\x03\x02\x02\x02\u{6e3}\
	\u{6de}\x03\x02\x02\x02\u{6e3}\u{6df}\x03\x02\x02\x02\u{6e3}\u{6e0}\x03\
	\x02\x02\x02\u{6e3}\u{6e1}\x03\x02\x02\x02\u{6e3}\u{6e2}\x03\x02\x02\x02\
	\u{6e4}\u{133}\x03\x02\x02\x02\u{6e5}\u{6e6}\x07\x29\x02\x02\u{6e6}\u{6e7}\
	\x07\x4e\x02\x02\u{6e7}\u{6e8}\x05\u{186}\u{c4}\x02\u{6e8}\u{6e9}\x07\x4f\
	\x02\x02\u{6e9}\u{6ea}\x05\u{124}\u{93}\x02\u{6ea}\u{135}\x03\x02\x02\x02\
	\u{6eb}\u{6ec}\x07\x29\x02\x02\u{6ec}\u{6ed}\x07\x4e\x02\x02\u{6ed}\u{6ee}\
	\x05\u{186}\u{c4}\x02\u{6ee}\u{6ef}\x07\x4f\x02\x02\u{6ef}\u{6f0}\x05\u{126}\
	\u{94}\x02\u{6f0}\u{6f1}\x07\x22\x02\x02\u{6f1}\u{6f2}\x05\u{124}\u{93}\
	\x02\u{6f2}\u{137}\x03\x02\x02\x02\u{6f3}\u{6f4}\x07\x29\x02\x02\u{6f4}\
	\u{6f5}\x07\x4e\x02\x02\u{6f5}\u{6f6}\x05\u{186}\u{c4}\x02\u{6f6}\u{6f7}\
	\x07\x4f\x02\x02\u{6f7}\u{6f8}\x05\u{126}\u{94}\x02\u{6f8}\u{6f9}\x07\x22\
	\x02\x02\u{6f9}\u{6fa}\x05\u{126}\u{94}\x02\u{6fa}\u{139}\x03\x02\x02\x02\
	\u{6fb}\u{6fc}\x07\x15\x02\x02\u{6fc}\u{6ff}\x05\u{186}\u{c4}\x02\u{6fd}\
	\u{6fe}\x07\x60\x02\x02\u{6fe}\u{700}\x05\u{186}\u{c4}\x02\u{6ff}\u{6fd}\
	\x03\x02\x02\x02\u{6ff}\u{700}\x03\x02\x02\x02\u{700}\u{701}\x03\x02\x02\
	\x02\u{701}\u{702}\x07\x54\x02\x02\u{702}\u{13b}\x03\x02\x02\x02\u{703}\
	\u{704}\x07\x3c\x02\x02\u{704}\u{705}\x07\x4e\x02\x02\u{705}\u{706}\x05\
	\u{186}\u{c4}\x02\u{706}\u{707}\x07\x4f\x02\x02\u{707}\u{708}\x05\u{13e}\
	\u{a0}\x02\u{708}\u{13d}\x03\x02\x02\x02\u{709}\u{70a}\x07\x50\x02\x02\u{70a}\
	\u{70e}\x05\u{140}\u{a1}\x02\u{70b}\u{70d}\x05\u{140}\u{a1}\x02\u{70c}\u{70b}\
	\x03\x02\x02\x02\u{70d}\u{710}\x03\x02\x02\x02\u{70e}\u{70c}\x03\x02\x02\
	\x02\u{70e}\u{70f}\x03\x02\x02\x02\u{70f}\u{711}\x03\x02\x02\x02\u{710}\
	\u{70e}\x03\x02\x02\x02\u{711}\u{712}\x07\x51\x02\x02\u{712}\u{724}\x03\
	\x02\x02\x02\u{713}\u{717}\x07\x50\x02\x02\u{714}\u{716}\x05\u{142}\u{a2}\
	\x02\u{715}\u{714}\x03\x02\x02\x02\u{716}\u{719}\x03\x02\x02\x02\u{717}\
	\u{715}\x03\x02\x02\x02\u{717}\u{718}\x03\x02\x02\x02\u{718}\u{71f}\x03\
	\x02\x02\x02\u{719}\u{717}\x03\x02\x02\x02\u{71a}\u{71b}\x05\u{144}\u{a3}\
	\x02\u{71b}\u{71c}\x07\x60\x02\x02\u{71c}\u{71e}\x03\x02\x02\x02\u{71d}\
	\u{71a}\x03\x02\x02\x02\u{71e}\u{721}\x03\x02\x02\x02\u{71f}\u{71d}\x03\
	\x02\x02\x02\u{71f}\u{720}\x03\x02\x02\x02\u{720}\u{722}\x03\x02\x02\x02\
	\u{721}\u{71f}\x03\x02\x02\x02\u{722}\u{724}\x07\x51\x02\x02\u{723}\u{709}\
	\x03\x02\x02\x02\u{723}\u{713}\x03\x02\x02\x02\u{724}\u{13f}\x03\x02\x02\
	\x02\u{725}\u{726}\x05\u{144}\u{a3}\x02\u{726}\u{72c}\x07\x61\x02\x02\u{727}\
	\u{728}\x05\u{186}\u{c4}\x02\u{728}\u{729}\x07\x54\x02\x02\u{729}\u{72d}\
	\x03\x02\x02\x02\u{72a}\u{72d}\x05\u{116}\u{8c}\x02\u{72b}\u{72d}\x05\u{166}\
	\u{b4}\x02\u{72c}\u{727}\x03\x02\x02\x02\u{72c}\u{72a}\x03\x02\x02\x02\u{72c}\
	\u{72b}\x03\x02\x02\x02\u{72d}\u{141}\x03\x02\x02\x02\u{72e}\u{72f}\x05\
	\u{144}\u{a3}\x02\u{72f}\u{735}\x07\x60\x02\x02\u{730}\u{731}\x05\u{144}\
	\u{a3}\x02\u{731}\u{732}\x07\x60\x02\x02\u{732}\u{734}\x03\x02\x02\x02\u{733}\
	\u{730}\x03\x02\x02\x02\u{734}\u{737}\x03\x02\x02\x02\u{735}\u{733}\x03\
	\x02\x02\x02\u{735}\u{736}\x03\x02\x02\x02\u{736}\u{738}\x03\x02\x02\x02\
	\u{737}\u{735}\x03\x02\x02\x02\u{738}\u{739}\x05\u{118}\u{8d}\x02\u{739}\
	\u{143}\x03\x02\x02\x02\u{73a}\u{73b}\x07\x19\x02\x02\u{73b}\u{740}\x05\
	\u{146}\u{a4}\x02\u{73c}\u{73d}\x07\x55\x02\x02\u{73d}\u{73f}\x05\u{146}\
	\u{a4}\x02\u{73e}\u{73c}\x03\x02\x02\x02\u{73f}\u{742}\x03\x02\x02\x02\u{740}\
	\u{73e}\x03\x02\x02\x02\u{740}\u{741}\x03\x02\x02\x02\u{741}\u{745}\x03\
	\x02\x02\x02\u{742}\u{740}\x03\x02\x02\x02\u{743}\u{745}\x07\x1f\x02\x02\
	\u{744}\u{73a}\x03\x02\x02\x02\u{744}\u{743}\x03\x02\x02\x02\u{745}\u{145}\
	\x03\x02\x02\x02\u{746}\u{747}\x05\u{1d2}\u{ea}\x02\u{747}\u{147}\x03\x02\
	\x02\x02\u{748}\u{749}\x07\x45\x02\x02\u{749}\u{74a}\x07\x4e\x02\x02\u{74a}\
	\u{74b}\x05\u{186}\u{c4}\x02\u{74b}\u{74c}\x07\x4f\x02\x02\u{74c}\u{74d}\
	\x05\u{124}\u{93}\x02\u{74d}\u{149}\x03\x02\x02\x02\u{74e}\u{74f}\x07\x45\
	\x02\x02\u{74f}\u{750}\x07\x4e\x02\x02\u{750}\u{751}\x05\u{186}\u{c4}\x02\
	\u{751}\u{752}\x07\x4f\x02\x02\u{752}\u{753}\x05\u{126}\u{94}\x02\u{753}\
	\u{14b}\x03\x02\x02\x02\u{754}\u{755}\x07\x20\x02\x02\u{755}\u{756}\x05\
	\u{124}\u{93}\x02\u{756}\u{757}\x07\x45\x02\x02\u{757}\u{758}\x07\x4e\x02\
	\x02\u{758}\u{759}\x05\u{186}\u{c4}\x02\u{759}\u{75a}\x07\x4f\x02\x02\u{75a}\
	\u{75b}\x07\x54\x02\x02\u{75b}\u{14d}\x03\x02\x02\x02\u{75c}\u{75f}\x05\
	\u{152}\u{aa}\x02\u{75d}\u{75f}\x05\u{15c}\u{af}\x02\u{75e}\u{75c}\x03\x02\
	\x02\x02\u{75e}\u{75d}\x03\x02\x02\x02\u{75f}\u{14f}\x03\x02\x02\x02\u{760}\
	\u{763}\x05\u{154}\u{ab}\x02\u{761}\u{763}\x05\u{15e}\u{b0}\x02\u{762}\u{760}\
	\x03\x02\x02\x02\u{762}\u{761}\x03\x02\x02\x02\u{763}\u{151}\x03\x02\x02\
	\x02\u{764}\u{765}\x07\x28\x02\x02\u{765}\u{767}\x07\x4e\x02\x02\u{766}\
	\u{768}\x05\u{156}\u{ac}\x02\u{767}\u{766}\x03\x02\x02\x02\u{767}\u{768}\
	\x03\x02\x02\x02\u{768}\u{769}\x03\x02\x02\x02\u{769}\u{76b}\x07\x54\x02\
	\x02\u{76a}\u{76c}\x05\u{186}\u{c4}\x02\u{76b}\u{76a}\x03\x02\x02\x02\u{76b}\
	\u{76c}\x03\x02\x02\x02\u{76c}\u{76d}\x03\x02\x02\x02\u{76d}\u{76f}\x07\
	\x54\x02\x02\u{76e}\u{770}\x05\u{158}\u{ad}\x02\u{76f}\u{76e}\x03\x02\x02\
	\x02\u{76f}\u{770}\x03\x02\x02\x02\u{770}\u{771}\x03\x02\x02\x02\u{771}\
	\u{772}\x07\x4f\x02\x02\u{772}\u{773}\x05\u{124}\u{93}\x02\u{773}\u{153}\
	\x03\x02\x02\x02\u{774}\u{775}\x07\x28\x02\x02\u{775}\u{777}\x07\x4e\x02\
	\x02\u{776}\u{778}\x05\u{156}\u{ac}\x02\u{777}\u{776}\x03\x02\x02\x02\u{777}\
	\u{778}\x03\x02\x02\x02\u{778}\u{779}\x03\x02\x02\x02\u{779}\u{77b}\x07\
	\x54\x02\x02\u{77a}\u{77c}\x05\u{186}\u{c4}\x02\u{77b}\u{77a}\x03\x02\x02\
	\x02\u{77b}\u{77c}\x03\x02\x02\x02\u{77c}\u{77d}\x03\x02\x02\x02\u{77d}\
	\u{77f}\x07\x54\x02\x02\u{77e}\u{780}\x05\u{158}\u{ad}\x02\u{77f}\u{77e}\
	\x03\x02\x02\x02\u{77f}\u{780}\x03\x02\x02\x02\u{780}\u{781}\x03\x02\x02\
	\x02\u{781}\u{782}\x07\x4f\x02\x02\u{782}\u{783}\x05\u{126}\u{94}\x02\u{783}\
	\u{155}\x03\x02\x02\x02\u{784}\u{787}\x05\u{15a}\u{ae}\x02\u{785}\u{787}\
	\x05\u{11e}\u{90}\x02\u{786}\u{784}\x03\x02\x02\x02\u{786}\u{785}\x03\x02\
	\x02\x02\u{787}\u{157}\x03\x02\x02\x02\u{788}\u{789}\x05\u{15a}\u{ae}\x02\
	\u{789}\u{159}\x03\x02\x02\x02\u{78a}\u{78f}\x05\u{132}\u{9a}\x02\u{78b}\
	\u{78c}\x07\x55\x02\x02\u{78c}\u{78e}\x05\u{132}\u{9a}\x02\u{78d}\u{78b}\
	\x03\x02\x02\x02\u{78e}\u{791}\x03\x02\x02\x02\u{78f}\u{78d}\x03\x02\x02\
	\x02\u{78f}\u{790}\x03\x02\x02\x02\u{790}\u{15b}\x03\x02\x02\x02\u{791}\
	\u{78f}\x03\x02\x02\x02\u{792}\u{793}\x07\x28\x02\x02\u{793}\u{794}\x07\
	\x4e\x02\x02\u{794}\u{795}\x05\u{11e}\u{90}\x02\u{795}\u{796}\x07\x60\x02\
	\x02\u{796}\u{797}\x05\u{186}\u{c4}\x02\u{797}\u{798}\x07\x4f\x02\x02\u{798}\
	\u{799}\x05\u{124}\u{93}\x02\u{799}\u{15d}\x03\x02\x02\x02\u{79a}\u{79b}\
	\x07\x28\x02\x02\u{79b}\u{79c}\x07\x4e\x02\x02\u{79c}\u{79d}\x05\u{11e}\
	\u{90}\x02\u{79d}\u{79e}\x07\x60\x02\x02\u{79e}\u{79f}\x05\u{186}\u{c4}\
	\x02\u{79f}\u{7a0}\x07\x4f\x02\x02\u{7a0}\u{7a1}\x05\u{126}\u{94}\x02\u{7a1}\
	\u{15f}\x03\x02\x02\x02\u{7a2}\u{7a4}\x07\x17\x02\x02\u{7a3}\u{7a5}\x07\
	\x7d\x02\x02\u{7a4}\u{7a3}\x03\x02\x02\x02\u{7a4}\u{7a5}\x03\x02\x02\x02\
	\u{7a5}\u{7a6}\x03\x02\x02\x02\u{7a6}\u{7a7}\x07\x54\x02\x02\u{7a7}\u{161}\
	\x03\x02\x02\x02\u{7a8}\u{7aa}\x07\x1e\x02\x02\u{7a9}\u{7ab}\x07\x7d\x02\
	\x02\u{7aa}\u{7a9}\x03\x02\x02\x02\u{7aa}\u{7ab}\x03\x02\x02\x02\u{7ab}\
	\u{7ac}\x03\x02\x02\x02\u{7ac}\u{7ad}\x07\x54\x02\x02\u{7ad}\u{163}\x03\
	\x02\x02\x02\u{7ae}\u{7b0}\x07\x37\x02\x02\u{7af}\u{7b1}\x05\u{186}\u{c4}\
	\x02\u{7b0}\u{7af}\x03\x02\x02\x02\u{7b0}\u{7b1}\x03\x02\x02\x02\u{7b1}\
	\u{7b2}\x03\x02\x02\x02\u{7b2}\u{7b3}\x07\x54\x02\x02\u{7b3}\u{165}\x03\
	\x02\x02\x02\u{7b4}\u{7b5}\x07\x3f\x02\x02\u{7b5}\u{7b6}\x05\u{186}\u{c4}\
	\x02\u{7b6}\u{7b7}\x07\x54\x02\x02\u{7b7}\u{167}\x03\x02\x02\x02\u{7b8}\
	\u{7b9}\x07\x3d\x02\x02\u{7b9}\u{7ba}\x07\x4e\x02\x02\u{7ba}\u{7bb}\x05\
	\u{186}\u{c4}\x02\u{7bb}\u{7bc}\x07\x4f\x02\x02\u{7bc}\u{7bd}\x05\u{116}\
	\u{8c}\x02\u{7bd}\u{169}\x03\x02\x02\x02\u{7be}\u{7bf}\x07\x42\x02\x02\u{7bf}\
	\u{7c0}\x05\u{116}\u{8c}\x02\u{7c0}\u{7c1}\x05\u{16c}\u{b7}\x02\u{7c1}\u{7cf}\
	\x03\x02\x02\x02\u{7c2}\u{7c3}\x07\x42\x02\x02\u{7c3}\u{7c4}\x05\u{116}\
	\u{8c}\x02\u{7c4}\u{7c5}\x05\u{174}\u{bb}\x02\u{7c5}\u{7cf}\x03\x02\x02\
	\x02\u{7c6}\u{7c7}\x07\x42\x02\x02\u{7c7}\u{7c9}\x05\u{116}\u{8c}\x02\u{7c8}\
	\u{7ca}\x05\u{16c}\u{b7}\x02\u{7c9}\u{7c8}\x03\x02\x02\x02\u{7c9}\u{7ca}\
	\x03\x02\x02\x02\u{7ca}\u{7cb}\x03\x02\x02\x02\u{7cb}\u{7cc}\x05\u{174}\
	\u{bb}\x02\u{7cc}\u{7cf}\x03\x02\x02\x02\u{7cd}\u{7cf}\x05\u{176}\u{bc}\
	\x02\u{7ce}\u{7be}\x03\x02\x02\x02\u{7ce}\u{7c2}\x03\x02\x02\x02\u{7ce}\
	\u{7c6}\x03\x02\x02\x02\u{7ce}\u{7cd}\x03\x02\x02\x02\u{7cf}\u{16b}\x03\
	\x02\x02\x02\u{7d0}\u{7d4}\x05\u{16e}\u{b8}\x02\u{7d1}\u{7d3}\x05\u{16e}\
	\u{b8}\x02\u{7d2}\u{7d1}\x03\x02\x02\x02\u{7d3}\u{7d6}\x03\x02\x02\x02\u{7d4}\
	\u{7d2}\x03\x02\x02\x02\u{7d4}\u{7d5}\x03\x02\x02\x02\u{7d5}\u{16d}\x03\
	\x02\x02\x02\u{7d6}\u{7d4}\x03\x02\x02\x02\u{7d7}\u{7d8}\x07\x1a\x02\x02\
	\u{7d8}\u{7d9}\x07\x4e\x02\x02\u{7d9}\u{7da}\x05\u{170}\u{b9}\x02\u{7da}\
	\u{7db}\x07\x4f\x02\x02\u{7db}\u{7dc}\x05\u{116}\u{8c}\x02\u{7dc}\u{16f}\
	\x03\x02\x02\x02\u{7dd}\u{7df}\x05\u{a6}\x54\x02\u{7de}\u{7dd}\x03\x02\x02\
	\x02\u{7df}\u{7e2}\x03\x02\x02\x02\u{7e0}\u{7de}\x03\x02\x02\x02\u{7e0}\
	\u{7e1}\x03\x02\x02\x02\u{7e1}\u{7e3}\x03\x02\x02\x02\u{7e2}\u{7e0}\x03\
	\x02\x02\x02\u{7e3}\u{7e4}\x05\u{172}\u{ba}\x02\u{7e4}\u{7e5}\x05\x7e\x40\
	\x02\u{7e5}\u{171}\x03\x02\x02\x02\u{7e6}\u{7eb}\x05\u{8c}\x47\x02\u{7e7}\
	\u{7e8}\x07\x6f\x02\x02\u{7e8}\u{7ea}\x05\x18\x0d\x02\u{7e9}\u{7e7}\x03\
	\x02\x02\x02\u{7ea}\u{7ed}\x03\x02\x02\x02\u{7eb}\u{7e9}\x03\x02\x02\x02\
	\u{7eb}\u{7ec}\x03\x02\x02\x02\u{7ec}\u{173}\x03\x02\x02\x02\u{7ed}\u{7eb}\
	\x03\x02\x02\x02\u{7ee}\u{7ef}\x07\x26\x02\x02\u{7ef}\u{7f0}\x05\u{116}\
	\u{8c}\x02\u{7f0}\u{175}\x03\x02\x02\x02\u{7f1}\u{7f2}\x07\x42\x02\x02\u{7f2}\
	\u{7f3}\x05\u{178}\u{bd}\x02\u{7f3}\u{7f5}\x05\u{116}\u{8c}\x02\u{7f4}\u{7f6}\
	\x05\u{16c}\u{b7}\x02\u{7f5}\u{7f4}\x03\x02\x02\x02\u{7f5}\u{7f6}\x03\x02\
	\x02\x02\u{7f6}\u{7f8}\x03\x02\x02\x02\u{7f7}\u{7f9}\x05\u{174}\u{bb}\x02\
	\u{7f8}\u{7f7}\x03\x02\x02\x02\u{7f8}\u{7f9}\x03\x02\x02\x02\u{7f9}\u{177}\
	\x03\x02\x02\x02\u{7fa}\u{7fb}\x07\x4e\x02\x02\u{7fb}\u{7fd}\x05\u{17a}\
	\u{be}\x02\u{7fc}\u{7fe}\x07\x54\x02\x02\u{7fd}\u{7fc}\x03\x02\x02\x02\u{7fd}\
	\u{7fe}\x03\x02\x02\x02\u{7fe}\u{7ff}\x03\x02\x02\x02\u{7ff}\u{800}\x07\
	\x4f\x02\x02\u{800}\u{179}\x03\x02\x02\x02\u{801}\u{806}\x05\u{17c}\u{bf}\
	\x02\u{802}\u{803}\x07\x54\x02\x02\u{803}\u{805}\x05\u{17c}\u{bf}\x02\u{804}\
	\u{802}\x03\x02\x02\x02\u{805}\u{808}\x03\x02\x02\x02\u{806}\u{804}\x03\
	\x02\x02\x02\u{806}\u{807}\x03\x02\x02\x02\u{807}\u{17b}\x03\x02\x02\x02\
	\u{808}\u{806}\x03\x02\x02\x02\u{809}\u{80c}\x05\u{11e}\u{90}\x02\u{80a}\
	\u{80c}\x05\u{17e}\u{c0}\x02\u{80b}\u{809}\x03\x02\x02\x02\u{80b}\u{80a}\
	\x03\x02\x02\x02\u{80c}\u{17d}\x03\x02\x02\x02\u{80d}\u{810}\x05\x3c\x1f\
	\x02\u{80e}\u{810}\x05\u{1a4}\u{d3}\x02\u{80f}\u{80d}\x03\x02\x02\x02\u{80f}\
	\u{80e}\x03\x02\x02\x02\u{810}\u{17f}\x03\x02\x02\x02\u{811}\u{812}\x07\
	\x13\x02\x02\u{812}\u{813}\x05\u{186}\u{c4}\x02\u{813}\u{814}\x07\x54\x02\
	\x02\u{814}\u{181}\x03\x02\x02\x02\u{815}\u{816}\x05\u{184}\u{c3}\x02\u{816}\
	\u{183}\x03\x02\x02\x02\u{817}\u{818}\x05\u{11e}\u{90}\x02\u{818}\u{185}\
	\x03\x02\x02\x02\u{819}\u{81c}\x05\u{1dc}\u{ef}\x02\u{81a}\u{81c}\x05\u{1d4}\
	\u{eb}\x02\u{81b}\u{819}\x03\x02\x02\x02\u{81b}\u{81a}\x03\x02\x02\x02\u{81c}\
	\u{187}\x03\x02\x02\x02\u{81d}\u{820}\x05\u{18a}\u{c6}\x02\u{81e}\u{820}\
	\x05\u{198}\u{cd}\x02\u{81f}\u{81d}\x03\x02\x02\x02\u{81f}\u{81e}\x03\x02\
	\x02\x02\u{820}\u{189}\x03\x02\x02\x02\u{821}\u{823}\x05\x04\x03\x02\u{822}\
	\u{824}\x05\u{18c}\u{c7}\x02\u{823}\u{822}\x03\x02\x02\x02\u{823}\u{824}\
	\x03\x02\x02\x02\u{824}\u{8fb}\x03\x02\x02\x02\u{825}\u{827}\x05\u{18e}\
	\u{c8}\x02\u{826}\u{828}\x05\u{18c}\u{c7}\x02\u{827}\u{826}\x03\x02\x02\
	\x02\u{827}\u{828}\x03\x02\x02\x02\u{828}\u{8fb}\x03\x02\x02\x02\u{829}\
	\u{82b}\x07\x3e\x02\x02\u{82a}\u{82c}\x05\u{18c}\u{c7}\x02\u{82b}\u{82a}\
	\x03\x02\x02\x02\u{82b}\u{82c}\x03\x02\x02\x02\u{82c}\u{8fb}\x03\x02\x02\
	\x02\u{82d}\u{82e}\x05\x38\x1d\x02\u{82e}\u{82f}\x07\x56\x02\x02\u{82f}\
	\u{831}\x07\x3e\x02\x02\u{830}\u{832}\x05\u{18c}\u{c7}\x02\u{831}\u{830}\
	\x03\x02\x02\x02\u{831}\u{832}\x03\x02\x02\x02\u{832}\u{8fb}\x03\x02\x02\
	\x02\u{833}\u{834}\x07\x4e\x02\x02\u{834}\u{835}\x05\u{186}\u{c4}\x02\u{835}\
	\u{837}\x07\x4f\x02\x02\u{836}\u{838}\x05\u{18c}\u{c7}\x02\u{837}\u{836}\
	\x03\x02\x02\x02\u{837}\u{838}\x03\x02\x02\x02\u{838}\u{8fb}\x03\x02\x02\
	\x02\u{839}\u{83b}\x05\u{192}\u{ca}\x02\u{83a}\u{83c}\x05\u{18c}\u{c7}\x02\
	\u{83b}\u{83a}\x03\x02\x02\x02\u{83b}\u{83c}\x03\x02\x02\x02\u{83c}\u{8fb}\
	\x03\x02\x02\x02\u{83d}\u{83e}\x05\x3c\x1f\x02\u{83e}\u{83f}\x07\x56\x02\
	\x02\u{83f}\u{841}\x05\u{192}\u{ca}\x02\u{840}\u{842}\x05\u{18c}\u{c7}\x02\
	\u{841}\u{840}\x03\x02\x02\x02\u{841}\u{842}\x03\x02\x02\x02\u{842}\u{8fb}\
	\x03\x02\x02\x02\u{843}\u{844}\x05\u{198}\u{cd}\x02\u{844}\u{845}\x07\x56\
	\x02\x02\u{845}\u{847}\x05\u{192}\u{ca}\x02\u{846}\u{848}\x05\u{18c}\u{c7}\
	\x02\u{847}\u{846}\x03\x02\x02\x02\u{847}\u{848}\x03\x02\x02\x02\u{848}\
	\u{8fb}\x03\x02\x02\x02\u{849}\u{84a}\x05\u{198}\u{cd}\x02\u{84a}\u{84b}\
	\x07\x56\x02\x02\u{84b}\u{84d}\x07\x7d\x02\x02\u{84c}\u{84e}\x05\u{18c}\
	\u{c7}\x02\u{84d}\u{84c}\x03\x02\x02\x02\u{84d}\u{84e}\x03\x02\x02\x02\u{84e}\
	\u{8fb}\x03\x02\x02\x02\u{84f}\u{850}\x07\x3b\x02\x02\u{850}\u{851}\x07\
	\x56\x02\x02\u{851}\u{853}\x07\x7d\x02\x02\u{852}\u{854}\x05\u{18c}\u{c7}\
	\x02\u{853}\u{852}\x03\x02\x02\x02\u{853}\u{854}\x03\x02\x02\x02\u{854}\
	\u{8fb}\x03\x02\x02\x02\u{855}\u{856}\x05\x38\x1d\x02\u{856}\u{857}\x07\
	\x56\x02\x02\u{857}\u{858}\x07\x3b\x02\x02\u{858}\u{859}\x07\x56\x02\x02\
	\u{859}\u{85b}\x07\x7d\x02\x02\u{85a}\u{85c}\x05\u{18c}\u{c7}\x02\u{85b}\
	\u{85a}\x03\x02\x02\x02\u{85b}\u{85c}\x03\x02\x02\x02\u{85c}\u{8fb}\x03\
	\x02\x02\x02\u{85d}\u{85e}\x05\x3c\x1f\x02\u{85e}\u{85f}\x07\x52\x02\x02\
	\u{85f}\u{860}\x05\u{186}\u{c4}\x02\u{860}\u{862}\x07\x53\x02\x02\u{861}\
	\u{863}\x05\u{18c}\u{c7}\x02\u{862}\u{861}\x03\x02\x02\x02\u{862}\u{863}\
	\x03\x02\x02\x02\u{863}\u{8fb}\x03\x02\x02\x02\u{864}\u{865}\x05\u{19c}\
	\u{cf}\x02\u{865}\u{866}\x07\x52\x02\x02\u{866}\u{867}\x05\u{186}\u{c4}\
	\x02\u{867}\u{869}\x07\x53\x02\x02\u{868}\u{86a}\x05\u{18c}\u{c7}\x02\u{869}\
	\u{868}\x03\x02\x02\x02\u{869}\u{86a}\x03\x02\x02\x02\u{86a}\u{8fb}\x03\
	\x02\x02\x02\u{86b}\u{86c}\x05\x3e\x20\x02\u{86c}\u{86e}\x07\x4e\x02\x02\
	\u{86d}\u{86f}\x05\u{1a8}\u{d5}\x02\u{86e}\u{86d}\x03\x02\x02\x02\u{86e}\
	\u{86f}\x03\x02\x02\x02\u{86f}\u{870}\x03\x02\x02\x02\u{870}\u{872}\x07\
	\x4f\x02\x02\u{871}\u{873}\x05\u{18c}\u{c7}\x02\u{872}\u{871}\x03\x02\x02\
	\x02\u{872}\u{873}\x03\x02\x02\x02\u{873}\u{8fb}\x03\x02\x02\x02\u{874}\
	\u{875}\x05\x38\x1d\x02\u{875}\u{877}\x07\x56\x02\x02\u{876}\u{878}\x05\
	\x2a\x16\x02\u{877}\u{876}\x03\x02\x02\x02\u{877}\u{878}\x03\x02\x02\x02\
	\u{878}\u{879}\x03\x02\x02\x02\u{879}\u{87a}\x07\x7d\x02\x02\u{87a}\u{87c}\
	\x07\x4e\x02\x02\u{87b}\u{87d}\x05\u{1a8}\u{d5}\x02\u{87c}\u{87b}\x03\x02\
	\x02\x02\u{87c}\u{87d}\x03\x02\x02\x02\u{87d}\u{87e}\x03\x02\x02\x02\u{87e}\
	\u{880}\x07\x4f\x02\x02\u{87f}\u{881}\x05\u{18c}\u{c7}\x02\u{880}\u{87f}\
	\x03\x02\x02\x02\u{880}\u{881}\x03\x02\x02\x02\u{881}\u{8fb}\x03\x02\x02\
	\x02\u{882}\u{883}\x05\x3c\x1f\x02\u{883}\u{885}\x07\x56\x02\x02\u{884}\
	\u{886}\x05\x2a\x16\x02\u{885}\u{884}\x03\x02\x02\x02\u{885}\u{886}\x03\
	\x02\x02\x02\u{886}\u{887}\x03\x02\x02\x02\u{887}\u{888}\x07\x7d\x02\x02\
	\u{888}\u{88a}\x07\x4e\x02\x02\u{889}\u{88b}\x05\u{1a8}\u{d5}\x02\u{88a}\
	\u{889}\x03\x02\x02\x02\u{88a}\u{88b}\x03\x02\x02\x02\u{88b}\u{88c}\x03\
	\x02\x02\x02\u{88c}\u{88e}\x07\x4f\x02\x02\u{88d}\u{88f}\x05\u{18c}\u{c7}\
	\x02\u{88e}\u{88d}\x03\x02\x02\x02\u{88e}\u{88f}\x03\x02\x02\x02\u{88f}\
	\u{8fb}\x03\x02\x02\x02\u{890}\u{891}\x05\u{198}\u{cd}\x02\u{891}\u{893}\
	\x07\x56\x02\x02\u{892}\u{894}\x05\x2a\x16\x02\u{893}\u{892}\x03\x02\x02\
	\x02\u{893}\u{894}\x03\x02\x02\x02\u{894}\u{895}\x03\x02\x02\x02\u{895}\
	\u{896}\x07\x7d\x02\x02\u{896}\u{898}\x07\x4e\x02\x02\u{897}\u{899}\x05\
	\u{1a8}\u{d5}\x02\u{898}\u{897}\x03\x02\x02\x02\u{898}\u{899}\x03\x02\x02\
	\x02\u{899}\u{89a}\x03\x02\x02\x02\u{89a}\u{89c}\x07\x4f\x02\x02\u{89b}\
	\u{89d}\x05\u{18c}\u{c7}\x02\u{89c}\u{89b}\x03\x02\x02\x02\u{89c}\u{89d}\
	\x03\x02\x02\x02\u{89d}\u{8fb}\x03\x02\x02\x02\u{89e}\u{89f}\x07\x3b\x02\
	\x02\u{89f}\u{8a1}\x07\x56\x02\x02\u{8a0}\u{8a2}\x05\x2a\x16\x02\u{8a1}\
	\u{8a0}\x03\x02\x02\x02\u{8a1}\u{8a2}\x03\x02\x02\x02\u{8a2}\u{8a3}\x03\
	\x02\x02\x02\u{8a3}\u{8a4}\x07\x7d\x02\x02\u{8a4}\u{8a6}\x07\x4e\x02\x02\
	\u{8a5}\u{8a7}\x05\u{1a8}\u{d5}\x02\u{8a6}\u{8a5}\x03\x02\x02\x02\u{8a6}\
	\u{8a7}\x03\x02\x02\x02\u{8a7}\u{8a8}\x03\x02\x02\x02\u{8a8}\u{8aa}\x07\
	\x4f\x02\x02\u{8a9}\u{8ab}\x05\u{18c}\u{c7}\x02\u{8aa}\u{8a9}\x03\x02\x02\
	\x02\u{8aa}\u{8ab}\x03\x02\x02\x02\u{8ab}\u{8fb}\x03\x02\x02\x02\u{8ac}\
	\u{8ad}\x05\x38\x1d\x02\u{8ad}\u{8ae}\x07\x56\x02\x02\u{8ae}\u{8af}\x07\
	\x3b\x02\x02\u{8af}\u{8b1}\x07\x56\x02\x02\u{8b0}\u{8b2}\x05\x2a\x16\x02\
	\u{8b1}\u{8b0}\x03\x02\x02\x02\u{8b1}\u{8b2}\x03\x02\x02\x02\u{8b2}\u{8b3}\
	\x03\x02\x02\x02\u{8b3}\u{8b4}\x07\x7d\x02\x02\u{8b4}\u{8b6}\x07\x4e\x02\
	\x02\u{8b5}\u{8b7}\x05\u{1a8}\u{d5}\x02\u{8b6}\u{8b5}\x03\x02\x02\x02\u{8b6}\
	\u{8b7}\x03\x02\x02\x02\u{8b7}\u{8b8}\x03\x02\x02\x02\u{8b8}\u{8ba}\x07\
	\x4f\x02\x02\u{8b9}\u{8bb}\x05\u{18c}\u{c7}\x02\u{8ba}\u{8b9}\x03\x02\x02\
	\x02\u{8ba}\u{8bb}\x03\x02\x02\x02\u{8bb}\u{8fb}\x03\x02\x02\x02\u{8bc}\
	\u{8bd}\x05\x3c\x1f\x02\u{8bd}\u{8bf}\x07\x59\x02\x02\u{8be}\u{8c0}\x05\
	\x2a\x16\x02\u{8bf}\u{8be}\x03\x02\x02\x02\u{8bf}\u{8c0}\x03\x02\x02\x02\
	\u{8c0}\u{8c1}\x03\x02\x02\x02\u{8c1}\u{8c3}\x07\x7d\x02\x02\u{8c2}\u{8c4}\
	\x05\u{18c}\u{c7}\x02\u{8c3}\u{8c2}\x03\x02\x02\x02\u{8c3}\u{8c4}\x03\x02\
	\x02\x02\u{8c4}\u{8fb}\x03\x02\x02\x02\u{8c5}\u{8c6}\x05\u{198}\u{cd}\x02\
	\u{8c6}\u{8c8}\x07\x59\x02\x02\u{8c7}\u{8c9}\x05\x2a\x16\x02\u{8c8}\u{8c7}\
	\x03\x02\x02\x02\u{8c8}\u{8c9}\x03\x02\x02\x02\u{8c9}\u{8ca}\x03\x02\x02\
	\x02\u{8ca}\u{8cc}\x07\x7d\x02\x02\u{8cb}\u{8cd}\x05\u{18c}\u{c7}\x02\u{8cc}\
	\u{8cb}\x03\x02\x02\x02\u{8cc}\u{8cd}\x03\x02\x02\x02\u{8cd}\u{8fb}\x03\
	\x02\x02\x02\u{8ce}\u{8cf}\x05\x12\x0a\x02\u{8cf}\u{8d1}\x07\x59\x02\x02\
	\u{8d0}\u{8d2}\x05\x2a\x16\x02\u{8d1}\u{8d0}\x03\x02\x02\x02\u{8d1}\u{8d2}\
	\x03\x02\x02\x02\u{8d2}\u{8d3}\x03\x02\x02\x02\u{8d3}\u{8d5}\x07\x7d\x02\
	\x02\u{8d4}\u{8d6}\x05\u{18c}\u{c7}\x02\u{8d5}\u{8d4}\x03\x02\x02\x02\u{8d5}\
	\u{8d6}\x03\x02\x02\x02\u{8d6}\u{8fb}\x03\x02\x02\x02\u{8d7}\u{8d8}\x07\
	\x3b\x02\x02\u{8d8}\u{8da}\x07\x59\x02\x02\u{8d9}\u{8db}\x05\x2a\x16\x02\
	\u{8da}\u{8d9}\x03\x02\x02\x02\u{8da}\u{8db}\x03\x02\x02\x02\u{8db}\u{8dc}\
	\x03\x02\x02\x02\u{8dc}\u{8de}\x07\x7d\x02\x02\u{8dd}\u{8df}\x05\u{18c}\
	\u{c7}\x02\u{8de}\u{8dd}\x03\x02\x02\x02\u{8de}\u{8df}\x03\x02\x02\x02\u{8df}\
	\u{8fb}\x03\x02\x02\x02\u{8e0}\u{8e1}\x05\x38\x1d\x02\u{8e1}\u{8e2}\x07\
	\x56\x02\x02\u{8e2}\u{8e3}\x07\x3b\x02\x02\u{8e3}\u{8e5}\x07\x59\x02\x02\
	\u{8e4}\u{8e6}\x05\x2a\x16\x02\u{8e5}\u{8e4}\x03\x02\x02\x02\u{8e5}\u{8e6}\
	\x03\x02\x02\x02\u{8e6}\u{8e7}\x03\x02\x02\x02\u{8e7}\u{8e9}\x07\x7d\x02\
	\x02\u{8e8}\u{8ea}\x05\u{18c}\u{c7}\x02\u{8e9}\u{8e8}\x03\x02\x02\x02\u{8e9}\
	\u{8ea}\x03\x02\x02\x02\u{8ea}\u{8fb}\x03\x02\x02\x02\u{8eb}\u{8ec}\x05\
	\x18\x0d\x02\u{8ec}\u{8ee}\x07\x59\x02\x02\u{8ed}\u{8ef}\x05\x2a\x16\x02\
	\u{8ee}\u{8ed}\x03\x02\x02\x02\u{8ee}\u{8ef}\x03\x02\x02\x02\u{8ef}\u{8f0}\
	\x03\x02\x02\x02\u{8f0}\u{8f2}\x07\x32\x02\x02\u{8f1}\u{8f3}\x05\u{18c}\
	\u{c7}\x02\u{8f2}\u{8f1}\x03\x02\x02\x02\u{8f2}\u{8f3}\x03\x02\x02\x02\u{8f3}\
	\u{8fb}\x03\x02\x02\x02\u{8f4}\u{8f5}\x05\x1e\x10\x02\u{8f5}\u{8f6}\x07\
	\x59\x02\x02\u{8f6}\u{8f8}\x07\x32\x02\x02\u{8f7}\u{8f9}\x05\u{18c}\u{c7}\
	\x02\u{8f8}\u{8f7}\x03\x02\x02\x02\u{8f8}\u{8f9}\x03\x02\x02\x02\u{8f9}\
	\u{8fb}\x03\x02\x02\x02\u{8fa}\u{821}\x03\x02\x02\x02\u{8fa}\u{825}\x03\
	\x02\x02\x02\u{8fa}\u{829}\x03\x02\x02\x02\u{8fa}\u{82d}\x03\x02\x02\x02\
	\u{8fa}\u{833}\x03\x02\x02\x02\u{8fa}\u{839}\x03\x02\x02\x02\u{8fa}\u{83d}\
	\x03\x02\x02\x02\u{8fa}\u{843}\x03\x02\x02\x02\u{8fa}\u{849}\x03\x02\x02\
	\x02\u{8fa}\u{84f}\x03\x02\x02\x02\u{8fa}\u{855}\x03\x02\x02\x02\u{8fa}\
	\u{85d}\x03\x02\x02\x02\u{8fa}\u{864}\x03\x02\x02\x02\u{8fa}\u{86b}\x03\
	\x02\x02\x02\u{8fa}\u{874}\x03\x02\x02\x02\u{8fa}\u{882}\x03\x02\x02\x02\
	\u{8fa}\u{890}\x03\x02\x02\x02\u{8fa}\u{89e}\x03\x02\x02\x02\u{8fa}\u{8ac}\
	\x03\x02\x02\x02\u{8fa}\u{8bc}\x03\x02\x02\x02\u{8fa}\u{8c5}\x03\x02\x02\
	\x02\u{8fa}\u{8ce}\x03\x02\x02\x02\u{8fa}\u{8d7}\x03\x02\x02\x02\u{8fa}\
	\u{8e0}\x03\x02\x02\x02\u{8fa}\u{8eb}\x03\x02\x02\x02\u{8fa}\u{8f4}\x03\
	\x02\x02\x02\u{8fb}\u{18b}\x03\x02\x02\x02\u{8fc}\u{8fd}\x07\x56\x02\x02\
	\u{8fd}\u{8ff}\x05\u{192}\u{ca}\x02\u{8fe}\u{900}\x05\u{18c}\u{c7}\x02\u{8ff}\
	\u{8fe}\x03\x02\x02\x02\u{8ff}\u{900}\x03\x02\x02\x02\u{900}\u{922}\x03\
	\x02\x02\x02\u{901}\u{902}\x07\x56\x02\x02\u{902}\u{904}\x07\x7d\x02\x02\
	\u{903}\u{905}\x05\u{18c}\u{c7}\x02\u{904}\u{903}\x03\x02\x02\x02\u{904}\
	\u{905}\x03\x02\x02\x02\u{905}\u{922}\x03\x02\x02\x02\u{906}\u{907}\x07\
	\x52\x02\x02\u{907}\u{908}\x05\u{186}\u{c4}\x02\u{908}\u{90a}\x07\x53\x02\
	\x02\u{909}\u{90b}\x05\u{18c}\u{c7}\x02\u{90a}\u{909}\x03\x02\x02\x02\u{90a}\
	\u{90b}\x03\x02\x02\x02\u{90b}\u{922}\x03\x02\x02\x02\u{90c}\u{90e}\x07\
	\x56\x02\x02\u{90d}\u{90f}\x05\x2a\x16\x02\u{90e}\u{90d}\x03\x02\x02\x02\
	\u{90e}\u{90f}\x03\x02\x02\x02\u{90f}\u{910}\x03\x02\x02\x02\u{910}\u{911}\
	\x07\x7d\x02\x02\u{911}\u{913}\x07\x4e\x02\x02\u{912}\u{914}\x05\u{1a8}\
	\u{d5}\x02\u{913}\u{912}\x03\x02\x02\x02\u{913}\u{914}\x03\x02\x02\x02\u{914}\
	\u{915}\x03\x02\x02\x02\u{915}\u{917}\x07\x4f\x02\x02\u{916}\u{918}\x05\
	\u{18c}\u{c7}\x02\u{917}\u{916}\x03\x02\x02\x02\u{917}\u{918}\x03\x02\x02\
	\x02\u{918}\u{922}\x03\x02\x02\x02\u{919}\u{91b}\x07\x59\x02\x02\u{91a}\
	\u{91c}\x05\x2a\x16\x02\u{91b}\u{91a}\x03\x02\x02\x02\u{91b}\u{91c}\x03\
	\x02\x02\x02\u{91c}\u{91d}\x03\x02\x02\x02\u{91d}\u{91f}\x07\x7d\x02\x02\
	\u{91e}\u{920}\x05\u{18c}\u{c7}\x02\u{91f}\u{91e}\x03\x02\x02\x02\u{91f}\
	\u{920}\x03\x02\x02\x02\u{920}\u{922}\x03\x02\x02\x02\u{921}\u{8fc}\x03\
	\x02\x02\x02\u{921}\u{901}\x03\x02\x02\x02\u{921}\u{906}\x03\x02\x02\x02\
	\u{921}\u{90c}\x03\x02\x02\x02\u{921}\u{919}\x03\x02\x02\x02\u{922}\u{18d}\
	\x03\x02\x02\x02\u{923}\u{928}\x05\x38\x1d\x02\u{924}\u{925}\x07\x52\x02\
	\x02\u{925}\u{927}\x07\x53\x02\x02\u{926}\u{924}\x03\x02\x02\x02\u{927}\
	\u{92a}\x03\x02\x02\x02\u{928}\u{926}\x03\x02\x02\x02\u{928}\u{929}\x03\
	\x02\x02\x02\u{929}\u{92b}\x03\x02\x02\x02\u{92a}\u{928}\x03\x02\x02\x02\
	\u{92b}\u{92c}\x07\x56\x02\x02\u{92c}\u{92d}\x07\x1c\x02\x02\u{92d}\u{947}\
	\x03\x02\x02\x02\u{92e}\u{933}\x05\x0c\x07\x02\u{92f}\u{930}\x07\x52\x02\
	\x02\u{930}\u{932}\x07\x53\x02\x02\u{931}\u{92f}\x03\x02\x02\x02\u{932}\
	\u{935}\x03\x02\x02\x02\u{933}\u{931}\x03\x02\x02\x02\u{933}\u{934}\x03\
	\x02\x02\x02\u{934}\u{936}\x03\x02\x02\x02\u{935}\u{933}\x03\x02\x02\x02\
	\u{936}\u{937}\x07\x56\x02\x02\u{937}\u{938}\x07\x1c\x02\x02\u{938}\u{947}\
	\x03\x02\x02\x02\u{939}\u{93e}\x07\x16\x02\x02\u{93a}\u{93b}\x07\x52\x02\
	\x02\u{93b}\u{93d}\x07\x53\x02\x02\u{93c}\u{93a}\x03\x02\x02\x02\u{93d}\
	\u{940}\x03\x02\x02\x02\u{93e}\u{93c}\x03\x02\x02\x02\u{93e}\u{93f}\x03\
	\x02\x02\x02\u{93f}\u{941}\x03\x02\x02\x02\u{940}\u{93e}\x03\x02\x02\x02\
	\u{941}\u{942}\x07\x56\x02\x02\u{942}\u{947}\x07\x1c\x02\x02\u{943}\u{944}\
	\x07\x43\x02\x02\u{944}\u{945}\x07\x56\x02\x02\u{945}\u{947}\x07\x1c\x02\
	\x02\u{946}\u{923}\x03\x02\x02\x02\u{946}\u{92e}\x03\x02\x02\x02\u{946}\
	\u{939}\x03\x02\x02\x02\u{946}\u{943}\x03\x02\x02\x02\u{947}\u{18f}\x03\
	\x02\x02\x02\u{948}\u{952}\x05\u{192}\u{ca}\x02\u{949}\u{94a}\x05\x3c\x1f\
	\x02\u{94a}\u{94b}\x07\x56\x02\x02\u{94b}\u{94c}\x05\u{192}\u{ca}\x02\u{94c}\
	\u{952}\x03\x02\x02\x02\u{94d}\u{94e}\x05\u{188}\u{c5}\x02\u{94e}\u{94f}\
	\x07\x56\x02\x02\u{94f}\u{950}\x05\u{192}\u{ca}\x02\u{950}\u{952}\x03\x02\
	\x02\x02\u{951}\u{948}\x03\x02\x02\x02\u{951}\u{949}\x03\x02\x02\x02\u{951}\
	\u{94d}\x03\x02\x02\x02\u{952}\u{191}\x03\x02\x02\x02\u{953}\u{955}\x07\
	\x32\x02\x02\u{954}\u{956}\x05\x2a\x16\x02\u{955}\u{954}\x03\x02\x02\x02\
	\u{955}\u{956}\x03\x02\x02\x02\u{956}\u{957}\x03\x02\x02\x02\u{957}\u{958}\
	\x05\u{194}\u{cb}\x02\u{958}\u{95a}\x07\x4e\x02\x02\u{959}\u{95b}\x05\u{1a8}\
	\u{d5}\x02\u{95a}\u{959}\x03\x02\x02\x02\u{95a}\u{95b}\x03\x02\x02\x02\u{95b}\
	\u{95c}\x03\x02\x02\x02\u{95c}\u{95e}\x07\x4f\x02\x02\u{95d}\u{95f}\x05\
	\x70\x39\x02\u{95e}\u{95d}\x03\x02\x02\x02\u{95e}\u{95f}\x03\x02\x02\x02\
	\u{95f}\u{193}\x03\x02\x02\x02\u{960}\u{962}\x05\u{100}\u{81}\x02\u{961}\
	\u{960}\x03\x02\x02\x02\u{962}\u{965}\x03\x02\x02\x02\u{963}\u{961}\x03\
	\x02\x02\x02\u{963}\u{964}\x03\x02\x02\x02\u{964}\u{966}\x03\x02\x02\x02\
	\u{965}\u{963}\x03\x02\x02\x02\u{966}\u{971}\x07\x7d\x02\x02\u{967}\u{96b}\
	\x07\x56\x02\x02\u{968}\u{96a}\x05\u{100}\u{81}\x02\u{969}\u{968}\x03\x02\
	\x02\x02\u{96a}\u{96d}\x03\x02\x02\x02\u{96b}\u{969}\x03\x02\x02\x02\u{96b}\
	\u{96c}\x03\x02\x02\x02\u{96c}\u{96e}\x03\x02\x02\x02\u{96d}\u{96b}\x03\
	\x02\x02\x02\u{96e}\u{970}\x07\x7d\x02\x02\u{96f}\u{967}\x03\x02\x02\x02\
	\u{970}\u{973}\x03\x02\x02\x02\u{971}\u{96f}\x03\x02\x02\x02\u{971}\u{972}\
	\x03\x02\x02\x02\u{972}\u{975}\x03\x02\x02\x02\u{973}\u{971}\x03\x02\x02\
	\x02\u{974}\u{976}\x05\u{196}\u{cc}\x02\u{975}\u{974}\x03\x02\x02\x02\u{975}\
	\u{976}\x03\x02\x02\x02\u{976}\u{195}\x03\x02\x02\x02\u{977}\u{97a}\x05\
	\x2a\x16\x02\u{978}\u{97a}\x07\x06\x02\x02\u{979}\u{977}\x03\x02\x02\x02\
	\u{979}\u{978}\x03\x02\x02\x02\u{97a}\u{197}\x03\x02\x02\x02\u{97b}\u{97e}\
	\x05\u{19a}\u{ce}\x02\u{97c}\u{97e}\x05\u{19c}\u{cf}\x02\u{97d}\u{97b}\x03\
	\x02\x02\x02\u{97d}\u{97c}\x03\x02\x02\x02\u{97e}\u{199}\x03\x02\x02\x02\
	\u{97f}\u{980}\x07\x32\x02\x02\u{980}\u{981}\x05\x0a\x06\x02\u{981}\u{983}\
	\x05\u{19e}\u{d0}\x02\u{982}\u{984}\x05\x20\x11\x02\u{983}\u{982}\x03\x02\
	\x02\x02\u{983}\u{984}\x03\x02\x02\x02\u{984}\u{98c}\x03\x02\x02\x02\u{985}\
	\u{986}\x07\x32\x02\x02\u{986}\u{987}\x05\x18\x0d\x02\u{987}\u{989}\x05\
	\u{19e}\u{d0}\x02\u{988}\u{98a}\x05\x20\x11\x02\u{989}\u{988}\x03\x02\x02\
	\x02\u{989}\u{98a}\x03\x02\x02\x02\u{98a}\u{98c}\x03\x02\x02\x02\u{98b}\
	\u{97f}\x03\x02\x02\x02\u{98b}\u{985}\x03\x02\x02\x02\u{98c}\u{19b}\x03\
	\x02\x02\x02\u{98d}\u{98e}\x07\x32\x02\x02\u{98e}\u{98f}\x05\x0a\x06\x02\
	\u{98f}\u{990}\x05\x20\x11\x02\u{990}\u{991}\x05\u{112}\u{8a}\x02\u{991}\
	\u{998}\x03\x02\x02\x02\u{992}\u{993}\x07\x32\x02\x02\u{993}\u{994}\x05\
	\x16\x0c\x02\u{994}\u{995}\x05\x20\x11\x02\u{995}\u{996}\x05\u{112}\u{8a}\
	\x02\u{996}\u{998}\x03\x02\x02\x02\u{997}\u{98d}\x03\x02\x02\x02\u{997}\
	\u{992}\x03\x02\x02\x02\u{998}\u{19d}\x03\x02\x02\x02\u{999}\u{99d}\x05\
	\u{1a0}\u{d1}\x02\u{99a}\u{99c}\x05\u{1a0}\u{d1}\x02\u{99b}\u{99a}\x03\x02\
	\x02\x02\u{99c}\u{99f}\x03\x02\x02\x02\u{99d}\u{99b}\x03\x02\x02\x02\u{99d}\
	\u{99e}\x03\x02\x02\x02\u{99e}\u{19f}\x03\x02\x02\x02\u{99f}\u{99d}\x03\
	\x02\x02\x02\u{9a0}\u{9a2}\x05\u{100}\u{81}\x02\u{9a1}\u{9a0}\x03\x02\x02\
	\x02\u{9a2}\u{9a5}\x03\x02\x02\x02\u{9a3}\u{9a1}\x03\x02\x02\x02\u{9a3}\
	\u{9a4}\x03\x02\x02\x02\u{9a4}\u{9a6}\x03\x02\x02\x02\u{9a5}\u{9a3}\x03\
	\x02\x02\x02\u{9a6}\u{9a7}\x07\x52\x02\x02\u{9a7}\u{9a8}\x05\u{186}\u{c4}\
	\x02\u{9a8}\u{9a9}\x07\x53\x02\x02\u{9a9}\u{1a1}\x03\x02\x02\x02\u{9aa}\
	\u{9ab}\x05\x3c\x1f\x02\u{9ab}\u{9ac}\x07\x52\x02\x02\u{9ac}\u{9ad}\x05\
	\u{186}\u{c4}\x02\u{9ad}\u{9ae}\x07\x53\x02\x02\u{9ae}\u{9ba}\x03\x02\x02\
	\x02\u{9af}\u{9b0}\x05\u{18a}\u{c6}\x02\u{9b0}\u{9b1}\x07\x52\x02\x02\u{9b1}\
	\u{9b2}\x05\u{186}\u{c4}\x02\u{9b2}\u{9b3}\x07\x53\x02\x02\u{9b3}\u{9ba}\
	\x03\x02\x02\x02\u{9b4}\u{9b5}\x05\u{19c}\u{cf}\x02\u{9b5}\u{9b6}\x07\x52\
	\x02\x02\u{9b6}\u{9b7}\x05\u{186}\u{c4}\x02\u{9b7}\u{9b8}\x07\x53\x02\x02\
	\u{9b8}\u{9ba}\x03\x02\x02\x02\u{9b9}\u{9aa}\x03\x02\x02\x02\u{9b9}\u{9af}\
	\x03\x02\x02\x02\u{9b9}\u{9b4}\x03\x02\x02\x02\u{9ba}\u{1a3}\x03\x02\x02\
	\x02\u{9bb}\u{9bc}\x05\u{188}\u{c5}\x02\u{9bc}\u{9bd}\x07\x56\x02\x02\u{9bd}\
	\u{9be}\x07\x7d\x02\x02\u{9be}\u{9c9}\x03\x02\x02\x02\u{9bf}\u{9c0}\x07\
	\x3b\x02\x02\u{9c0}\u{9c1}\x07\x56\x02\x02\u{9c1}\u{9c9}\x07\x7d\x02\x02\
	\u{9c2}\u{9c3}\x05\x38\x1d\x02\u{9c3}\u{9c4}\x07\x56\x02\x02\u{9c4}\u{9c5}\
	\x07\x3b\x02\x02\u{9c5}\u{9c6}\x07\x56\x02\x02\u{9c6}\u{9c7}\x07\x7d\x02\
	\x02\u{9c7}\u{9c9}\x03\x02\x02\x02\u{9c8}\u{9bb}\x03\x02\x02\x02\u{9c8}\
	\u{9bf}\x03\x02\x02\x02\u{9c8}\u{9c2}\x03\x02\x02\x02\u{9c9}\u{1a5}\x03\
	\x02\x02\x02\u{9ca}\u{9cb}\x05\x3e\x20\x02\u{9cb}\u{9cd}\x07\x4e\x02\x02\
	\u{9cc}\u{9ce}\x05\u{1a8}\u{d5}\x02\u{9cd}\u{9cc}\x03\x02\x02\x02\u{9cd}\
	\u{9ce}\x03\x02\x02\x02\u{9ce}\u{9cf}\x03\x02\x02\x02\u{9cf}\u{9d0}\x07\
	\x4f\x02\x02\u{9d0}\u{a0f}\x03\x02\x02\x02\u{9d1}\u{9d2}\x05\x38\x1d\x02\
	\u{9d2}\u{9d4}\x07\x56\x02\x02\u{9d3}\u{9d5}\x05\x2a\x16\x02\u{9d4}\u{9d3}\
	\x03\x02\x02\x02\u{9d4}\u{9d5}\x03\x02\x02\x02\u{9d5}\u{9d6}\x03\x02\x02\
	\x02\u{9d6}\u{9d7}\x07\x7d\x02\x02\u{9d7}\u{9d9}\x07\x4e\x02\x02\u{9d8}\
	\u{9da}\x05\u{1a8}\u{d5}\x02\u{9d9}\u{9d8}\x03\x02\x02\x02\u{9d9}\u{9da}\
	\x03\x02\x02\x02\u{9da}\u{9db}\x03\x02\x02\x02\u{9db}\u{9dc}\x07\x4f\x02\
	\x02\u{9dc}\u{a0f}\x03\x02\x02\x02\u{9dd}\u{9de}\x05\x3c\x1f\x02\u{9de}\
	\u{9e0}\x07\x56\x02\x02\u{9df}\u{9e1}\x05\x2a\x16\x02\u{9e0}\u{9df}\x03\
	\x02\x02\x02\u{9e0}\u{9e1}\x03\x02\x02\x02\u{9e1}\u{9e2}\x03\x02\x02\x02\
	\u{9e2}\u{9e3}\x07\x7d\x02\x02\u{9e3}\u{9e5}\x07\x4e\x02\x02\u{9e4}\u{9e6}\
	\x05\u{1a8}\u{d5}\x02\u{9e5}\u{9e4}\x03\x02\x02\x02\u{9e5}\u{9e6}\x03\x02\
	\x02\x02\u{9e6}\u{9e7}\x03\x02\x02\x02\u{9e7}\u{9e8}\x07\x4f\x02\x02\u{9e8}\
	\u{a0f}\x03\x02\x02\x02\u{9e9}\u{9ea}\x05\u{188}\u{c5}\x02\u{9ea}\u{9ec}\
	\x07\x56\x02\x02\u{9eb}\u{9ed}\x05\x2a\x16\x02\u{9ec}\u{9eb}\x03\x02\x02\
	\x02\u{9ec}\u{9ed}\x03\x02\x02\x02\u{9ed}\u{9ee}\x03\x02\x02\x02\u{9ee}\
	\u{9ef}\x07\x7d\x02\x02\u{9ef}\u{9f1}\x07\x4e\x02\x02\u{9f0}\u{9f2}\x05\
	\u{1a8}\u{d5}\x02\u{9f1}\u{9f0}\x03\x02\x02\x02\u{9f1}\u{9f2}\x03\x02\x02\
	\x02\u{9f2}\u{9f3}\x03\x02\x02\x02\u{9f3}\u{9f4}\x07\x4f\x02\x02\u{9f4}\
	\u{a0f}\x03\x02\x02\x02\u{9f5}\u{9f6}\x07\x3b\x02\x02\u{9f6}\u{9f8}\x07\
	\x56\x02\x02\u{9f7}\u{9f9}\x05\x2a\x16\x02\u{9f8}\u{9f7}\x03\x02\x02\x02\
	\u{9f8}\u{9f9}\x03\x02\x02\x02\u{9f9}\u{9fa}\x03\x02\x02\x02\u{9fa}\u{9fb}\
	\x07\x7d\x02\x02\u{9fb}\u{9fd}\x07\x4e\x02\x02\u{9fc}\u{9fe}\x05\u{1a8}\
	\u{d5}\x02\u{9fd}\u{9fc}\x03\x02\x02\x02\u{9fd}\u{9fe}\x03\x02\x02\x02\u{9fe}\
	\u{9ff}\x03\x02\x02\x02\u{9ff}\u{a0f}\x07\x4f\x02\x02\u{a00}\u{a01}\x05\
	\x38\x1d\x02\u{a01}\u{a02}\x07\x56\x02\x02\u{a02}\u{a03}\x07\x3b\x02\x02\
	\u{a03}\u{a05}\x07\x56\x02\x02\u{a04}\u{a06}\x05\x2a\x16\x02\u{a05}\u{a04}\
	\x03\x02\x02\x02\u{a05}\u{a06}\x03\x02\x02\x02\u{a06}\u{a07}\x03\x02\x02\
	\x02\u{a07}\u{a08}\x07\x7d\x02\x02\u{a08}\u{a0a}\x07\x4e\x02\x02\u{a09}\
	\u{a0b}\x05\u{1a8}\u{d5}\x02\u{a0a}\u{a09}\x03\x02\x02\x02\u{a0a}\u{a0b}\
	\x03\x02\x02\x02\u{a0b}\u{a0c}\x03\x02\x02\x02\u{a0c}\u{a0d}\x07\x4f\x02\
	\x02\u{a0d}\u{a0f}\x03\x02\x02\x02\u{a0e}\u{9ca}\x03\x02\x02\x02\u{a0e}\
	\u{9d1}\x03\x02\x02\x02\u{a0e}\u{9dd}\x03\x02\x02\x02\u{a0e}\u{9e9}\x03\
	\x02\x02\x02\u{a0e}\u{9f5}\x03\x02\x02\x02\u{a0e}\u{a00}\x03\x02\x02\x02\
	\u{a0f}\u{1a7}\x03\x02\x02\x02\u{a10}\u{a15}\x05\u{186}\u{c4}\x02\u{a11}\
	\u{a12}\x07\x55\x02\x02\u{a12}\u{a14}\x05\u{186}\u{c4}\x02\u{a13}\u{a11}\
	\x03\x02\x02\x02\u{a14}\u{a17}\x03\x02\x02\x02\u{a15}\u{a13}\x03\x02\x02\
	\x02\u{a15}\u{a16}\x03\x02\x02\x02\u{a16}\u{1a9}\x03\x02\x02\x02\u{a17}\
	\u{a15}\x03\x02\x02\x02\u{a18}\u{a19}\x05\x3c\x1f\x02\u{a19}\u{a1b}\x07\
	\x59\x02\x02\u{a1a}\u{a1c}\x05\x2a\x16\x02\u{a1b}\u{a1a}\x03\x02\x02\x02\
	\u{a1b}\u{a1c}\x03\x02\x02\x02\u{a1c}\u{a1d}\x03\x02\x02\x02\u{a1d}\u{a1e}\
	\x07\x7d\x02\x02\u{a1e}\u{a48}\x03\x02\x02\x02\u{a1f}\u{a20}\x05\u{188}\
	\u{c5}\x02\u{a20}\u{a22}\x07\x59\x02\x02\u{a21}\u{a23}\x05\x2a\x16\x02\u{a22}\
	\u{a21}\x03\x02\x02\x02\u{a22}\u{a23}\x03\x02\x02\x02\u{a23}\u{a24}\x03\
	\x02\x02\x02\u{a24}\u{a25}\x07\x7d\x02\x02\u{a25}\u{a48}\x03\x02\x02\x02\
	\u{a26}\u{a27}\x05\x12\x0a\x02\u{a27}\u{a29}\x07\x59\x02\x02\u{a28}\u{a2a}\
	\x05\x2a\x16\x02\u{a29}\u{a28}\x03\x02\x02\x02\u{a29}\u{a2a}\x03\x02\x02\
	\x02\u{a2a}\u{a2b}\x03\x02\x02\x02\u{a2b}\u{a2c}\x07\x7d\x02\x02\u{a2c}\
	\u{a48}\x03\x02\x02\x02\u{a2d}\u{a2e}\x07\x3b\x02\x02\u{a2e}\u{a30}\x07\
	\x59\x02\x02\u{a2f}\u{a31}\x05\x2a\x16\x02\u{a30}\u{a2f}\x03\x02\x02\x02\
	\u{a30}\u{a31}\x03\x02\x02\x02\u{a31}\u{a32}\x03\x02\x02\x02\u{a32}\u{a48}\
	\x07\x7d\x02\x02\u{a33}\u{a34}\x05\x38\x1d\x02\u{a34}\u{a35}\x07\x56\x02\
	\x02\u{a35}\u{a36}\x07\x3b\x02\x02\u{a36}\u{a38}\x07\x59\x02\x02\u{a37}\
	\u{a39}\x05\x2a\x16\x02\u{a38}\u{a37}\x03\x02\x02\x02\u{a38}\u{a39}\x03\
	\x02\x02\x02\u{a39}\u{a3a}\x03\x02\x02\x02\u{a3a}\u{a3b}\x07\x7d\x02\x02\
	\u{a3b}\u{a48}\x03\x02\x02\x02\u{a3c}\u{a3d}\x05\x18\x0d\x02\u{a3d}\u{a3f}\
	\x07\x59\x02\x02\u{a3e}\u{a40}\x05\x2a\x16\x02\u{a3f}\u{a3e}\x03\x02\x02\
	\x02\u{a3f}\u{a40}\x03\x02\x02\x02\u{a40}\u{a41}\x03\x02\x02\x02\u{a41}\
	\u{a42}\x07\x32\x02\x02\u{a42}\u{a48}\x03\x02\x02\x02\u{a43}\u{a44}\x05\
	\x1e\x10\x02\u{a44}\u{a45}\x07\x59\x02\x02\u{a45}\u{a46}\x07\x32\x02\x02\
	\u{a46}\u{a48}\x03\x02\x02\x02\u{a47}\u{a18}\x03\x02\x02\x02\u{a47}\u{a1f}\
	\x03\x02\x02\x02\u{a47}\u{a26}\x03\x02\x02\x02\u{a47}\u{a2d}\x03\x02\x02\
	\x02\u{a47}\u{a33}\x03\x02\x02\x02\u{a47}\u{a3c}\x03\x02\x02\x02\u{a47}\
	\u{a43}\x03\x02\x02\x02\u{a48}\u{1ab}\x03\x02\x02\x02\u{a49}\u{a4b}\x05\
	\u{188}\u{c5}\x02\u{a4a}\u{a4c}\x05\u{1ae}\u{d8}\x02\u{a4b}\u{a4a}\x03\x02\
	\x02\x02\u{a4b}\u{a4c}\x03\x02\x02\x02\u{a4c}\u{a52}\x03\x02\x02\x02\u{a4d}\
	\u{a4f}\x05\x3c\x1f\x02\u{a4e}\u{a50}\x05\u{1ae}\u{d8}\x02\u{a4f}\u{a4e}\
	\x03\x02\x02\x02\u{a4f}\u{a50}\x03\x02\x02\x02\u{a50}\u{a52}\x03\x02\x02\
	\x02\u{a51}\u{a49}\x03\x02\x02\x02\u{a51}\u{a4d}\x03\x02\x02\x02\u{a52}\
	\u{1ad}\x03\x02\x02\x02\u{a53}\u{a55}\x07\x68\x02\x02\u{a54}\u{a56}\x05\
	\u{1ae}\u{d8}\x02\u{a55}\u{a54}\x03\x02\x02\x02\u{a55}\u{a56}\x03\x02\x02\
	\x02\u{a56}\u{a5c}\x03\x02\x02\x02\u{a57}\u{a59}\x07\x69\x02\x02\u{a58}\
	\u{a5a}\x05\u{1ae}\u{d8}\x02\u{a59}\u{a58}\x03\x02\x02\x02\u{a59}\u{a5a}\
	\x03\x02\x02\x02\u{a5a}\u{a5c}\x03\x02\x02\x02\u{a5b}\u{a53}\x03\x02\x02\
	\x02\u{a5b}\u{a57}\x03\x02\x02\x02\u{a5c}\u{1af}\x03\x02\x02\x02\u{a5d}\
	\u{a5e}\x05\u{1ac}\u{d7}\x02\u{a5e}\u{a5f}\x07\x68\x02\x02\u{a5f}\u{1b1}\
	\x03\x02\x02\x02\u{a60}\u{a61}\x05\u{1ac}\u{d7}\x02\u{a61}\u{a62}\x07\x69\
	\x02\x02\u{a62}\u{1b3}\x03\x02\x02\x02\u{a63}\u{a6b}\x05\u{1b6}\u{dc}\x02\
	\u{a64}\u{a6b}\x05\u{1b8}\u{dd}\x02\u{a65}\u{a66}\x07\x6a\x02\x02\u{a66}\
	\u{a6b}\x05\u{1b4}\u{db}\x02\u{a67}\u{a68}\x07\x6b\x02\x02\u{a68}\u{a6b}\
	\x05\u{1b4}\u{db}\x02\u{a69}\u{a6b}\x05\u{1ba}\u{de}\x02\u{a6a}\u{a63}\x03\
	\x02\x02\x02\u{a6a}\u{a64}\x03\x02\x02\x02\u{a6a}\u{a65}\x03\x02\x02\x02\
	\u{a6a}\u{a67}\x03\x02\x02\x02\u{a6a}\u{a69}\x03\x02\x02\x02\u{a6b}\u{1b5}\
	\x03\x02\x02\x02\u{a6c}\u{a6d}\x07\x68\x02\x02\u{a6d}\u{a6e}\x05\u{1b4}\
	\u{db}\x02\u{a6e}\u{1b7}\x03\x02\x02\x02\u{a6f}\u{a70}\x07\x69\x02\x02\u{a70}\
	\u{a71}\x05\u{1b4}\u{db}\x02\u{a71}\u{1b9}\x03\x02\x02\x02\u{a72}\u{a7a}\
	\x05\u{1ac}\u{d7}\x02\u{a73}\u{a74}\x07\x5e\x02\x02\u{a74}\u{a7a}\x05\u{1b4}\
	\u{db}\x02\u{a75}\u{a76}\x07\x5d\x02\x02\u{a76}\u{a7a}\x05\u{1b4}\u{db}\
	\x02\u{a77}\u{a7a}\x05\u{1bc}\u{df}\x02\u{a78}\u{a7a}\x05\u{1e8}\u{f5}\x02\
	\u{a79}\u{a72}\x03\x02\x02\x02\u{a79}\u{a73}\x03\x02\x02\x02\u{a79}\u{a75}\
	\x03\x02\x02\x02\u{a79}\u{a77}\x03\x02\x02\x02\u{a79}\u{a78}\x03\x02\x02\
	\x02\u{a7a}\u{1bb}\x03\x02\x02\x02\u{a7b}\u{a7c}\x07\x4e\x02\x02\u{a7c}\
	\u{a7d}\x05\x0a\x06\x02\u{a7d}\u{a7e}\x07\x4f\x02\x02\u{a7e}\u{a7f}\x05\
	\u{1b4}\u{db}\x02\u{a7f}\u{a97}\x03\x02\x02\x02\u{a80}\u{a81}\x07\x4e\x02\
	\x02\u{a81}\u{a85}\x05\x12\x0a\x02\u{a82}\u{a84}\x05\x28\x15\x02\u{a83}\
	\u{a82}\x03\x02\x02\x02\u{a84}\u{a87}\x03\x02\x02\x02\u{a85}\u{a83}\x03\
	\x02\x02\x02\u{a85}\u{a86}\x03\x02\x02\x02\u{a86}\u{a88}\x03\x02\x02\x02\
	\u{a87}\u{a85}\x03\x02\x02\x02\u{a88}\u{a89}\x07\x4f\x02\x02\u{a89}\u{a8a}\
	\x05\u{1ba}\u{de}\x02\u{a8a}\u{a97}\x03\x02\x02\x02\u{a8b}\u{a8c}\x07\x4e\
	\x02\x02\u{a8c}\u{a90}\x05\x12\x0a\x02\u{a8d}\u{a8f}\x05\x28\x15\x02\u{a8e}\
	\u{a8d}\x03\x02\x02\x02\u{a8f}\u{a92}\x03\x02\x02\x02\u{a90}\u{a8e}\x03\
	\x02\x02\x02\u{a90}\u{a91}\x03\x02\x02\x02\u{a91}\u{a93}\x03\x02\x02\x02\
	\u{a92}\u{a90}\x03\x02\x02\x02\u{a93}\u{a94}\x07\x4f\x02\x02\u{a94}\u{a95}\
	\x05\u{1dc}\u{ef}\x02\u{a95}\u{a97}\x03\x02\x02\x02\u{a96}\u{a7b}\x03\x02\
	\x02\x02\u{a96}\u{a80}\x03\x02\x02\x02\u{a96}\u{a8b}\x03\x02\x02\x02\u{a97}\
	\u{1bd}\x03\x02\x02\x02\u{a98}\u{a99}\x08\u{e0}\x01\x02\u{a99}\u{a9a}\x05\
	\u{1b4}\u{db}\x02\u{a9a}\u{aa6}\x03\x02\x02\x02\u{a9b}\u{a9c}\x0c\x05\x02\
	\x02\u{a9c}\u{a9d}\x07\x6c\x02\x02\u{a9d}\u{aa5}\x05\u{1b4}\u{db}\x02\u{a9e}\
	\u{a9f}\x0c\x04\x02\x02\u{a9f}\u{aa0}\x07\x6d\x02\x02\u{aa0}\u{aa5}\x05\
	\u{1b4}\u{db}\x02\u{aa1}\u{aa2}\x0c\x03\x02\x02\u{aa2}\u{aa3}\x07\x71\x02\
	\x02\u{aa3}\u{aa5}\x05\u{1b4}\u{db}\x02\u{aa4}\u{a9b}\x03\x02\x02\x02\u{aa4}\
	\u{a9e}\x03\x02\x02\x02\u{aa4}\u{aa1}\x03\x02\x02\x02\u{aa5}\u{aa8}\x03\
	\x02\x02\x02\u{aa6}\u{aa4}\x03\x02\x02\x02\u{aa6}\u{aa7}\x03\x02\x02\x02\
	\u{aa7}\u{1bf}\x03\x02\x02\x02\u{aa8}\u{aa6}\x03\x02\x02\x02\u{aa9}\u{aaa}\
	\x08\u{e1}\x01\x02\u{aaa}\u{aab}\x05\u{1be}\u{e0}\x02\u{aab}\u{ab4}\x03\
	\x02\x02\x02\u{aac}\u{aad}\x0c\x04\x02\x02\u{aad}\u{aae}\x07\x6a\x02\x02\
	\u{aae}\u{ab3}\x05\u{1be}\u{e0}\x02\u{aaf}\u{ab0}\x0c\x03\x02\x02\u{ab0}\
	\u{ab1}\x07\x6b\x02\x02\u{ab1}\u{ab3}\x05\u{1be}\u{e0}\x02\u{ab2}\u{aac}\
	\x03\x02\x02\x02\u{ab2}\u{aaf}\x03\x02\x02\x02\u{ab3}\u{ab6}\x03\x02\x02\
	\x02\u{ab4}\u{ab2}\x03\x02\x02\x02\u{ab4}\u{ab5}\x03\x02\x02\x02\u{ab5}\
	\u{1c1}\x03\x02\x02\x02\u{ab6}\u{ab4}\x03\x02\x02\x02\u{ab7}\u{ab8}\x08\
	\u{e2}\x01\x02\u{ab8}\u{ab9}\x05\u{1c0}\u{e1}\x02\u{ab9}\u{ac9}\x03\x02\
	\x02\x02\u{aba}\u{abb}\x0c\x05\x02\x02\u{abb}\u{abc}\x07\x5c\x02\x02\u{abc}\
	\u{abd}\x07\x5c\x02\x02\u{abd}\u{ac8}\x05\u{1c0}\u{e1}\x02\u{abe}\u{abf}\
	\x0c\x04\x02\x02\u{abf}\u{ac0}\x07\x5b\x02\x02\u{ac0}\u{ac1}\x07\x5b\x02\
	\x02\u{ac1}\u{ac8}\x05\u{1c0}\u{e1}\x02\u{ac2}\u{ac3}\x0c\x03\x02\x02\u{ac3}\
	\u{ac4}\x07\x5b\x02\x02\u{ac4}\u{ac5}\x07\x5b\x02\x02\u{ac5}\u{ac6}\x07\
	\x5b\x02\x02\u{ac6}\u{ac8}\x05\u{1c0}\u{e1}\x02\u{ac7}\u{aba}\x03\x02\x02\
	\x02\u{ac7}\u{abe}\x03\x02\x02\x02\u{ac7}\u{ac2}\x03\x02\x02\x02\u{ac8}\
	\u{acb}\x03\x02\x02\x02\u{ac9}\u{ac7}\x03\x02\x02\x02\u{ac9}\u{aca}\x03\
	\x02\x02\x02\u{aca}\u{1c3}\x03\x02\x02\x02\u{acb}\u{ac9}\x03\x02\x02\x02\
	\u{acc}\u{acd}\x08\u{e3}\x01\x02\u{acd}\u{ace}\x05\u{1c2}\u{e2}\x02\u{ace}\
	\u{ae3}\x03\x02\x02\x02\u{acf}\u{ad0}\x0c\x07\x02\x02\u{ad0}\u{ad1}\x07\
	\x5c\x02\x02\u{ad1}\u{ae2}\x05\u{1c2}\u{e2}\x02\u{ad2}\u{ad3}\x0c\x06\x02\
	\x02\u{ad3}\u{ad4}\x07\x5b\x02\x02\u{ad4}\u{ae2}\x05\u{1c2}\u{e2}\x02\u{ad5}\
	\u{ad6}\x0c\x05\x02\x02\u{ad6}\u{ad7}\x07\x63\x02\x02\u{ad7}\u{ae2}\x05\
	\u{1c2}\u{e2}\x02\u{ad8}\u{ad9}\x0c\x04\x02\x02\u{ad9}\u{ada}\x07\x64\x02\
	\x02\u{ada}\u{ae2}\x05\u{1c2}\u{e2}\x02\u{adb}\u{adc}\x0c\x03\x02\x02\u{adc}\
	\u{adf}\x07\x2d\x02\x02\u{add}\u{ae0}\x05\x12\x0a\x02\u{ade}\u{ae0}\x05\
	\u{182}\u{c2}\x02\u{adf}\u{add}\x03\x02\x02\x02\u{adf}\u{ade}\x03\x02\x02\
	\x02\u{ae0}\u{ae2}\x03\x02\x02\x02\u{ae1}\u{acf}\x03\x02\x02\x02\u{ae1}\
	\u{ad2}\x03\x02\x02\x02\u{ae1}\u{ad5}\x03\x02\x02\x02\u{ae1}\u{ad8}\x03\
	\x02\x02\x02\u{ae1}\u{adb}\x03\x02\x02\x02\u{ae2}\u{ae5}\x03\x02\x02\x02\
	\u{ae3}\u{ae1}\x03\x02\x02\x02\u{ae3}\u{ae4}\x03\x02\x02\x02\u{ae4}\u{1c5}\
	\x03\x02\x02\x02\u{ae5}\u{ae3}\x03\x02\x02\x02\u{ae6}\u{ae7}\x08\u{e4}\x01\
	\x02\u{ae7}\u{ae8}\x05\u{1c4}\u{e3}\x02\u{ae8}\u{af1}\x03\x02\x02\x02\u{ae9}\
	\u{aea}\x0c\x04\x02\x02\u{aea}\u{aeb}\x07\x62\x02\x02\u{aeb}\u{af0}\x05\
	\u{1c4}\u{e3}\x02\u{aec}\u{aed}\x0c\x03\x02\x02\u{aed}\u{aee}\x07\x65\x02\
	\x02\u{aee}\u{af0}\x05\u{1c4}\u{e3}\x02\u{aef}\u{ae9}\x03\x02\x02\x02\u{aef}\
	\u{aec}\x03\x02\x02\x02\u{af0}\u{af3}\x03\x02\x02\x02\u{af1}\u{aef}\x03\
	\x02\x02\x02\u{af1}\u{af2}\x03\x02\x02\x02\u{af2}\u{1c7}\x03\x02\x02\x02\
	\u{af3}\u{af1}\x03\x02\x02\x02\u{af4}\u{af5}\x08\u{e5}\x01\x02\u{af5}\u{af6}\
	\x05\u{1c6}\u{e4}\x02\u{af6}\u{afc}\x03\x02\x02\x02\u{af7}\u{af8}\x0c\x03\
	\x02\x02\u{af8}\u{af9}\x07\x6e\x02\x02\u{af9}\u{afb}\x05\u{1c6}\u{e4}\x02\
	\u{afa}\u{af7}\x03\x02\x02\x02\u{afb}\u{afe}\x03\x02\x02\x02\u{afc}\u{afa}\
	\x03\x02\x02\x02\u{afc}\u{afd}\x03\x02\x02\x02\u{afd}\u{1c9}\x03\x02\x02\
	\x02\u{afe}\u{afc}\x03\x02\x02\x02\u{aff}\u{b00}\x08\u{e6}\x01\x02\u{b00}\
	\u{b01}\x05\u{1c8}\u{e5}\x02\u{b01}\u{b07}\x03\x02\x02\x02\u{b02}\u{b03}\
	\x0c\x03\x02\x02\u{b03}\u{b04}\x07\x70\x02\x02\u{b04}\u{b06}\x05\u{1c8}\
	\u{e5}\x02\u{b05}\u{b02}\x03\x02\x02\x02\u{b06}\u{b09}\x03\x02\x02\x02\u{b07}\
	\u{b05}\x03\x02\x02\x02\u{b07}\u{b08}\x03\x02\x02\x02\u{b08}\u{1cb}\x03\
	\x02\x02\x02\u{b09}\u{b07}\x03\x02\x02\x02\u{b0a}\u{b0b}\x08\u{e7}\x01\x02\
	\u{b0b}\u{b0c}\x05\u{1ca}\u{e6}\x02\u{b0c}\u{b12}\x03\x02\x02\x02\u{b0d}\
	\u{b0e}\x0c\x03\x02\x02\u{b0e}\u{b0f}\x07\x6f\x02\x02\u{b0f}\u{b11}\x05\
	\u{1ca}\u{e6}\x02\u{b10}\u{b0d}\x03\x02\x02\x02\u{b11}\u{b14}\x03\x02\x02\
	\x02\u{b12}\u{b10}\x03\x02\x02\x02\u{b12}\u{b13}\x03\x02\x02\x02\u{b13}\
	\u{1cd}\x03\x02\x02\x02\u{b14}\u{b12}\x03\x02\x02\x02\u{b15}\u{b16}\x08\
	\u{e8}\x01\x02\u{b16}\u{b17}\x05\u{1cc}\u{e7}\x02\u{b17}\u{b1d}\x03\x02\
	\x02\x02\u{b18}\u{b19}\x0c\x03\x02\x02\u{b19}\u{b1a}\x07\x66\x02\x02\u{b1a}\
	\u{b1c}\x05\u{1cc}\u{e7}\x02\u{b1b}\u{b18}\x03\x02\x02\x02\u{b1c}\u{b1f}\
	\x03\x02\x02\x02\u{b1d}\u{b1b}\x03\x02\x02\x02\u{b1d}\u{b1e}\x03\x02\x02\
	\x02\u{b1e}\u{1cf}\x03\x02\x02\x02\u{b1f}\u{b1d}\x03\x02\x02\x02\u{b20}\
	\u{b21}\x08\u{e9}\x01\x02\u{b21}\u{b22}\x05\u{1ce}\u{e8}\x02\u{b22}\u{b28}\
	\x03\x02\x02\x02\u{b23}\u{b24}\x0c\x03\x02\x02\u{b24}\u{b25}\x07\x67\x02\
	\x02\u{b25}\u{b27}\x05\u{1ce}\u{e8}\x02\u{b26}\u{b23}\x03\x02\x02\x02\u{b27}\
	\u{b2a}\x03\x02\x02\x02\u{b28}\u{b26}\x03\x02\x02\x02\u{b28}\u{b29}\x03\
	\x02\x02\x02\u{b29}\u{1d1}\x03\x02\x02\x02\u{b2a}\u{b28}\x03\x02\x02\x02\
	\u{b2b}\u{b39}\x05\u{1d0}\u{e9}\x02\u{b2c}\u{b2d}\x05\u{1d0}\u{e9}\x02\u{b2d}\
	\u{b2e}\x07\x5f\x02\x02\u{b2e}\u{b2f}\x05\u{186}\u{c4}\x02\u{b2f}\u{b30}\
	\x07\x60\x02\x02\u{b30}\u{b31}\x05\u{1d2}\u{ea}\x02\u{b31}\u{b39}\x03\x02\
	\x02\x02\u{b32}\u{b33}\x05\u{1d0}\u{e9}\x02\u{b33}\u{b34}\x07\x5f\x02\x02\
	\u{b34}\u{b35}\x05\u{186}\u{c4}\x02\u{b35}\u{b36}\x07\x60\x02\x02\u{b36}\
	\u{b37}\x05\u{1dc}\u{ef}\x02\u{b37}\u{b39}\x03\x02\x02\x02\u{b38}\u{b2b}\
	\x03\x02\x02\x02\u{b38}\u{b2c}\x03\x02\x02\x02\u{b38}\u{b32}\x03\x02\x02\
	\x02\u{b39}\u{1d3}\x03\x02\x02\x02\u{b3a}\u{b3d}\x05\u{1d2}\u{ea}\x02\u{b3b}\
	\u{b3d}\x05\u{1d6}\u{ec}\x02\u{b3c}\u{b3a}\x03\x02\x02\x02\u{b3c}\u{b3b}\
	\x03\x02\x02\x02\u{b3d}\u{1d5}\x03\x02\x02\x02\u{b3e}\u{b3f}\x05\u{1d8}\
	\u{ed}\x02\u{b3f}\u{b40}\x05\u{1da}\u{ee}\x02\u{b40}\u{b41}\x05\u{186}\u{c4}\
	\x02\u{b41}\u{1d7}\x03\x02\x02\x02\u{b42}\u{b46}\x05\x3c\x1f\x02\u{b43}\
	\u{b46}\x05\u{1a4}\u{d3}\x02\u{b44}\u{b46}\x05\u{1a2}\u{d2}\x02\u{b45}\u{b42}\
	\x03\x02\x02\x02\u{b45}\u{b43}\x03\x02\x02\x02\u{b45}\u{b44}\x03\x02\x02\
	\x02\u{b46}\u{1d9}\x03\x02\x02\x02\u{b47}\u{b48}\x09\x07\x02\x02\u{b48}\
	\u{1db}\x03\x02\x02\x02\u{b49}\u{b4a}\x05\u{1de}\u{f0}\x02\u{b4a}\u{b4b}\
	\x07\x61\x02\x02\u{b4b}\u{b4c}\x05\u{1e6}\u{f4}\x02\u{b4c}\u{1dd}\x03\x02\
	\x02\x02\u{b4d}\u{b4f}\x07\x4e\x02\x02\u{b4e}\u{b50}\x05\u{1e0}\u{f1}\x02\
	\u{b4f}\u{b4e}\x03\x02\x02\x02\u{b4f}\u{b50}\x03\x02\x02\x02\u{b50}\u{b51}\
	\x03\x02\x02\x02\u{b51}\u{b54}\x07\x4f\x02\x02\u{b52}\u{b54}\x07\x7d\x02\
	\x02\u{b53}\u{b4d}\x03\x02\x02\x02\u{b53}\u{b52}\x03\x02\x02\x02\u{b54}\
	\u{1df}\x03\x02\x02\x02\u{b55}\u{b5a}\x05\u{1e2}\u{f2}\x02\u{b56}\u{b57}\
	\x07\x55\x02\x02\u{b57}\u{b59}\x05\u{1e2}\u{f2}\x02\u{b58}\u{b56}\x03\x02\
	\x02\x02\u{b59}\u{b5c}\x03\x02\x02\x02\u{b5a}\u{b58}\x03\x02\x02\x02\u{b5a}\
	\u{b5b}\x03\x02\x02\x02\u{b5b}\u{b66}\x03\x02\x02\x02\u{b5c}\u{b5a}\x03\
	\x02\x02\x02\u{b5d}\u{b62}\x07\x7d\x02\x02\u{b5e}\u{b5f}\x07\x55\x02\x02\
	\u{b5f}\u{b61}\x07\x7d\x02\x02\u{b60}\u{b5e}\x03\x02\x02\x02\u{b61}\u{b64}\
	\x03\x02\x02\x02\u{b62}\u{b60}\x03\x02\x02\x02\u{b62}\u{b63}\x03\x02\x02\
	\x02\u{b63}\u{b66}\x03\x02\x02\x02\u{b64}\u{b62}\x03\x02\x02\x02\u{b65}\
	\u{b55}\x03\x02\x02\x02\u{b65}\u{b5d}\x03\x02\x02\x02\u{b66}\u{1e1}\x03\
	\x02\x02\x02\u{b67}\u{b69}\x05\u{a6}\x54\x02\u{b68}\u{b67}\x03\x02\x02\x02\
	\u{b69}\u{b6c}\x03\x02\x02\x02\u{b6a}\u{b68}\x03\x02\x02\x02\u{b6a}\u{b6b}\
	\x03\x02\x02\x02\u{b6b}\u{b6d}\x03\x02\x02\x02\u{b6c}\u{b6a}\x03\x02\x02\
	\x02\u{b6d}\u{b6e}\x05\u{1e4}\u{f3}\x02\u{b6e}\u{b6f}\x05\x7e\x40\x02\u{b6f}\
	\u{b72}\x03\x02\x02\x02\u{b70}\u{b72}\x05\u{a4}\x53\x02\u{b71}\u{b6a}\x03\
	\x02\x02\x02\u{b71}\u{b70}\x03\x02\x02\x02\u{b72}\u{1e3}\x03\x02\x02\x02\
	\u{b73}\u{b76}\x05\u{82}\x42\x02\u{b74}\u{b76}\x07\x11\x02\x02\u{b75}\u{b73}\
	\x03\x02\x02\x02\u{b75}\u{b74}\x03\x02\x02\x02\u{b76}\u{1e5}\x03\x02\x02\
	\x02\u{b77}\u{b7a}\x05\u{186}\u{c4}\x02\u{b78}\u{b7a}\x05\u{116}\u{8c}\x02\
	\u{b79}\u{b77}\x03\x02\x02\x02\u{b79}\u{b78}\x03\x02\x02\x02\u{b7a}\u{1e7}\
	\x03\x02\x02\x02\u{b7b}\u{b7c}\x07\x3c\x02\x02\u{b7c}\u{b7d}\x07\x4e\x02\
	\x02\u{b7d}\u{b7e}\x05\u{186}\u{c4}\x02\u{b7e}\u{b7f}\x07\x4f\x02\x02\u{b7f}\
	\u{b80}\x05\u{13e}\u{a0}\x02\u{b80}\u{1e9}\x03\x02\x02\x02\u{b81}\u{b82}\
	\x05\u{186}\u{c4}\x02\u{b82}\u{1eb}\x03\x02\x02\x02\u{16a}\u{1f8}\u{1fd}\
	\u{201}\u{20a}\u{210}\u{215}\u{218}\u{21d}\u{222}\u{227}\u{22a}\u{22f}\u{234}\
	\u{23b}\u{240}\u{247}\u{24c}\u{24e}\u{255}\u{263}\u{268}\u{270}\u{277}\u{27d}\
	\u{282}\u{28c}\u{28f}\u{29d}\u{2a2}\u{2a7}\u{2ac}\u{2b2}\u{2b7}\u{2bc}\u{2c1}\
	\u{2c6}\u{2cb}\u{2d4}\u{2d8}\u{2db}\u{2e0}\u{2e6}\u{2ec}\u{2f4}\u{2fd}\u{308}\
	\u{325}\u{32a}\u{32e}\u{336}\u{33d}\u{346}\u{354}\u{357}\u{363}\u{366}\u{376}\
	\u{37b}\u{382}\u{387}\u{38d}\u{390}\u{393}\u{396}\u{3a4}\u{3af}\u{3bd}\u{3c6}\
	\u{3cd}\u{3d6}\u{3dd}\u{3e2}\u{3f1}\u{3f8}\u{3fe}\u{402}\u{406}\u{40a}\u{40e}\
	\u{413}\u{41a}\u{41d}\u{421}\u{424}\u{42a}\u{42f}\u{432}\u{436}\u{43a}\u{440}\
	\u{445}\u{447}\u{450}\u{457}\u{467}\u{46d}\u{470}\u{475}\u{479}\u{480}\u{483}\
	\u{487}\u{48c}\u{492}\u{49b}\u{4a1}\u{4a8}\u{4ad}\u{4b4}\u{4bc}\u{4c6}\u{4cb}\
	\u{4cf}\u{4d9}\u{4de}\u{4e6}\u{4e9}\u{4f0}\u{4f3}\u{4fb}\u{4fe}\u{503}\u{508}\
	\u{50e}\u{512}\u{517}\u{51c}\u{521}\u{527}\u{52d}\u{530}\u{533}\u{53c}\u{542}\
	\u{548}\u{54b}\u{54e}\u{556}\u{55c}\u{562}\u{566}\u{56c}\u{575}\u{57b}\u{582}\
	\u{587}\u{58e}\u{59a}\u{5a1}\u{5a6}\u{5ae}\u{5b3}\u{5b9}\u{5bc}\u{5bf}\u{5cc}\
	\u{5d7}\u{5de}\u{5e8}\u{5ed}\u{5f8}\u{5fd}\u{60a}\u{60f}\u{61b}\u{625}\u{62a}\
	\u{632}\u{635}\u{63c}\u{644}\u{64a}\u{653}\u{65d}\u{661}\u{664}\u{66d}\u{67b}\
	\u{67e}\u{687}\u{68c}\u{694}\u{69a}\u{69e}\u{6a3}\u{6a8}\u{6ac}\u{6b7}\u{6be}\
	\u{6cd}\u{6e3}\u{6ff}\u{70e}\u{717}\u{71f}\u{723}\u{72c}\u{735}\u{740}\u{744}\
	\u{75e}\u{762}\u{767}\u{76b}\u{76f}\u{777}\u{77b}\u{77f}\u{786}\u{78f}\u{7a4}\
	\u{7aa}\u{7b0}\u{7c9}\u{7ce}\u{7d4}\u{7e0}\u{7eb}\u{7f5}\u{7f8}\u{7fd}\u{806}\
	\u{80b}\u{80f}\u{81b}\u{81f}\u{823}\u{827}\u{82b}\u{831}\u{837}\u{83b}\u{841}\
	\u{847}\u{84d}\u{853}\u{85b}\u{862}\u{869}\u{86e}\u{872}\u{877}\u{87c}\u{880}\
	\u{885}\u{88a}\u{88e}\u{893}\u{898}\u{89c}\u{8a1}\u{8a6}\u{8aa}\u{8b1}\u{8b6}\
	\u{8ba}\u{8bf}\u{8c3}\u{8c8}\u{8cc}\u{8d1}\u{8d5}\u{8da}\u{8de}\u{8e5}\u{8e9}\
	\u{8ee}\u{8f2}\u{8f8}\u{8fa}\u{8ff}\u{904}\u{90a}\u{90e}\u{913}\u{917}\u{91b}\
	\u{91f}\u{921}\u{928}\u{933}\u{93e}\u{946}\u{951}\u{955}\u{95a}\u{95e}\u{963}\
	\u{96b}\u{971}\u{975}\u{979}\u{97d}\u{983}\u{989}\u{98b}\u{997}\u{99d}\u{9a3}\
	\u{9b9}\u{9c8}\u{9cd}\u{9d4}\u{9d9}\u{9e0}\u{9e5}\u{9ec}\u{9f1}\u{9f8}\u{9fd}\
	\u{a05}\u{a0a}\u{a0e}\u{a15}\u{a1b}\u{a22}\u{a29}\u{a30}\u{a38}\u{a3f}\u{a47}\
	\u{a4b}\u{a4f}\u{a51}\u{a55}\u{a59}\u{a5b}\u{a6a}\u{a79}\u{a85}\u{a90}\u{a96}\
	\u{aa4}\u{aa6}\u{ab2}\u{ab4}\u{ac7}\u{ac9}\u{adf}\u{ae1}\u{ae3}\u{aef}\u{af1}\
	\u{afc}\u{b07}\u{b12}\u{b1d}\u{b28}\u{b38}\u{b3c}\u{b45}\u{b4f}\u{b53}\u{b5a}\
	\u{b62}\u{b65}\u{b6a}\u{b71}\u{b75}\u{b79}";

